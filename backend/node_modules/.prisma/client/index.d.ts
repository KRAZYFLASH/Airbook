
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Airport
 * 
 */
export type Airport = $Result.DefaultSelection<Prisma.$AirportPayload>
/**
 * Model Airline
 * 
 */
export type Airline = $Result.DefaultSelection<Prisma.$AirlinePayload>
/**
 * Model AircraftType
 * 
 */
export type AircraftType = $Result.DefaultSelection<Prisma.$AircraftTypePayload>
/**
 * Model Aircraft
 * 
 */
export type Aircraft = $Result.DefaultSelection<Prisma.$AircraftPayload>
/**
 * Model Destination
 * 
 */
export type Destination = $Result.DefaultSelection<Prisma.$DestinationPayload>
/**
 * Model Flight
 * 
 */
export type Flight = $Result.DefaultSelection<Prisma.$FlightPayload>
/**
 * Model FlightSchedule
 * 
 */
export type FlightSchedule = $Result.DefaultSelection<Prisma.$FlightSchedulePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model PassengerDetail
 * 
 */
export type PassengerDetail = $Result.DefaultSelection<Prisma.$PassengerDetailPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model AdminFlightSchedule
 * 
 */
export type AdminFlightSchedule = $Result.DefaultSelection<Prisma.$AdminFlightSchedulePayload>
/**
 * Model AdminPromotion
 * 
 */
export type AdminPromotion = $Result.DefaultSelection<Prisma.$AdminPromotionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airport`: Exposes CRUD operations for the **Airport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airports
    * const airports = await prisma.airport.findMany()
    * ```
    */
  get airport(): Prisma.AirportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airline`: Exposes CRUD operations for the **Airline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airlines
    * const airlines = await prisma.airline.findMany()
    * ```
    */
  get airline(): Prisma.AirlineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aircraftType`: Exposes CRUD operations for the **AircraftType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AircraftTypes
    * const aircraftTypes = await prisma.aircraftType.findMany()
    * ```
    */
  get aircraftType(): Prisma.AircraftTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aircraft`: Exposes CRUD operations for the **Aircraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aircraft
    * const aircraft = await prisma.aircraft.findMany()
    * ```
    */
  get aircraft(): Prisma.AircraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destination`: Exposes CRUD operations for the **Destination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinations
    * const destinations = await prisma.destination.findMany()
    * ```
    */
  get destination(): Prisma.DestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flight`: Exposes CRUD operations for the **Flight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flights
    * const flights = await prisma.flight.findMany()
    * ```
    */
  get flight(): Prisma.FlightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flightSchedule`: Exposes CRUD operations for the **FlightSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlightSchedules
    * const flightSchedules = await prisma.flightSchedule.findMany()
    * ```
    */
  get flightSchedule(): Prisma.FlightScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passengerDetail`: Exposes CRUD operations for the **PassengerDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PassengerDetails
    * const passengerDetails = await prisma.passengerDetail.findMany()
    * ```
    */
  get passengerDetail(): Prisma.PassengerDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminFlightSchedule`: Exposes CRUD operations for the **AdminFlightSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminFlightSchedules
    * const adminFlightSchedules = await prisma.adminFlightSchedule.findMany()
    * ```
    */
  get adminFlightSchedule(): Prisma.AdminFlightScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPromotion`: Exposes CRUD operations for the **AdminPromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPromotions
    * const adminPromotions = await prisma.adminPromotion.findMany()
    * ```
    */
  get adminPromotion(): Prisma.AdminPromotionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Country: 'Country',
    City: 'City',
    Airport: 'Airport',
    Airline: 'Airline',
    AircraftType: 'AircraftType',
    Aircraft: 'Aircraft',
    Destination: 'Destination',
    Flight: 'Flight',
    FlightSchedule: 'FlightSchedule',
    Booking: 'Booking',
    PassengerDetail: 'PassengerDetail',
    Payment: 'Payment',
    Review: 'Review',
    Promotion: 'Promotion',
    Notification: 'Notification',
    SystemConfig: 'SystemConfig',
    AdminFlightSchedule: 'AdminFlightSchedule',
    AdminPromotion: 'AdminPromotion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "country" | "city" | "airport" | "airline" | "aircraftType" | "aircraft" | "destination" | "flight" | "flightSchedule" | "booking" | "passengerDetail" | "payment" | "review" | "promotion" | "notification" | "systemConfig" | "adminFlightSchedule" | "adminPromotion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Airport: {
        payload: Prisma.$AirportPayload<ExtArgs>
        fields: Prisma.AirportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AirportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AirportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          findFirst: {
            args: Prisma.AirportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AirportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          findMany: {
            args: Prisma.AirportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>[]
          }
          create: {
            args: Prisma.AirportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          createMany: {
            args: Prisma.AirportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AirportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>[]
          }
          delete: {
            args: Prisma.AirportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          update: {
            args: Prisma.AirportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          deleteMany: {
            args: Prisma.AirportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AirportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AirportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>[]
          }
          upsert: {
            args: Prisma.AirportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirportPayload>
          }
          aggregate: {
            args: Prisma.AirportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirport>
          }
          groupBy: {
            args: Prisma.AirportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AirportCountArgs<ExtArgs>
            result: $Utils.Optional<AirportCountAggregateOutputType> | number
          }
        }
      }
      Airline: {
        payload: Prisma.$AirlinePayload<ExtArgs>
        fields: Prisma.AirlineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AirlineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AirlineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          findFirst: {
            args: Prisma.AirlineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AirlineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          findMany: {
            args: Prisma.AirlineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>[]
          }
          create: {
            args: Prisma.AirlineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          createMany: {
            args: Prisma.AirlineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AirlineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>[]
          }
          delete: {
            args: Prisma.AirlineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          update: {
            args: Prisma.AirlineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          deleteMany: {
            args: Prisma.AirlineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AirlineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AirlineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>[]
          }
          upsert: {
            args: Prisma.AirlineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirlinePayload>
          }
          aggregate: {
            args: Prisma.AirlineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirline>
          }
          groupBy: {
            args: Prisma.AirlineGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.AirlineCountArgs<ExtArgs>
            result: $Utils.Optional<AirlineCountAggregateOutputType> | number
          }
        }
      }
      AircraftType: {
        payload: Prisma.$AircraftTypePayload<ExtArgs>
        fields: Prisma.AircraftTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AircraftTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AircraftTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          findFirst: {
            args: Prisma.AircraftTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AircraftTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          findMany: {
            args: Prisma.AircraftTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>[]
          }
          create: {
            args: Prisma.AircraftTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          createMany: {
            args: Prisma.AircraftTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AircraftTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>[]
          }
          delete: {
            args: Prisma.AircraftTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          update: {
            args: Prisma.AircraftTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          deleteMany: {
            args: Prisma.AircraftTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AircraftTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AircraftTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>[]
          }
          upsert: {
            args: Prisma.AircraftTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftTypePayload>
          }
          aggregate: {
            args: Prisma.AircraftTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAircraftType>
          }
          groupBy: {
            args: Prisma.AircraftTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AircraftTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AircraftTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AircraftTypeCountAggregateOutputType> | number
          }
        }
      }
      Aircraft: {
        payload: Prisma.$AircraftPayload<ExtArgs>
        fields: Prisma.AircraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AircraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AircraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          findFirst: {
            args: Prisma.AircraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AircraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          findMany: {
            args: Prisma.AircraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>[]
          }
          create: {
            args: Prisma.AircraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          createMany: {
            args: Prisma.AircraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AircraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>[]
          }
          delete: {
            args: Prisma.AircraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          update: {
            args: Prisma.AircraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          deleteMany: {
            args: Prisma.AircraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AircraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AircraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>[]
          }
          upsert: {
            args: Prisma.AircraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AircraftPayload>
          }
          aggregate: {
            args: Prisma.AircraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAircraft>
          }
          groupBy: {
            args: Prisma.AircraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<AircraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.AircraftCountArgs<ExtArgs>
            result: $Utils.Optional<AircraftCountAggregateOutputType> | number
          }
        }
      }
      Destination: {
        payload: Prisma.$DestinationPayload<ExtArgs>
        fields: Prisma.DestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findFirst: {
            args: Prisma.DestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findMany: {
            args: Prisma.DestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          create: {
            args: Prisma.DestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          createMany: {
            args: Prisma.DestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          delete: {
            args: Prisma.DestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          update: {
            args: Prisma.DestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          deleteMany: {
            args: Prisma.DestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          upsert: {
            args: Prisma.DestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          aggregate: {
            args: Prisma.DestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestination>
          }
          groupBy: {
            args: Prisma.DestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationCountAggregateOutputType> | number
          }
        }
      }
      Flight: {
        payload: Prisma.$FlightPayload<ExtArgs>
        fields: Prisma.FlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          findFirst: {
            args: Prisma.FlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          findMany: {
            args: Prisma.FlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>[]
          }
          create: {
            args: Prisma.FlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          createMany: {
            args: Prisma.FlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>[]
          }
          delete: {
            args: Prisma.FlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          update: {
            args: Prisma.FlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          deleteMany: {
            args: Prisma.FlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>[]
          }
          upsert: {
            args: Prisma.FlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          aggregate: {
            args: Prisma.FlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlight>
          }
          groupBy: {
            args: Prisma.FlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightCountArgs<ExtArgs>
            result: $Utils.Optional<FlightCountAggregateOutputType> | number
          }
        }
      }
      FlightSchedule: {
        payload: Prisma.$FlightSchedulePayload<ExtArgs>
        fields: Prisma.FlightScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          findFirst: {
            args: Prisma.FlightScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          findMany: {
            args: Prisma.FlightScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>[]
          }
          create: {
            args: Prisma.FlightScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          createMany: {
            args: Prisma.FlightScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>[]
          }
          delete: {
            args: Prisma.FlightScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          update: {
            args: Prisma.FlightScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          deleteMany: {
            args: Prisma.FlightScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlightScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>[]
          }
          upsert: {
            args: Prisma.FlightScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightSchedulePayload>
          }
          aggregate: {
            args: Prisma.FlightScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlightSchedule>
          }
          groupBy: {
            args: Prisma.FlightScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<FlightScheduleCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      PassengerDetail: {
        payload: Prisma.$PassengerDetailPayload<ExtArgs>
        fields: Prisma.PassengerDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          findFirst: {
            args: Prisma.PassengerDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          findMany: {
            args: Prisma.PassengerDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>[]
          }
          create: {
            args: Prisma.PassengerDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          createMany: {
            args: Prisma.PassengerDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>[]
          }
          delete: {
            args: Prisma.PassengerDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          update: {
            args: Prisma.PassengerDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>[]
          }
          upsert: {
            args: Prisma.PassengerDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerDetailPayload>
          }
          aggregate: {
            args: Prisma.PassengerDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassengerDetail>
          }
          groupBy: {
            args: Prisma.PassengerDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerDetailCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerDetailCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      AdminFlightSchedule: {
        payload: Prisma.$AdminFlightSchedulePayload<ExtArgs>
        fields: Prisma.AdminFlightScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFlightScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFlightScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          findFirst: {
            args: Prisma.AdminFlightScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFlightScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          findMany: {
            args: Prisma.AdminFlightScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>[]
          }
          create: {
            args: Prisma.AdminFlightScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          createMany: {
            args: Prisma.AdminFlightScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminFlightScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>[]
          }
          delete: {
            args: Prisma.AdminFlightScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          update: {
            args: Prisma.AdminFlightScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          deleteMany: {
            args: Prisma.AdminFlightScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminFlightScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminFlightScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>[]
          }
          upsert: {
            args: Prisma.AdminFlightScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminFlightSchedulePayload>
          }
          aggregate: {
            args: Prisma.AdminFlightScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminFlightSchedule>
          }
          groupBy: {
            args: Prisma.AdminFlightScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminFlightScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminFlightScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<AdminFlightScheduleCountAggregateOutputType> | number
          }
        }
      }
      AdminPromotion: {
        payload: Prisma.$AdminPromotionPayload<ExtArgs>
        fields: Prisma.AdminPromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          findFirst: {
            args: Prisma.AdminPromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          findMany: {
            args: Prisma.AdminPromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>[]
          }
          create: {
            args: Prisma.AdminPromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          createMany: {
            args: Prisma.AdminPromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>[]
          }
          delete: {
            args: Prisma.AdminPromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          update: {
            args: Prisma.AdminPromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          deleteMany: {
            args: Prisma.AdminPromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>[]
          }
          upsert: {
            args: Prisma.AdminPromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPromotionPayload>
          }
          aggregate: {
            args: Prisma.AdminPromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPromotion>
          }
          groupBy: {
            args: Prisma.AdminPromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPromotionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPromotionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    country?: CountryOmit
    city?: CityOmit
    airport?: AirportOmit
    airline?: AirlineOmit
    aircraftType?: AircraftTypeOmit
    aircraft?: AircraftOmit
    destination?: DestinationOmit
    flight?: FlightOmit
    flightSchedule?: FlightScheduleOmit
    booking?: BookingOmit
    passengerDetail?: PassengerDetailOmit
    payment?: PaymentOmit
    review?: ReviewOmit
    promotion?: PromotionOmit
    notification?: NotificationOmit
    systemConfig?: SystemConfigOmit
    adminFlightSchedule?: AdminFlightScheduleOmit
    adminPromotion?: AdminPromotionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    notifications: number
    payments: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    airlines: number
    airports: number
    cities: number
    destinations: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airlines?: boolean | CountryCountOutputTypeCountAirlinesArgs
    airports?: boolean | CountryCountOutputTypeCountAirportsArgs
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    destinations?: boolean | CountryCountOutputTypeCountDestinationsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountAirlinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirlineWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountAirportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirportWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    airports: number
    destinations: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airports?: boolean | CityCountOutputTypeCountAirportsArgs
    destinations?: boolean | CityCountOutputTypeCountDestinationsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAirportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirportWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
  }


  /**
   * Count Type AirportCountOutputType
   */

  export type AirportCountOutputType = {
    destinations: number
    arrivalFlights: number
    departureFlights: number
  }

  export type AirportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinations?: boolean | AirportCountOutputTypeCountDestinationsArgs
    arrivalFlights?: boolean | AirportCountOutputTypeCountArrivalFlightsArgs
    departureFlights?: boolean | AirportCountOutputTypeCountDepartureFlightsArgs
  }

  // Custom InputTypes
  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirportCountOutputType
     */
    select?: AirportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountArrivalFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountDepartureFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
  }


  /**
   * Count Type AirlineCountOutputType
   */

  export type AirlineCountOutputType = {
    aircraft: number
    flights: number
    adminFlightSchedules: number
  }

  export type AirlineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AirlineCountOutputTypeCountAircraftArgs
    flights?: boolean | AirlineCountOutputTypeCountFlightsArgs
    adminFlightSchedules?: boolean | AirlineCountOutputTypeCountAdminFlightSchedulesArgs
  }

  // Custom InputTypes
  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirlineCountOutputType
     */
    select?: AirlineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountAircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AircraftWhereInput
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountAdminFlightSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminFlightScheduleWhereInput
  }


  /**
   * Count Type AircraftTypeCountOutputType
   */

  export type AircraftTypeCountOutputType = {
    aircraft: number
  }

  export type AircraftTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AircraftTypeCountOutputTypeCountAircraftArgs
  }

  // Custom InputTypes
  /**
   * AircraftTypeCountOutputType without action
   */
  export type AircraftTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftTypeCountOutputType
     */
    select?: AircraftTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AircraftTypeCountOutputType without action
   */
  export type AircraftTypeCountOutputTypeCountAircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AircraftWhereInput
  }


  /**
   * Count Type AircraftCountOutputType
   */

  export type AircraftCountOutputType = {
    flights: number
  }

  export type AircraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flights?: boolean | AircraftCountOutputTypeCountFlightsArgs
  }

  // Custom InputTypes
  /**
   * AircraftCountOutputType without action
   */
  export type AircraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftCountOutputType
     */
    select?: AircraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AircraftCountOutputType without action
   */
  export type AircraftCountOutputTypeCountFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
  }


  /**
   * Count Type DestinationCountOutputType
   */

  export type DestinationCountOutputType = {
    bookingsTo: number
    bookingsFrom: number
    promotions: number
    reviews: number
  }

  export type DestinationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingsTo?: boolean | DestinationCountOutputTypeCountBookingsToArgs
    bookingsFrom?: boolean | DestinationCountOutputTypeCountBookingsFromArgs
    promotions?: boolean | DestinationCountOutputTypeCountPromotionsArgs
    reviews?: boolean | DestinationCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationCountOutputType
     */
    select?: DestinationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountBookingsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountBookingsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type FlightCountOutputType
   */

  export type FlightCountOutputType = {
    bookings: number
    flightSchedules: number
  }

  export type FlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | FlightCountOutputTypeCountBookingsArgs
    flightSchedules?: boolean | FlightCountOutputTypeCountFlightSchedulesArgs
  }

  // Custom InputTypes
  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightCountOutputType
     */
    select?: FlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountFlightSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightScheduleWhereInput
  }


  /**
   * Count Type FlightScheduleCountOutputType
   */

  export type FlightScheduleCountOutputType = {
    bookings: number
  }

  export type FlightScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | FlightScheduleCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * FlightScheduleCountOutputType without action
   */
  export type FlightScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightScheduleCountOutputType
     */
    select?: FlightScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightScheduleCountOutputType without action
   */
  export type FlightScheduleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    notifications: number
    passengers: number
    payments: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | BookingCountOutputTypeCountNotificationsArgs
    passengers?: boolean | BookingCountOutputTypeCountPassengersArgs
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerDetailWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    dateOfBirth: Date | null
    nationality: string | null
    passportNumber: string | null
    role: string | null
    isActive: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    dateOfBirth: Date | null
    nationality: string | null
    passportNumber: string | null
    role: string | null
    isActive: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    phone: number
    dateOfBirth: number
    nationality: number
    passportNumber: number
    role: number
    isActive: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    role?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    role?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    role?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    phone: string | null
    dateOfBirth: Date | null
    nationality: string | null
    passportNumber: string | null
    role: string
    isActive: boolean
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    role?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    role?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    role?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    role?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "phone" | "dateOfBirth" | "nationality" | "passportNumber" | "role" | "isActive" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      phone: string | null
      dateOfBirth: Date | null
      nationality: string | null
      passportNumber: string | null
      role: string
      isActive: boolean
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly nationality: FieldRef<"User", 'String'>
    readonly passportNumber: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    continent: string | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    continent: string | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    continent: number
    currency: number
    timezone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    continent?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    continent?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    continent?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    continent?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airlines?: boolean | Country$airlinesArgs<ExtArgs>
    airports?: boolean | Country$airportsArgs<ExtArgs>
    cities?: boolean | Country$citiesArgs<ExtArgs>
    destinations?: boolean | Country$destinationsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    continent?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    continent?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    continent?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "continent" | "currency" | "timezone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airlines?: boolean | Country$airlinesArgs<ExtArgs>
    airports?: boolean | Country$airportsArgs<ExtArgs>
    cities?: boolean | Country$citiesArgs<ExtArgs>
    destinations?: boolean | Country$destinationsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      airlines: Prisma.$AirlinePayload<ExtArgs>[]
      airports: Prisma.$AirportPayload<ExtArgs>[]
      cities: Prisma.$CityPayload<ExtArgs>[]
      destinations: Prisma.$DestinationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      continent: string
      currency: string
      timezone: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airlines<T extends Country$airlinesArgs<ExtArgs> = {}>(args?: Subset<T, Country$airlinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    airports<T extends Country$airportsArgs<ExtArgs> = {}>(args?: Subset<T, Country$airportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    destinations<T extends Country$destinationsArgs<ExtArgs> = {}>(args?: Subset<T, Country$destinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
    readonly continent: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly timezone: FieldRef<"Country", 'String'>
    readonly isActive: FieldRef<"Country", 'Boolean'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.airlines
   */
  export type Country$airlinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    where?: AirlineWhereInput
    orderBy?: AirlineOrderByWithRelationInput | AirlineOrderByWithRelationInput[]
    cursor?: AirlineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * Country.airports
   */
  export type Country$airportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    where?: AirportWhereInput
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    cursor?: AirportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.destinations
   */
  export type Country$destinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    cursor?: DestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    population: number | null
    lat: number | null
    lon: number | null
  }

  export type CitySumAggregateOutputType = {
    population: number | null
    lat: number | null
    lon: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
    state: string | null
    population: number | null
    timezone: string | null
    lat: number | null
    lon: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
    state: string | null
    population: number | null
    timezone: string | null
    lat: number | null
    lon: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    state: number
    population: number
    timezone: number
    lat: number
    lon: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    population?: true
    lat?: true
    lon?: true
  }

  export type CitySumAggregateInputType = {
    population?: true
    lat?: true
    lon?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    state?: true
    population?: true
    timezone?: true
    lat?: true
    lon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    state?: true
    population?: true
    timezone?: true
    lat?: true
    lon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    state?: true
    population?: true
    timezone?: true
    lat?: true
    lon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    countryId: string
    state: string | null
    population: number | null
    timezone: string | null
    lat: number | null
    lon: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    state?: boolean
    population?: boolean
    timezone?: boolean
    lat?: boolean
    lon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airports?: boolean | City$airportsArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    destinations?: boolean | City$destinationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    state?: boolean
    population?: boolean
    timezone?: boolean
    lat?: boolean
    lon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    state?: boolean
    population?: boolean
    timezone?: boolean
    lat?: boolean
    lon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    state?: boolean
    population?: boolean
    timezone?: boolean
    lat?: boolean
    lon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "countryId" | "state" | "population" | "timezone" | "lat" | "lon" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airports?: boolean | City$airportsArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    destinations?: boolean | City$destinationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      airports: Prisma.$AirportPayload<ExtArgs>[]
      country: Prisma.$CountryPayload<ExtArgs>
      destinations: Prisma.$DestinationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      countryId: string
      state: string | null
      population: number | null
      timezone: string | null
      lat: number | null
      lon: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airports<T extends City$airportsArgs<ExtArgs> = {}>(args?: Subset<T, City$airportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destinations<T extends City$destinationsArgs<ExtArgs> = {}>(args?: Subset<T, City$destinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly countryId: FieldRef<"City", 'String'>
    readonly state: FieldRef<"City", 'String'>
    readonly population: FieldRef<"City", 'Int'>
    readonly timezone: FieldRef<"City", 'String'>
    readonly lat: FieldRef<"City", 'Float'>
    readonly lon: FieldRef<"City", 'Float'>
    readonly isActive: FieldRef<"City", 'Boolean'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.airports
   */
  export type City$airportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    where?: AirportWhereInput
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    cursor?: AirportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * City.destinations
   */
  export type City$destinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    cursor?: DestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Airport
   */

  export type AggregateAirport = {
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  export type AirportAvgAggregateOutputType = {
    lat: number | null
    lon: number | null
    elevation: number | null
  }

  export type AirportSumAggregateOutputType = {
    lat: number | null
    lon: number | null
    elevation: number | null
  }

  export type AirportMinAggregateOutputType = {
    id: string | null
    name: string | null
    iataCode: string | null
    icaoCode: string | null
    cityId: string | null
    countryId: string | null
    municipality: string | null
    lat: number | null
    lon: number | null
    elevation: number | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iataCode: string | null
    icaoCode: string | null
    cityId: string | null
    countryId: string | null
    municipality: string | null
    lat: number | null
    lon: number | null
    elevation: number | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirportCountAggregateOutputType = {
    id: number
    name: number
    iataCode: number
    icaoCode: number
    cityId: number
    countryId: number
    municipality: number
    lat: number
    lon: number
    elevation: number
    timezone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AirportAvgAggregateInputType = {
    lat?: true
    lon?: true
    elevation?: true
  }

  export type AirportSumAggregateInputType = {
    lat?: true
    lon?: true
    elevation?: true
  }

  export type AirportMinAggregateInputType = {
    id?: true
    name?: true
    iataCode?: true
    icaoCode?: true
    cityId?: true
    countryId?: true
    municipality?: true
    lat?: true
    lon?: true
    elevation?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirportMaxAggregateInputType = {
    id?: true
    name?: true
    iataCode?: true
    icaoCode?: true
    cityId?: true
    countryId?: true
    municipality?: true
    lat?: true
    lon?: true
    elevation?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirportCountAggregateInputType = {
    id?: true
    name?: true
    iataCode?: true
    icaoCode?: true
    cityId?: true
    countryId?: true
    municipality?: true
    lat?: true
    lon?: true
    elevation?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AirportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Airport to aggregate.
     */
    where?: AirportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airports to fetch.
     */
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AirportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Airports
    **/
    _count?: true | AirportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirportMaxAggregateInputType
  }

  export type GetAirportAggregateType<T extends AirportAggregateArgs> = {
        [P in keyof T & keyof AggregateAirport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirport[P]>
      : GetScalarType<T[P], AggregateAirport[P]>
  }




  export type AirportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirportWhereInput
    orderBy?: AirportOrderByWithAggregationInput | AirportOrderByWithAggregationInput[]
    by: AirportScalarFieldEnum[] | AirportScalarFieldEnum
    having?: AirportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirportCountAggregateInputType | true
    _avg?: AirportAvgAggregateInputType
    _sum?: AirportSumAggregateInputType
    _min?: AirportMinAggregateInputType
    _max?: AirportMaxAggregateInputType
  }

  export type AirportGroupByOutputType = {
    id: string
    name: string
    iataCode: string | null
    icaoCode: string | null
    cityId: string
    countryId: string
    municipality: string | null
    lat: number | null
    lon: number | null
    elevation: number | null
    timezone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  type GetAirportGroupByPayload<T extends AirportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirportGroupByOutputType[P]>
            : GetScalarType<T[P], AirportGroupByOutputType[P]>
        }
      >
    >


  export type AirportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iataCode?: boolean
    icaoCode?: boolean
    cityId?: boolean
    countryId?: boolean
    municipality?: boolean
    lat?: boolean
    lon?: boolean
    elevation?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    destinations?: boolean | Airport$destinationsArgs<ExtArgs>
    arrivalFlights?: boolean | Airport$arrivalFlightsArgs<ExtArgs>
    departureFlights?: boolean | Airport$departureFlightsArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airport"]>

  export type AirportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iataCode?: boolean
    icaoCode?: boolean
    cityId?: boolean
    countryId?: boolean
    municipality?: boolean
    lat?: boolean
    lon?: boolean
    elevation?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airport"]>

  export type AirportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iataCode?: boolean
    icaoCode?: boolean
    cityId?: boolean
    countryId?: boolean
    municipality?: boolean
    lat?: boolean
    lon?: boolean
    elevation?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airport"]>

  export type AirportSelectScalar = {
    id?: boolean
    name?: boolean
    iataCode?: boolean
    icaoCode?: boolean
    cityId?: boolean
    countryId?: boolean
    municipality?: boolean
    lat?: boolean
    lon?: boolean
    elevation?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AirportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "iataCode" | "icaoCode" | "cityId" | "countryId" | "municipality" | "lat" | "lon" | "elevation" | "timezone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["airport"]>
  export type AirportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    destinations?: boolean | Airport$destinationsArgs<ExtArgs>
    arrivalFlights?: boolean | Airport$arrivalFlightsArgs<ExtArgs>
    departureFlights?: boolean | Airport$departureFlightsArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AirportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type AirportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $AirportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Airport"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      destinations: Prisma.$DestinationPayload<ExtArgs>[]
      arrivalFlights: Prisma.$FlightPayload<ExtArgs>[]
      departureFlights: Prisma.$FlightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      iataCode: string | null
      icaoCode: string | null
      cityId: string
      countryId: string
      municipality: string | null
      lat: number | null
      lon: number | null
      elevation: number | null
      timezone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["airport"]>
    composites: {}
  }

  type AirportGetPayload<S extends boolean | null | undefined | AirportDefaultArgs> = $Result.GetResult<Prisma.$AirportPayload, S>

  type AirportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AirportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirportCountAggregateInputType | true
    }

  export interface AirportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Airport'], meta: { name: 'Airport' } }
    /**
     * Find zero or one Airport that matches the filter.
     * @param {AirportFindUniqueArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AirportFindUniqueArgs>(args: SelectSubset<T, AirportFindUniqueArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Airport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AirportFindUniqueOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AirportFindUniqueOrThrowArgs>(args: SelectSubset<T, AirportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportFindFirstArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AirportFindFirstArgs>(args?: SelectSubset<T, AirportFindFirstArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportFindFirstOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AirportFindFirstOrThrowArgs>(args?: SelectSubset<T, AirportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airports
     * const airports = await prisma.airport.findMany()
     * 
     * // Get first 10 Airports
     * const airports = await prisma.airport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airportWithIdOnly = await prisma.airport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AirportFindManyArgs>(args?: SelectSubset<T, AirportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Airport.
     * @param {AirportCreateArgs} args - Arguments to create a Airport.
     * @example
     * // Create one Airport
     * const Airport = await prisma.airport.create({
     *   data: {
     *     // ... data to create a Airport
     *   }
     * })
     * 
     */
    create<T extends AirportCreateArgs>(args: SelectSubset<T, AirportCreateArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Airports.
     * @param {AirportCreateManyArgs} args - Arguments to create many Airports.
     * @example
     * // Create many Airports
     * const airport = await prisma.airport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AirportCreateManyArgs>(args?: SelectSubset<T, AirportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Airports and returns the data saved in the database.
     * @param {AirportCreateManyAndReturnArgs} args - Arguments to create many Airports.
     * @example
     * // Create many Airports
     * const airport = await prisma.airport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Airports and only return the `id`
     * const airportWithIdOnly = await prisma.airport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AirportCreateManyAndReturnArgs>(args?: SelectSubset<T, AirportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Airport.
     * @param {AirportDeleteArgs} args - Arguments to delete one Airport.
     * @example
     * // Delete one Airport
     * const Airport = await prisma.airport.delete({
     *   where: {
     *     // ... filter to delete one Airport
     *   }
     * })
     * 
     */
    delete<T extends AirportDeleteArgs>(args: SelectSubset<T, AirportDeleteArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Airport.
     * @param {AirportUpdateArgs} args - Arguments to update one Airport.
     * @example
     * // Update one Airport
     * const airport = await prisma.airport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AirportUpdateArgs>(args: SelectSubset<T, AirportUpdateArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Airports.
     * @param {AirportDeleteManyArgs} args - Arguments to filter Airports to delete.
     * @example
     * // Delete a few Airports
     * const { count } = await prisma.airport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AirportDeleteManyArgs>(args?: SelectSubset<T, AirportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airports
     * const airport = await prisma.airport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AirportUpdateManyArgs>(args: SelectSubset<T, AirportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports and returns the data updated in the database.
     * @param {AirportUpdateManyAndReturnArgs} args - Arguments to update many Airports.
     * @example
     * // Update many Airports
     * const airport = await prisma.airport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Airports and only return the `id`
     * const airportWithIdOnly = await prisma.airport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AirportUpdateManyAndReturnArgs>(args: SelectSubset<T, AirportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Airport.
     * @param {AirportUpsertArgs} args - Arguments to update or create a Airport.
     * @example
     * // Update or create a Airport
     * const airport = await prisma.airport.upsert({
     *   create: {
     *     // ... data to create a Airport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airport we want to update
     *   }
     * })
     */
    upsert<T extends AirportUpsertArgs>(args: SelectSubset<T, AirportUpsertArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportCountArgs} args - Arguments to filter Airports to count.
     * @example
     * // Count the number of Airports
     * const count = await prisma.airport.count({
     *   where: {
     *     // ... the filter for the Airports we want to count
     *   }
     * })
    **/
    count<T extends AirportCountArgs>(
      args?: Subset<T, AirportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirportAggregateArgs>(args: Subset<T, AirportAggregateArgs>): Prisma.PrismaPromise<GetAirportAggregateType<T>>

    /**
     * Group by Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirportGroupByArgs['orderBy'] }
        : { orderBy?: AirportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Airport model
   */
  readonly fields: AirportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Airport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AirportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destinations<T extends Airport$destinationsArgs<ExtArgs> = {}>(args?: Subset<T, Airport$destinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrivalFlights<T extends Airport$arrivalFlightsArgs<ExtArgs> = {}>(args?: Subset<T, Airport$arrivalFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departureFlights<T extends Airport$departureFlightsArgs<ExtArgs> = {}>(args?: Subset<T, Airport$departureFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Airport model
   */
  interface AirportFieldRefs {
    readonly id: FieldRef<"Airport", 'String'>
    readonly name: FieldRef<"Airport", 'String'>
    readonly iataCode: FieldRef<"Airport", 'String'>
    readonly icaoCode: FieldRef<"Airport", 'String'>
    readonly cityId: FieldRef<"Airport", 'String'>
    readonly countryId: FieldRef<"Airport", 'String'>
    readonly municipality: FieldRef<"Airport", 'String'>
    readonly lat: FieldRef<"Airport", 'Float'>
    readonly lon: FieldRef<"Airport", 'Float'>
    readonly elevation: FieldRef<"Airport", 'Int'>
    readonly timezone: FieldRef<"Airport", 'String'>
    readonly isActive: FieldRef<"Airport", 'Boolean'>
    readonly createdAt: FieldRef<"Airport", 'DateTime'>
    readonly updatedAt: FieldRef<"Airport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Airport findUnique
   */
  export type AirportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter, which Airport to fetch.
     */
    where: AirportWhereUniqueInput
  }

  /**
   * Airport findUniqueOrThrow
   */
  export type AirportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter, which Airport to fetch.
     */
    where: AirportWhereUniqueInput
  }

  /**
   * Airport findFirst
   */
  export type AirportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter, which Airport to fetch.
     */
    where?: AirportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airports to fetch.
     */
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Airports.
     */
    cursor?: AirportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * Airport findFirstOrThrow
   */
  export type AirportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter, which Airport to fetch.
     */
    where?: AirportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airports to fetch.
     */
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Airports.
     */
    cursor?: AirportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * Airport findMany
   */
  export type AirportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter, which Airports to fetch.
     */
    where?: AirportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airports to fetch.
     */
    orderBy?: AirportOrderByWithRelationInput | AirportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Airports.
     */
    cursor?: AirportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airports.
     */
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * Airport create
   */
  export type AirportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * The data needed to create a Airport.
     */
    data: XOR<AirportCreateInput, AirportUncheckedCreateInput>
  }

  /**
   * Airport createMany
   */
  export type AirportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Airports.
     */
    data: AirportCreateManyInput | AirportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Airport createManyAndReturn
   */
  export type AirportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * The data used to create many Airports.
     */
    data: AirportCreateManyInput | AirportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Airport update
   */
  export type AirportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * The data needed to update a Airport.
     */
    data: XOR<AirportUpdateInput, AirportUncheckedUpdateInput>
    /**
     * Choose, which Airport to update.
     */
    where: AirportWhereUniqueInput
  }

  /**
   * Airport updateMany
   */
  export type AirportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Airports.
     */
    data: XOR<AirportUpdateManyMutationInput, AirportUncheckedUpdateManyInput>
    /**
     * Filter which Airports to update
     */
    where?: AirportWhereInput
    /**
     * Limit how many Airports to update.
     */
    limit?: number
  }

  /**
   * Airport updateManyAndReturn
   */
  export type AirportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * The data used to update Airports.
     */
    data: XOR<AirportUpdateManyMutationInput, AirportUncheckedUpdateManyInput>
    /**
     * Filter which Airports to update
     */
    where?: AirportWhereInput
    /**
     * Limit how many Airports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Airport upsert
   */
  export type AirportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * The filter to search for the Airport to update in case it exists.
     */
    where: AirportWhereUniqueInput
    /**
     * In case the Airport found by the `where` argument doesn't exist, create a new Airport with this data.
     */
    create: XOR<AirportCreateInput, AirportUncheckedCreateInput>
    /**
     * In case the Airport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AirportUpdateInput, AirportUncheckedUpdateInput>
  }

  /**
   * Airport delete
   */
  export type AirportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
    /**
     * Filter which Airport to delete.
     */
    where: AirportWhereUniqueInput
  }

  /**
   * Airport deleteMany
   */
  export type AirportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Airports to delete
     */
    where?: AirportWhereInput
    /**
     * Limit how many Airports to delete.
     */
    limit?: number
  }

  /**
   * Airport.destinations
   */
  export type Airport$destinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    cursor?: DestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Airport.arrivalFlights
   */
  export type Airport$arrivalFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    cursor?: FlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Airport.departureFlights
   */
  export type Airport$departureFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    cursor?: FlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Airport without action
   */
  export type AirportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airport
     */
    select?: AirportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airport
     */
    omit?: AirportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirportInclude<ExtArgs> | null
  }


  /**
   * Model Airline
   */

  export type AggregateAirline = {
    _count: AirlineCountAggregateOutputType | null
    _min: AirlineMinAggregateOutputType | null
    _max: AirlineMaxAggregateOutputType | null
  }

  export type AirlineMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    icaoCode: string | null
    countryId: string | null
    logo: string | null
    description: string | null
    website: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirlineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    icaoCode: string | null
    countryId: string | null
    logo: string | null
    description: string | null
    website: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirlineCountAggregateOutputType = {
    id: number
    name: number
    code: number
    icaoCode: number
    countryId: number
    logo: number
    description: number
    website: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AirlineMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icaoCode?: true
    countryId?: true
    logo?: true
    description?: true
    website?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirlineMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icaoCode?: true
    countryId?: true
    logo?: true
    description?: true
    website?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirlineCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    icaoCode?: true
    countryId?: true
    logo?: true
    description?: true
    website?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AirlineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Airline to aggregate.
     */
    where?: AirlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airlines to fetch.
     */
    orderBy?: AirlineOrderByWithRelationInput | AirlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AirlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Airlines
    **/
    _count?: true | AirlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirlineMaxAggregateInputType
  }

  export type GetAirlineAggregateType<T extends AirlineAggregateArgs> = {
        [P in keyof T & keyof AggregateAirline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirline[P]>
      : GetScalarType<T[P], AggregateAirline[P]>
  }




  export type AirlineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirlineWhereInput
    orderBy?: AirlineOrderByWithAggregationInput | AirlineOrderByWithAggregationInput[]
    by: AirlineScalarFieldEnum[] | AirlineScalarFieldEnum
    having?: AirlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirlineCountAggregateInputType | true
    _min?: AirlineMinAggregateInputType
    _max?: AirlineMaxAggregateInputType
  }

  export type AirlineGroupByOutputType = {
    id: string
    name: string
    code: string
    icaoCode: string | null
    countryId: string
    logo: string | null
    description: string | null
    website: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AirlineCountAggregateOutputType | null
    _min: AirlineMinAggregateOutputType | null
    _max: AirlineMaxAggregateOutputType | null
  }

  type GetAirlineGroupByPayload<T extends AirlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirlineGroupByOutputType[P]>
            : GetScalarType<T[P], AirlineGroupByOutputType[P]>
        }
      >
    >


  export type AirlineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    icaoCode?: boolean
    countryId?: boolean
    logo?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraft?: boolean | Airline$aircraftArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    flights?: boolean | Airline$flightsArgs<ExtArgs>
    adminFlightSchedules?: boolean | Airline$adminFlightSchedulesArgs<ExtArgs>
    _count?: boolean | AirlineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airline"]>

  export type AirlineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    icaoCode?: boolean
    countryId?: boolean
    logo?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airline"]>

  export type AirlineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    icaoCode?: boolean
    countryId?: boolean
    logo?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airline"]>

  export type AirlineSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    icaoCode?: boolean
    countryId?: boolean
    logo?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AirlineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "icaoCode" | "countryId" | "logo" | "description" | "website" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["airline"]>
  export type AirlineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | Airline$aircraftArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    flights?: boolean | Airline$flightsArgs<ExtArgs>
    adminFlightSchedules?: boolean | Airline$adminFlightSchedulesArgs<ExtArgs>
    _count?: boolean | AirlineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AirlineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type AirlineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $AirlinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Airline"
    objects: {
      aircraft: Prisma.$AircraftPayload<ExtArgs>[]
      country: Prisma.$CountryPayload<ExtArgs>
      flights: Prisma.$FlightPayload<ExtArgs>[]
      adminFlightSchedules: Prisma.$AdminFlightSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      icaoCode: string | null
      countryId: string
      logo: string | null
      description: string | null
      website: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["airline"]>
    composites: {}
  }

  type AirlineGetPayload<S extends boolean | null | undefined | AirlineDefaultArgs> = $Result.GetResult<Prisma.$AirlinePayload, S>

  type AirlineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AirlineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirlineCountAggregateInputType | true
    }

  export interface AirlineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Airline'], meta: { name: 'Airline' } }
    /**
     * Find zero or one Airline that matches the filter.
     * @param {AirlineFindUniqueArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AirlineFindUniqueArgs>(args: SelectSubset<T, AirlineFindUniqueArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Airline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AirlineFindUniqueOrThrowArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AirlineFindUniqueOrThrowArgs>(args: SelectSubset<T, AirlineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineFindFirstArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AirlineFindFirstArgs>(args?: SelectSubset<T, AirlineFindFirstArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineFindFirstOrThrowArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AirlineFindFirstOrThrowArgs>(args?: SelectSubset<T, AirlineFindFirstOrThrowArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Airlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airlines
     * const airlines = await prisma.airline.findMany()
     * 
     * // Get first 10 Airlines
     * const airlines = await prisma.airline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airlineWithIdOnly = await prisma.airline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AirlineFindManyArgs>(args?: SelectSubset<T, AirlineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Airline.
     * @param {AirlineCreateArgs} args - Arguments to create a Airline.
     * @example
     * // Create one Airline
     * const Airline = await prisma.airline.create({
     *   data: {
     *     // ... data to create a Airline
     *   }
     * })
     * 
     */
    create<T extends AirlineCreateArgs>(args: SelectSubset<T, AirlineCreateArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Airlines.
     * @param {AirlineCreateManyArgs} args - Arguments to create many Airlines.
     * @example
     * // Create many Airlines
     * const airline = await prisma.airline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AirlineCreateManyArgs>(args?: SelectSubset<T, AirlineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Airlines and returns the data saved in the database.
     * @param {AirlineCreateManyAndReturnArgs} args - Arguments to create many Airlines.
     * @example
     * // Create many Airlines
     * const airline = await prisma.airline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Airlines and only return the `id`
     * const airlineWithIdOnly = await prisma.airline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AirlineCreateManyAndReturnArgs>(args?: SelectSubset<T, AirlineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Airline.
     * @param {AirlineDeleteArgs} args - Arguments to delete one Airline.
     * @example
     * // Delete one Airline
     * const Airline = await prisma.airline.delete({
     *   where: {
     *     // ... filter to delete one Airline
     *   }
     * })
     * 
     */
    delete<T extends AirlineDeleteArgs>(args: SelectSubset<T, AirlineDeleteArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Airline.
     * @param {AirlineUpdateArgs} args - Arguments to update one Airline.
     * @example
     * // Update one Airline
     * const airline = await prisma.airline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AirlineUpdateArgs>(args: SelectSubset<T, AirlineUpdateArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Airlines.
     * @param {AirlineDeleteManyArgs} args - Arguments to filter Airlines to delete.
     * @example
     * // Delete a few Airlines
     * const { count } = await prisma.airline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AirlineDeleteManyArgs>(args?: SelectSubset<T, AirlineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airlines
     * const airline = await prisma.airline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AirlineUpdateManyArgs>(args: SelectSubset<T, AirlineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airlines and returns the data updated in the database.
     * @param {AirlineUpdateManyAndReturnArgs} args - Arguments to update many Airlines.
     * @example
     * // Update many Airlines
     * const airline = await prisma.airline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Airlines and only return the `id`
     * const airlineWithIdOnly = await prisma.airline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AirlineUpdateManyAndReturnArgs>(args: SelectSubset<T, AirlineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Airline.
     * @param {AirlineUpsertArgs} args - Arguments to update or create a Airline.
     * @example
     * // Update or create a Airline
     * const airline = await prisma.airline.upsert({
     *   create: {
     *     // ... data to create a Airline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airline we want to update
     *   }
     * })
     */
    upsert<T extends AirlineUpsertArgs>(args: SelectSubset<T, AirlineUpsertArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineCountArgs} args - Arguments to filter Airlines to count.
     * @example
     * // Count the number of Airlines
     * const count = await prisma.airline.count({
     *   where: {
     *     // ... the filter for the Airlines we want to count
     *   }
     * })
    **/
    count<T extends AirlineCountArgs>(
      args?: Subset<T, AirlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirlineAggregateArgs>(args: Subset<T, AirlineAggregateArgs>): Prisma.PrismaPromise<GetAirlineAggregateType<T>>

    /**
     * Group by Airline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirlineGroupByArgs['orderBy'] }
        : { orderBy?: AirlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Airline model
   */
  readonly fields: AirlineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Airline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AirlineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraft<T extends Airline$aircraftArgs<ExtArgs> = {}>(args?: Subset<T, Airline$aircraftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flights<T extends Airline$flightsArgs<ExtArgs> = {}>(args?: Subset<T, Airline$flightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminFlightSchedules<T extends Airline$adminFlightSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Airline$adminFlightSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Airline model
   */
  interface AirlineFieldRefs {
    readonly id: FieldRef<"Airline", 'String'>
    readonly name: FieldRef<"Airline", 'String'>
    readonly code: FieldRef<"Airline", 'String'>
    readonly icaoCode: FieldRef<"Airline", 'String'>
    readonly countryId: FieldRef<"Airline", 'String'>
    readonly logo: FieldRef<"Airline", 'String'>
    readonly description: FieldRef<"Airline", 'String'>
    readonly website: FieldRef<"Airline", 'String'>
    readonly isActive: FieldRef<"Airline", 'Boolean'>
    readonly createdAt: FieldRef<"Airline", 'DateTime'>
    readonly updatedAt: FieldRef<"Airline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Airline findUnique
   */
  export type AirlineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter, which Airline to fetch.
     */
    where: AirlineWhereUniqueInput
  }

  /**
   * Airline findUniqueOrThrow
   */
  export type AirlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter, which Airline to fetch.
     */
    where: AirlineWhereUniqueInput
  }

  /**
   * Airline findFirst
   */
  export type AirlineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter, which Airline to fetch.
     */
    where?: AirlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airlines to fetch.
     */
    orderBy?: AirlineOrderByWithRelationInput | AirlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Airlines.
     */
    cursor?: AirlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Airlines.
     */
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * Airline findFirstOrThrow
   */
  export type AirlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter, which Airline to fetch.
     */
    where?: AirlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airlines to fetch.
     */
    orderBy?: AirlineOrderByWithRelationInput | AirlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Airlines.
     */
    cursor?: AirlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Airlines.
     */
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * Airline findMany
   */
  export type AirlineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter, which Airlines to fetch.
     */
    where?: AirlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Airlines to fetch.
     */
    orderBy?: AirlineOrderByWithRelationInput | AirlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Airlines.
     */
    cursor?: AirlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Airlines.
     */
    skip?: number
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * Airline create
   */
  export type AirlineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * The data needed to create a Airline.
     */
    data: XOR<AirlineCreateInput, AirlineUncheckedCreateInput>
  }

  /**
   * Airline createMany
   */
  export type AirlineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Airlines.
     */
    data: AirlineCreateManyInput | AirlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Airline createManyAndReturn
   */
  export type AirlineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * The data used to create many Airlines.
     */
    data: AirlineCreateManyInput | AirlineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Airline update
   */
  export type AirlineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * The data needed to update a Airline.
     */
    data: XOR<AirlineUpdateInput, AirlineUncheckedUpdateInput>
    /**
     * Choose, which Airline to update.
     */
    where: AirlineWhereUniqueInput
  }

  /**
   * Airline updateMany
   */
  export type AirlineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Airlines.
     */
    data: XOR<AirlineUpdateManyMutationInput, AirlineUncheckedUpdateManyInput>
    /**
     * Filter which Airlines to update
     */
    where?: AirlineWhereInput
    /**
     * Limit how many Airlines to update.
     */
    limit?: number
  }

  /**
   * Airline updateManyAndReturn
   */
  export type AirlineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * The data used to update Airlines.
     */
    data: XOR<AirlineUpdateManyMutationInput, AirlineUncheckedUpdateManyInput>
    /**
     * Filter which Airlines to update
     */
    where?: AirlineWhereInput
    /**
     * Limit how many Airlines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Airline upsert
   */
  export type AirlineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * The filter to search for the Airline to update in case it exists.
     */
    where: AirlineWhereUniqueInput
    /**
     * In case the Airline found by the `where` argument doesn't exist, create a new Airline with this data.
     */
    create: XOR<AirlineCreateInput, AirlineUncheckedCreateInput>
    /**
     * In case the Airline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AirlineUpdateInput, AirlineUncheckedUpdateInput>
  }

  /**
   * Airline delete
   */
  export type AirlineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
    /**
     * Filter which Airline to delete.
     */
    where: AirlineWhereUniqueInput
  }

  /**
   * Airline deleteMany
   */
  export type AirlineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Airlines to delete
     */
    where?: AirlineWhereInput
    /**
     * Limit how many Airlines to delete.
     */
    limit?: number
  }

  /**
   * Airline.aircraft
   */
  export type Airline$aircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    where?: AircraftWhereInput
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    cursor?: AircraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * Airline.flights
   */
  export type Airline$flightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    cursor?: FlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Airline.adminFlightSchedules
   */
  export type Airline$adminFlightSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    where?: AdminFlightScheduleWhereInput
    orderBy?: AdminFlightScheduleOrderByWithRelationInput | AdminFlightScheduleOrderByWithRelationInput[]
    cursor?: AdminFlightScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminFlightScheduleScalarFieldEnum | AdminFlightScheduleScalarFieldEnum[]
  }

  /**
   * Airline without action
   */
  export type AirlineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Airline
     */
    select?: AirlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Airline
     */
    omit?: AirlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirlineInclude<ExtArgs> | null
  }


  /**
   * Model AircraftType
   */

  export type AggregateAircraftType = {
    _count: AircraftTypeCountAggregateOutputType | null
    _avg: AircraftTypeAvgAggregateOutputType | null
    _sum: AircraftTypeSumAggregateOutputType | null
    _min: AircraftTypeMinAggregateOutputType | null
    _max: AircraftTypeMaxAggregateOutputType | null
  }

  export type AircraftTypeAvgAggregateOutputType = {
    capacity: number | null
    range: number | null
    cruiseSpeed: number | null
    fuelCapacity: number | null
  }

  export type AircraftTypeSumAggregateOutputType = {
    capacity: number | null
    range: number | null
    cruiseSpeed: number | null
    fuelCapacity: number | null
  }

  export type AircraftTypeMinAggregateOutputType = {
    id: string | null
    manufacturer: string | null
    model: string | null
    variant: string | null
    capacity: number | null
    range: number | null
    cruiseSpeed: number | null
    fuelCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AircraftTypeMaxAggregateOutputType = {
    id: string | null
    manufacturer: string | null
    model: string | null
    variant: string | null
    capacity: number | null
    range: number | null
    cruiseSpeed: number | null
    fuelCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AircraftTypeCountAggregateOutputType = {
    id: number
    manufacturer: number
    model: number
    variant: number
    capacity: number
    range: number
    cruiseSpeed: number
    fuelCapacity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AircraftTypeAvgAggregateInputType = {
    capacity?: true
    range?: true
    cruiseSpeed?: true
    fuelCapacity?: true
  }

  export type AircraftTypeSumAggregateInputType = {
    capacity?: true
    range?: true
    cruiseSpeed?: true
    fuelCapacity?: true
  }

  export type AircraftTypeMinAggregateInputType = {
    id?: true
    manufacturer?: true
    model?: true
    variant?: true
    capacity?: true
    range?: true
    cruiseSpeed?: true
    fuelCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AircraftTypeMaxAggregateInputType = {
    id?: true
    manufacturer?: true
    model?: true
    variant?: true
    capacity?: true
    range?: true
    cruiseSpeed?: true
    fuelCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AircraftTypeCountAggregateInputType = {
    id?: true
    manufacturer?: true
    model?: true
    variant?: true
    capacity?: true
    range?: true
    cruiseSpeed?: true
    fuelCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AircraftTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AircraftType to aggregate.
     */
    where?: AircraftTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AircraftTypes to fetch.
     */
    orderBy?: AircraftTypeOrderByWithRelationInput | AircraftTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AircraftTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AircraftTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AircraftTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AircraftTypes
    **/
    _count?: true | AircraftTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AircraftTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AircraftTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AircraftTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AircraftTypeMaxAggregateInputType
  }

  export type GetAircraftTypeAggregateType<T extends AircraftTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAircraftType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAircraftType[P]>
      : GetScalarType<T[P], AggregateAircraftType[P]>
  }




  export type AircraftTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AircraftTypeWhereInput
    orderBy?: AircraftTypeOrderByWithAggregationInput | AircraftTypeOrderByWithAggregationInput[]
    by: AircraftTypeScalarFieldEnum[] | AircraftTypeScalarFieldEnum
    having?: AircraftTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AircraftTypeCountAggregateInputType | true
    _avg?: AircraftTypeAvgAggregateInputType
    _sum?: AircraftTypeSumAggregateInputType
    _min?: AircraftTypeMinAggregateInputType
    _max?: AircraftTypeMaxAggregateInputType
  }

  export type AircraftTypeGroupByOutputType = {
    id: string
    manufacturer: string
    model: string
    variant: string | null
    capacity: number
    range: number | null
    cruiseSpeed: number | null
    fuelCapacity: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AircraftTypeCountAggregateOutputType | null
    _avg: AircraftTypeAvgAggregateOutputType | null
    _sum: AircraftTypeSumAggregateOutputType | null
    _min: AircraftTypeMinAggregateOutputType | null
    _max: AircraftTypeMaxAggregateOutputType | null
  }

  type GetAircraftTypeGroupByPayload<T extends AircraftTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AircraftTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AircraftTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AircraftTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AircraftTypeGroupByOutputType[P]>
        }
      >
    >


  export type AircraftTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturer?: boolean
    model?: boolean
    variant?: boolean
    capacity?: boolean
    range?: boolean
    cruiseSpeed?: boolean
    fuelCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraft?: boolean | AircraftType$aircraftArgs<ExtArgs>
    _count?: boolean | AircraftTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraftType"]>

  export type AircraftTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturer?: boolean
    model?: boolean
    variant?: boolean
    capacity?: boolean
    range?: boolean
    cruiseSpeed?: boolean
    fuelCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aircraftType"]>

  export type AircraftTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturer?: boolean
    model?: boolean
    variant?: boolean
    capacity?: boolean
    range?: boolean
    cruiseSpeed?: boolean
    fuelCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aircraftType"]>

  export type AircraftTypeSelectScalar = {
    id?: boolean
    manufacturer?: boolean
    model?: boolean
    variant?: boolean
    capacity?: boolean
    range?: boolean
    cruiseSpeed?: boolean
    fuelCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AircraftTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "manufacturer" | "model" | "variant" | "capacity" | "range" | "cruiseSpeed" | "fuelCapacity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["aircraftType"]>
  export type AircraftTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AircraftType$aircraftArgs<ExtArgs>
    _count?: boolean | AircraftTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AircraftTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AircraftTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AircraftTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AircraftType"
    objects: {
      aircraft: Prisma.$AircraftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      manufacturer: string
      model: string
      variant: string | null
      capacity: number
      range: number | null
      cruiseSpeed: number | null
      fuelCapacity: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aircraftType"]>
    composites: {}
  }

  type AircraftTypeGetPayload<S extends boolean | null | undefined | AircraftTypeDefaultArgs> = $Result.GetResult<Prisma.$AircraftTypePayload, S>

  type AircraftTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AircraftTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AircraftTypeCountAggregateInputType | true
    }

  export interface AircraftTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AircraftType'], meta: { name: 'AircraftType' } }
    /**
     * Find zero or one AircraftType that matches the filter.
     * @param {AircraftTypeFindUniqueArgs} args - Arguments to find a AircraftType
     * @example
     * // Get one AircraftType
     * const aircraftType = await prisma.aircraftType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AircraftTypeFindUniqueArgs>(args: SelectSubset<T, AircraftTypeFindUniqueArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AircraftType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AircraftTypeFindUniqueOrThrowArgs} args - Arguments to find a AircraftType
     * @example
     * // Get one AircraftType
     * const aircraftType = await prisma.aircraftType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AircraftTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AircraftTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AircraftType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeFindFirstArgs} args - Arguments to find a AircraftType
     * @example
     * // Get one AircraftType
     * const aircraftType = await prisma.aircraftType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AircraftTypeFindFirstArgs>(args?: SelectSubset<T, AircraftTypeFindFirstArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AircraftType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeFindFirstOrThrowArgs} args - Arguments to find a AircraftType
     * @example
     * // Get one AircraftType
     * const aircraftType = await prisma.aircraftType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AircraftTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AircraftTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AircraftTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AircraftTypes
     * const aircraftTypes = await prisma.aircraftType.findMany()
     * 
     * // Get first 10 AircraftTypes
     * const aircraftTypes = await prisma.aircraftType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aircraftTypeWithIdOnly = await prisma.aircraftType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AircraftTypeFindManyArgs>(args?: SelectSubset<T, AircraftTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AircraftType.
     * @param {AircraftTypeCreateArgs} args - Arguments to create a AircraftType.
     * @example
     * // Create one AircraftType
     * const AircraftType = await prisma.aircraftType.create({
     *   data: {
     *     // ... data to create a AircraftType
     *   }
     * })
     * 
     */
    create<T extends AircraftTypeCreateArgs>(args: SelectSubset<T, AircraftTypeCreateArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AircraftTypes.
     * @param {AircraftTypeCreateManyArgs} args - Arguments to create many AircraftTypes.
     * @example
     * // Create many AircraftTypes
     * const aircraftType = await prisma.aircraftType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AircraftTypeCreateManyArgs>(args?: SelectSubset<T, AircraftTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AircraftTypes and returns the data saved in the database.
     * @param {AircraftTypeCreateManyAndReturnArgs} args - Arguments to create many AircraftTypes.
     * @example
     * // Create many AircraftTypes
     * const aircraftType = await prisma.aircraftType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AircraftTypes and only return the `id`
     * const aircraftTypeWithIdOnly = await prisma.aircraftType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AircraftTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AircraftTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AircraftType.
     * @param {AircraftTypeDeleteArgs} args - Arguments to delete one AircraftType.
     * @example
     * // Delete one AircraftType
     * const AircraftType = await prisma.aircraftType.delete({
     *   where: {
     *     // ... filter to delete one AircraftType
     *   }
     * })
     * 
     */
    delete<T extends AircraftTypeDeleteArgs>(args: SelectSubset<T, AircraftTypeDeleteArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AircraftType.
     * @param {AircraftTypeUpdateArgs} args - Arguments to update one AircraftType.
     * @example
     * // Update one AircraftType
     * const aircraftType = await prisma.aircraftType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AircraftTypeUpdateArgs>(args: SelectSubset<T, AircraftTypeUpdateArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AircraftTypes.
     * @param {AircraftTypeDeleteManyArgs} args - Arguments to filter AircraftTypes to delete.
     * @example
     * // Delete a few AircraftTypes
     * const { count } = await prisma.aircraftType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AircraftTypeDeleteManyArgs>(args?: SelectSubset<T, AircraftTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AircraftTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AircraftTypes
     * const aircraftType = await prisma.aircraftType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AircraftTypeUpdateManyArgs>(args: SelectSubset<T, AircraftTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AircraftTypes and returns the data updated in the database.
     * @param {AircraftTypeUpdateManyAndReturnArgs} args - Arguments to update many AircraftTypes.
     * @example
     * // Update many AircraftTypes
     * const aircraftType = await prisma.aircraftType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AircraftTypes and only return the `id`
     * const aircraftTypeWithIdOnly = await prisma.aircraftType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AircraftTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, AircraftTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AircraftType.
     * @param {AircraftTypeUpsertArgs} args - Arguments to update or create a AircraftType.
     * @example
     * // Update or create a AircraftType
     * const aircraftType = await prisma.aircraftType.upsert({
     *   create: {
     *     // ... data to create a AircraftType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AircraftType we want to update
     *   }
     * })
     */
    upsert<T extends AircraftTypeUpsertArgs>(args: SelectSubset<T, AircraftTypeUpsertArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AircraftTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeCountArgs} args - Arguments to filter AircraftTypes to count.
     * @example
     * // Count the number of AircraftTypes
     * const count = await prisma.aircraftType.count({
     *   where: {
     *     // ... the filter for the AircraftTypes we want to count
     *   }
     * })
    **/
    count<T extends AircraftTypeCountArgs>(
      args?: Subset<T, AircraftTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AircraftTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AircraftType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AircraftTypeAggregateArgs>(args: Subset<T, AircraftTypeAggregateArgs>): Prisma.PrismaPromise<GetAircraftTypeAggregateType<T>>

    /**
     * Group by AircraftType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AircraftTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AircraftTypeGroupByArgs['orderBy'] }
        : { orderBy?: AircraftTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AircraftTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAircraftTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AircraftType model
   */
  readonly fields: AircraftTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AircraftType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AircraftTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraft<T extends AircraftType$aircraftArgs<ExtArgs> = {}>(args?: Subset<T, AircraftType$aircraftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AircraftType model
   */
  interface AircraftTypeFieldRefs {
    readonly id: FieldRef<"AircraftType", 'String'>
    readonly manufacturer: FieldRef<"AircraftType", 'String'>
    readonly model: FieldRef<"AircraftType", 'String'>
    readonly variant: FieldRef<"AircraftType", 'String'>
    readonly capacity: FieldRef<"AircraftType", 'Int'>
    readonly range: FieldRef<"AircraftType", 'Int'>
    readonly cruiseSpeed: FieldRef<"AircraftType", 'Int'>
    readonly fuelCapacity: FieldRef<"AircraftType", 'Int'>
    readonly isActive: FieldRef<"AircraftType", 'Boolean'>
    readonly createdAt: FieldRef<"AircraftType", 'DateTime'>
    readonly updatedAt: FieldRef<"AircraftType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AircraftType findUnique
   */
  export type AircraftTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter, which AircraftType to fetch.
     */
    where: AircraftTypeWhereUniqueInput
  }

  /**
   * AircraftType findUniqueOrThrow
   */
  export type AircraftTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter, which AircraftType to fetch.
     */
    where: AircraftTypeWhereUniqueInput
  }

  /**
   * AircraftType findFirst
   */
  export type AircraftTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter, which AircraftType to fetch.
     */
    where?: AircraftTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AircraftTypes to fetch.
     */
    orderBy?: AircraftTypeOrderByWithRelationInput | AircraftTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AircraftTypes.
     */
    cursor?: AircraftTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AircraftTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AircraftTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AircraftTypes.
     */
    distinct?: AircraftTypeScalarFieldEnum | AircraftTypeScalarFieldEnum[]
  }

  /**
   * AircraftType findFirstOrThrow
   */
  export type AircraftTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter, which AircraftType to fetch.
     */
    where?: AircraftTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AircraftTypes to fetch.
     */
    orderBy?: AircraftTypeOrderByWithRelationInput | AircraftTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AircraftTypes.
     */
    cursor?: AircraftTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AircraftTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AircraftTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AircraftTypes.
     */
    distinct?: AircraftTypeScalarFieldEnum | AircraftTypeScalarFieldEnum[]
  }

  /**
   * AircraftType findMany
   */
  export type AircraftTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter, which AircraftTypes to fetch.
     */
    where?: AircraftTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AircraftTypes to fetch.
     */
    orderBy?: AircraftTypeOrderByWithRelationInput | AircraftTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AircraftTypes.
     */
    cursor?: AircraftTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AircraftTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AircraftTypes.
     */
    skip?: number
    distinct?: AircraftTypeScalarFieldEnum | AircraftTypeScalarFieldEnum[]
  }

  /**
   * AircraftType create
   */
  export type AircraftTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AircraftType.
     */
    data: XOR<AircraftTypeCreateInput, AircraftTypeUncheckedCreateInput>
  }

  /**
   * AircraftType createMany
   */
  export type AircraftTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AircraftTypes.
     */
    data: AircraftTypeCreateManyInput | AircraftTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AircraftType createManyAndReturn
   */
  export type AircraftTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * The data used to create many AircraftTypes.
     */
    data: AircraftTypeCreateManyInput | AircraftTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AircraftType update
   */
  export type AircraftTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AircraftType.
     */
    data: XOR<AircraftTypeUpdateInput, AircraftTypeUncheckedUpdateInput>
    /**
     * Choose, which AircraftType to update.
     */
    where: AircraftTypeWhereUniqueInput
  }

  /**
   * AircraftType updateMany
   */
  export type AircraftTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AircraftTypes.
     */
    data: XOR<AircraftTypeUpdateManyMutationInput, AircraftTypeUncheckedUpdateManyInput>
    /**
     * Filter which AircraftTypes to update
     */
    where?: AircraftTypeWhereInput
    /**
     * Limit how many AircraftTypes to update.
     */
    limit?: number
  }

  /**
   * AircraftType updateManyAndReturn
   */
  export type AircraftTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * The data used to update AircraftTypes.
     */
    data: XOR<AircraftTypeUpdateManyMutationInput, AircraftTypeUncheckedUpdateManyInput>
    /**
     * Filter which AircraftTypes to update
     */
    where?: AircraftTypeWhereInput
    /**
     * Limit how many AircraftTypes to update.
     */
    limit?: number
  }

  /**
   * AircraftType upsert
   */
  export type AircraftTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AircraftType to update in case it exists.
     */
    where: AircraftTypeWhereUniqueInput
    /**
     * In case the AircraftType found by the `where` argument doesn't exist, create a new AircraftType with this data.
     */
    create: XOR<AircraftTypeCreateInput, AircraftTypeUncheckedCreateInput>
    /**
     * In case the AircraftType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AircraftTypeUpdateInput, AircraftTypeUncheckedUpdateInput>
  }

  /**
   * AircraftType delete
   */
  export type AircraftTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
    /**
     * Filter which AircraftType to delete.
     */
    where: AircraftTypeWhereUniqueInput
  }

  /**
   * AircraftType deleteMany
   */
  export type AircraftTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AircraftTypes to delete
     */
    where?: AircraftTypeWhereInput
    /**
     * Limit how many AircraftTypes to delete.
     */
    limit?: number
  }

  /**
   * AircraftType.aircraft
   */
  export type AircraftType$aircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    where?: AircraftWhereInput
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    cursor?: AircraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * AircraftType without action
   */
  export type AircraftTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftType
     */
    select?: AircraftTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AircraftType
     */
    omit?: AircraftTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftTypeInclude<ExtArgs> | null
  }


  /**
   * Model Aircraft
   */

  export type AggregateAircraft = {
    _count: AircraftCountAggregateOutputType | null
    _min: AircraftMinAggregateOutputType | null
    _max: AircraftMaxAggregateOutputType | null
  }

  export type AircraftMinAggregateOutputType = {
    id: string | null
    registration: string | null
    airlineId: string | null
    aircraftTypeId: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AircraftMaxAggregateOutputType = {
    id: string | null
    registration: string | null
    airlineId: string | null
    aircraftTypeId: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AircraftCountAggregateOutputType = {
    id: number
    registration: number
    airlineId: number
    aircraftTypeId: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AircraftMinAggregateInputType = {
    id?: true
    registration?: true
    airlineId?: true
    aircraftTypeId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AircraftMaxAggregateInputType = {
    id?: true
    registration?: true
    airlineId?: true
    aircraftTypeId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AircraftCountAggregateInputType = {
    id?: true
    registration?: true
    airlineId?: true
    aircraftTypeId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AircraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aircraft to aggregate.
     */
    where?: AircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aircraft to fetch.
     */
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Aircraft
    **/
    _count?: true | AircraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AircraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AircraftMaxAggregateInputType
  }

  export type GetAircraftAggregateType<T extends AircraftAggregateArgs> = {
        [P in keyof T & keyof AggregateAircraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAircraft[P]>
      : GetScalarType<T[P], AggregateAircraft[P]>
  }




  export type AircraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AircraftWhereInput
    orderBy?: AircraftOrderByWithAggregationInput | AircraftOrderByWithAggregationInput[]
    by: AircraftScalarFieldEnum[] | AircraftScalarFieldEnum
    having?: AircraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AircraftCountAggregateInputType | true
    _min?: AircraftMinAggregateInputType
    _max?: AircraftMaxAggregateInputType
  }

  export type AircraftGroupByOutputType = {
    id: string
    registration: string
    airlineId: string
    aircraftTypeId: string
    name: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AircraftCountAggregateOutputType | null
    _min: AircraftMinAggregateOutputType | null
    _max: AircraftMaxAggregateOutputType | null
  }

  type GetAircraftGroupByPayload<T extends AircraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AircraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AircraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AircraftGroupByOutputType[P]>
            : GetScalarType<T[P], AircraftGroupByOutputType[P]>
        }
      >
    >


  export type AircraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration?: boolean
    airlineId?: boolean
    aircraftTypeId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    flights?: boolean | Aircraft$flightsArgs<ExtArgs>
    _count?: boolean | AircraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraft"]>

  export type AircraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration?: boolean
    airlineId?: boolean
    aircraftTypeId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraft"]>

  export type AircraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration?: boolean
    airlineId?: boolean
    aircraftTypeId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraft"]>

  export type AircraftSelectScalar = {
    id?: boolean
    registration?: boolean
    airlineId?: boolean
    aircraftTypeId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AircraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registration" | "airlineId" | "aircraftTypeId" | "name" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["aircraft"]>
  export type AircraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    flights?: boolean | Aircraft$flightsArgs<ExtArgs>
    _count?: boolean | AircraftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AircraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }
  export type AircraftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraftType?: boolean | AircraftTypeDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }

  export type $AircraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Aircraft"
    objects: {
      aircraftType: Prisma.$AircraftTypePayload<ExtArgs>
      airline: Prisma.$AirlinePayload<ExtArgs>
      flights: Prisma.$FlightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      registration: string
      airlineId: string
      aircraftTypeId: string
      name: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aircraft"]>
    composites: {}
  }

  type AircraftGetPayload<S extends boolean | null | undefined | AircraftDefaultArgs> = $Result.GetResult<Prisma.$AircraftPayload, S>

  type AircraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AircraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AircraftCountAggregateInputType | true
    }

  export interface AircraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Aircraft'], meta: { name: 'Aircraft' } }
    /**
     * Find zero or one Aircraft that matches the filter.
     * @param {AircraftFindUniqueArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AircraftFindUniqueArgs>(args: SelectSubset<T, AircraftFindUniqueArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aircraft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AircraftFindUniqueOrThrowArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AircraftFindUniqueOrThrowArgs>(args: SelectSubset<T, AircraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftFindFirstArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AircraftFindFirstArgs>(args?: SelectSubset<T, AircraftFindFirstArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftFindFirstOrThrowArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AircraftFindFirstOrThrowArgs>(args?: SelectSubset<T, AircraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aircraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aircraft
     * const aircraft = await prisma.aircraft.findMany()
     * 
     * // Get first 10 Aircraft
     * const aircraft = await prisma.aircraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aircraftWithIdOnly = await prisma.aircraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AircraftFindManyArgs>(args?: SelectSubset<T, AircraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aircraft.
     * @param {AircraftCreateArgs} args - Arguments to create a Aircraft.
     * @example
     * // Create one Aircraft
     * const Aircraft = await prisma.aircraft.create({
     *   data: {
     *     // ... data to create a Aircraft
     *   }
     * })
     * 
     */
    create<T extends AircraftCreateArgs>(args: SelectSubset<T, AircraftCreateArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aircraft.
     * @param {AircraftCreateManyArgs} args - Arguments to create many Aircraft.
     * @example
     * // Create many Aircraft
     * const aircraft = await prisma.aircraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AircraftCreateManyArgs>(args?: SelectSubset<T, AircraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Aircraft and returns the data saved in the database.
     * @param {AircraftCreateManyAndReturnArgs} args - Arguments to create many Aircraft.
     * @example
     * // Create many Aircraft
     * const aircraft = await prisma.aircraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Aircraft and only return the `id`
     * const aircraftWithIdOnly = await prisma.aircraft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AircraftCreateManyAndReturnArgs>(args?: SelectSubset<T, AircraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Aircraft.
     * @param {AircraftDeleteArgs} args - Arguments to delete one Aircraft.
     * @example
     * // Delete one Aircraft
     * const Aircraft = await prisma.aircraft.delete({
     *   where: {
     *     // ... filter to delete one Aircraft
     *   }
     * })
     * 
     */
    delete<T extends AircraftDeleteArgs>(args: SelectSubset<T, AircraftDeleteArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aircraft.
     * @param {AircraftUpdateArgs} args - Arguments to update one Aircraft.
     * @example
     * // Update one Aircraft
     * const aircraft = await prisma.aircraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AircraftUpdateArgs>(args: SelectSubset<T, AircraftUpdateArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aircraft.
     * @param {AircraftDeleteManyArgs} args - Arguments to filter Aircraft to delete.
     * @example
     * // Delete a few Aircraft
     * const { count } = await prisma.aircraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AircraftDeleteManyArgs>(args?: SelectSubset<T, AircraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aircraft
     * const aircraft = await prisma.aircraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AircraftUpdateManyArgs>(args: SelectSubset<T, AircraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aircraft and returns the data updated in the database.
     * @param {AircraftUpdateManyAndReturnArgs} args - Arguments to update many Aircraft.
     * @example
     * // Update many Aircraft
     * const aircraft = await prisma.aircraft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Aircraft and only return the `id`
     * const aircraftWithIdOnly = await prisma.aircraft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AircraftUpdateManyAndReturnArgs>(args: SelectSubset<T, AircraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Aircraft.
     * @param {AircraftUpsertArgs} args - Arguments to update or create a Aircraft.
     * @example
     * // Update or create a Aircraft
     * const aircraft = await prisma.aircraft.upsert({
     *   create: {
     *     // ... data to create a Aircraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aircraft we want to update
     *   }
     * })
     */
    upsert<T extends AircraftUpsertArgs>(args: SelectSubset<T, AircraftUpsertArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftCountArgs} args - Arguments to filter Aircraft to count.
     * @example
     * // Count the number of Aircraft
     * const count = await prisma.aircraft.count({
     *   where: {
     *     // ... the filter for the Aircraft we want to count
     *   }
     * })
    **/
    count<T extends AircraftCountArgs>(
      args?: Subset<T, AircraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AircraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AircraftAggregateArgs>(args: Subset<T, AircraftAggregateArgs>): Prisma.PrismaPromise<GetAircraftAggregateType<T>>

    /**
     * Group by Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AircraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AircraftGroupByArgs['orderBy'] }
        : { orderBy?: AircraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AircraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAircraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Aircraft model
   */
  readonly fields: AircraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aircraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AircraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraftType<T extends AircraftTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AircraftTypeDefaultArgs<ExtArgs>>): Prisma__AircraftTypeClient<$Result.GetResult<Prisma.$AircraftTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    airline<T extends AirlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirlineDefaultArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flights<T extends Aircraft$flightsArgs<ExtArgs> = {}>(args?: Subset<T, Aircraft$flightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Aircraft model
   */
  interface AircraftFieldRefs {
    readonly id: FieldRef<"Aircraft", 'String'>
    readonly registration: FieldRef<"Aircraft", 'String'>
    readonly airlineId: FieldRef<"Aircraft", 'String'>
    readonly aircraftTypeId: FieldRef<"Aircraft", 'String'>
    readonly name: FieldRef<"Aircraft", 'String'>
    readonly isActive: FieldRef<"Aircraft", 'Boolean'>
    readonly createdAt: FieldRef<"Aircraft", 'DateTime'>
    readonly updatedAt: FieldRef<"Aircraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Aircraft findUnique
   */
  export type AircraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter, which Aircraft to fetch.
     */
    where: AircraftWhereUniqueInput
  }

  /**
   * Aircraft findUniqueOrThrow
   */
  export type AircraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter, which Aircraft to fetch.
     */
    where: AircraftWhereUniqueInput
  }

  /**
   * Aircraft findFirst
   */
  export type AircraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter, which Aircraft to fetch.
     */
    where?: AircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aircraft to fetch.
     */
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Aircraft.
     */
    cursor?: AircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Aircraft.
     */
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * Aircraft findFirstOrThrow
   */
  export type AircraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter, which Aircraft to fetch.
     */
    where?: AircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aircraft to fetch.
     */
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Aircraft.
     */
    cursor?: AircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Aircraft.
     */
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * Aircraft findMany
   */
  export type AircraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter, which Aircraft to fetch.
     */
    where?: AircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aircraft to fetch.
     */
    orderBy?: AircraftOrderByWithRelationInput | AircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Aircraft.
     */
    cursor?: AircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aircraft.
     */
    skip?: number
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * Aircraft create
   */
  export type AircraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * The data needed to create a Aircraft.
     */
    data: XOR<AircraftCreateInput, AircraftUncheckedCreateInput>
  }

  /**
   * Aircraft createMany
   */
  export type AircraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Aircraft.
     */
    data: AircraftCreateManyInput | AircraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Aircraft createManyAndReturn
   */
  export type AircraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * The data used to create many Aircraft.
     */
    data: AircraftCreateManyInput | AircraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Aircraft update
   */
  export type AircraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * The data needed to update a Aircraft.
     */
    data: XOR<AircraftUpdateInput, AircraftUncheckedUpdateInput>
    /**
     * Choose, which Aircraft to update.
     */
    where: AircraftWhereUniqueInput
  }

  /**
   * Aircraft updateMany
   */
  export type AircraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Aircraft.
     */
    data: XOR<AircraftUpdateManyMutationInput, AircraftUncheckedUpdateManyInput>
    /**
     * Filter which Aircraft to update
     */
    where?: AircraftWhereInput
    /**
     * Limit how many Aircraft to update.
     */
    limit?: number
  }

  /**
   * Aircraft updateManyAndReturn
   */
  export type AircraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * The data used to update Aircraft.
     */
    data: XOR<AircraftUpdateManyMutationInput, AircraftUncheckedUpdateManyInput>
    /**
     * Filter which Aircraft to update
     */
    where?: AircraftWhereInput
    /**
     * Limit how many Aircraft to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Aircraft upsert
   */
  export type AircraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * The filter to search for the Aircraft to update in case it exists.
     */
    where: AircraftWhereUniqueInput
    /**
     * In case the Aircraft found by the `where` argument doesn't exist, create a new Aircraft with this data.
     */
    create: XOR<AircraftCreateInput, AircraftUncheckedCreateInput>
    /**
     * In case the Aircraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AircraftUpdateInput, AircraftUncheckedUpdateInput>
  }

  /**
   * Aircraft delete
   */
  export type AircraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
    /**
     * Filter which Aircraft to delete.
     */
    where: AircraftWhereUniqueInput
  }

  /**
   * Aircraft deleteMany
   */
  export type AircraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aircraft to delete
     */
    where?: AircraftWhereInput
    /**
     * Limit how many Aircraft to delete.
     */
    limit?: number
  }

  /**
   * Aircraft.flights
   */
  export type Aircraft$flightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    cursor?: FlightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Aircraft without action
   */
  export type AircraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aircraft
     */
    select?: AircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aircraft
     */
    omit?: AircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AircraftInclude<ExtArgs> | null
  }


  /**
   * Model Destination
   */

  export type AggregateDestination = {
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  export type DestinationAvgAggregateOutputType = {
    rating: number | null
  }

  export type DestinationSumAggregateOutputType = {
    rating: number | null
  }

  export type DestinationMinAggregateOutputType = {
    id: string | null
    name: string | null
    cityId: string | null
    countryId: string | null
    airportId: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    rating: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cityId: string | null
    countryId: string | null
    airportId: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    rating: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DestinationCountAggregateOutputType = {
    id: number
    name: number
    cityId: number
    countryId: number
    airportId: number
    description: number
    imageUrl: number
    category: number
    rating: number
    isActive: number
    isFeatured: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DestinationAvgAggregateInputType = {
    rating?: true
  }

  export type DestinationSumAggregateInputType = {
    rating?: true
  }

  export type DestinationMinAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    countryId?: true
    airportId?: true
    description?: true
    imageUrl?: true
    category?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationMaxAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    countryId?: true
    airportId?: true
    description?: true
    imageUrl?: true
    category?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DestinationCountAggregateInputType = {
    id?: true
    name?: true
    cityId?: true
    countryId?: true
    airportId?: true
    description?: true
    imageUrl?: true
    category?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destination to aggregate.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinations
    **/
    _count?: true | DestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationMaxAggregateInputType
  }

  export type GetDestinationAggregateType<T extends DestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestination[P]>
      : GetScalarType<T[P], AggregateDestination[P]>
  }




  export type DestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithAggregationInput | DestinationOrderByWithAggregationInput[]
    by: DestinationScalarFieldEnum[] | DestinationScalarFieldEnum
    having?: DestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationCountAggregateInputType | true
    _avg?: DestinationAvgAggregateInputType
    _sum?: DestinationSumAggregateInputType
    _min?: DestinationMinAggregateInputType
    _max?: DestinationMaxAggregateInputType
  }

  export type DestinationGroupByOutputType = {
    id: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description: string | null
    imageUrl: string | null
    category: string
    rating: number | null
    isActive: boolean
    isFeatured: boolean
    createdAt: Date
    updatedAt: Date
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  type GetDestinationGroupByPayload<T extends DestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationGroupByOutputType[P]>
        }
      >
    >


  export type DestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cityId?: boolean
    countryId?: boolean
    airportId?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingsTo?: boolean | Destination$bookingsToArgs<ExtArgs>
    bookingsFrom?: boolean | Destination$bookingsFromArgs<ExtArgs>
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    promotions?: boolean | Destination$promotionsArgs<ExtArgs>
    reviews?: boolean | Destination$reviewsArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cityId?: boolean
    countryId?: boolean
    airportId?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cityId?: boolean
    countryId?: boolean
    airportId?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectScalar = {
    id?: boolean
    name?: boolean
    cityId?: boolean
    countryId?: boolean
    airportId?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cityId" | "countryId" | "airportId" | "description" | "imageUrl" | "category" | "rating" | "isActive" | "isFeatured" | "createdAt" | "updatedAt", ExtArgs["result"]["destination"]>
  export type DestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingsTo?: boolean | Destination$bookingsToArgs<ExtArgs>
    bookingsFrom?: boolean | Destination$bookingsFromArgs<ExtArgs>
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    promotions?: boolean | Destination$promotionsArgs<ExtArgs>
    reviews?: boolean | Destination$reviewsArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type DestinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airport?: boolean | AirportDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $DestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Destination"
    objects: {
      bookingsTo: Prisma.$BookingPayload<ExtArgs>[]
      bookingsFrom: Prisma.$BookingPayload<ExtArgs>[]
      airport: Prisma.$AirportPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cityId: string
      countryId: string
      airportId: string
      description: string | null
      imageUrl: string | null
      category: string
      rating: number | null
      isActive: boolean
      isFeatured: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["destination"]>
    composites: {}
  }

  type DestinationGetPayload<S extends boolean | null | undefined | DestinationDefaultArgs> = $Result.GetResult<Prisma.$DestinationPayload, S>

  type DestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationCountAggregateInputType | true
    }

  export interface DestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Destination'], meta: { name: 'Destination' } }
    /**
     * Find zero or one Destination that matches the filter.
     * @param {DestinationFindUniqueArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationFindUniqueArgs>(args: SelectSubset<T, DestinationFindUniqueArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Destination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationFindUniqueOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationFindFirstArgs>(args?: SelectSubset<T, DestinationFindFirstArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Destinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinations
     * const destinations = await prisma.destination.findMany()
     * 
     * // Get first 10 Destinations
     * const destinations = await prisma.destination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationWithIdOnly = await prisma.destination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationFindManyArgs>(args?: SelectSubset<T, DestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Destination.
     * @param {DestinationCreateArgs} args - Arguments to create a Destination.
     * @example
     * // Create one Destination
     * const Destination = await prisma.destination.create({
     *   data: {
     *     // ... data to create a Destination
     *   }
     * })
     * 
     */
    create<T extends DestinationCreateArgs>(args: SelectSubset<T, DestinationCreateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Destinations.
     * @param {DestinationCreateManyArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationCreateManyArgs>(args?: SelectSubset<T, DestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Destinations and returns the data saved in the database.
     * @param {DestinationCreateManyAndReturnArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Destination.
     * @param {DestinationDeleteArgs} args - Arguments to delete one Destination.
     * @example
     * // Delete one Destination
     * const Destination = await prisma.destination.delete({
     *   where: {
     *     // ... filter to delete one Destination
     *   }
     * })
     * 
     */
    delete<T extends DestinationDeleteArgs>(args: SelectSubset<T, DestinationDeleteArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Destination.
     * @param {DestinationUpdateArgs} args - Arguments to update one Destination.
     * @example
     * // Update one Destination
     * const destination = await prisma.destination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationUpdateArgs>(args: SelectSubset<T, DestinationUpdateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Destinations.
     * @param {DestinationDeleteManyArgs} args - Arguments to filter Destinations to delete.
     * @example
     * // Delete a few Destinations
     * const { count } = await prisma.destination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationDeleteManyArgs>(args?: SelectSubset<T, DestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationUpdateManyArgs>(args: SelectSubset<T, DestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations and returns the data updated in the database.
     * @param {DestinationUpdateManyAndReturnArgs} args - Arguments to update many Destinations.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Destination.
     * @param {DestinationUpsertArgs} args - Arguments to update or create a Destination.
     * @example
     * // Update or create a Destination
     * const destination = await prisma.destination.upsert({
     *   create: {
     *     // ... data to create a Destination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destination we want to update
     *   }
     * })
     */
    upsert<T extends DestinationUpsertArgs>(args: SelectSubset<T, DestinationUpsertArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationCountArgs} args - Arguments to filter Destinations to count.
     * @example
     * // Count the number of Destinations
     * const count = await prisma.destination.count({
     *   where: {
     *     // ... the filter for the Destinations we want to count
     *   }
     * })
    **/
    count<T extends DestinationCountArgs>(
      args?: Subset<T, DestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationAggregateArgs>(args: Subset<T, DestinationAggregateArgs>): Prisma.PrismaPromise<GetDestinationAggregateType<T>>

    /**
     * Group by Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationGroupByArgs['orderBy'] }
        : { orderBy?: DestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Destination model
   */
  readonly fields: DestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingsTo<T extends Destination$bookingsToArgs<ExtArgs> = {}>(args?: Subset<T, Destination$bookingsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingsFrom<T extends Destination$bookingsFromArgs<ExtArgs> = {}>(args?: Subset<T, Destination$bookingsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    airport<T extends AirportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirportDefaultArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    promotions<T extends Destination$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Destination$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Destination$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Destination$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Destination model
   */
  interface DestinationFieldRefs {
    readonly id: FieldRef<"Destination", 'String'>
    readonly name: FieldRef<"Destination", 'String'>
    readonly cityId: FieldRef<"Destination", 'String'>
    readonly countryId: FieldRef<"Destination", 'String'>
    readonly airportId: FieldRef<"Destination", 'String'>
    readonly description: FieldRef<"Destination", 'String'>
    readonly imageUrl: FieldRef<"Destination", 'String'>
    readonly category: FieldRef<"Destination", 'String'>
    readonly rating: FieldRef<"Destination", 'Float'>
    readonly isActive: FieldRef<"Destination", 'Boolean'>
    readonly isFeatured: FieldRef<"Destination", 'Boolean'>
    readonly createdAt: FieldRef<"Destination", 'DateTime'>
    readonly updatedAt: FieldRef<"Destination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Destination findUnique
   */
  export type DestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findUniqueOrThrow
   */
  export type DestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findFirst
   */
  export type DestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findFirstOrThrow
   */
  export type DestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findMany
   */
  export type DestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destinations to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination create
   */
  export type DestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Destination.
     */
    data: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
  }

  /**
   * Destination createMany
   */
  export type DestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination createManyAndReturn
   */
  export type DestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Destination update
   */
  export type DestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Destination.
     */
    data: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
    /**
     * Choose, which Destination to update.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination updateMany
   */
  export type DestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination updateManyAndReturn
   */
  export type DestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Destination upsert
   */
  export type DestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Destination to update in case it exists.
     */
    where: DestinationWhereUniqueInput
    /**
     * In case the Destination found by the `where` argument doesn't exist, create a new Destination with this data.
     */
    create: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
    /**
     * In case the Destination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
  }

  /**
   * Destination delete
   */
  export type DestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter which Destination to delete.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination deleteMany
   */
  export type DestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destinations to delete
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to delete.
     */
    limit?: number
  }

  /**
   * Destination.bookingsTo
   */
  export type Destination$bookingsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Destination.bookingsFrom
   */
  export type Destination$bookingsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Destination.promotions
   */
  export type Destination$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Destination.reviews
   */
  export type Destination$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Destination without action
   */
  export type DestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
  }


  /**
   * Model Flight
   */

  export type AggregateFlight = {
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  export type FlightAvgAggregateOutputType = {
    duration: number | null
    distance: number | null
  }

  export type FlightSumAggregateOutputType = {
    duration: number | null
    distance: number | null
  }

  export type FlightMinAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    airlineId: string | null
    aircraftId: string | null
    departureAirportId: string | null
    arrivalAirportId: string | null
    departureTime: Date | null
    arrivalTime: Date | null
    duration: number | null
    distance: number | null
    status: string | null
    gate: string | null
    terminal: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightMaxAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    airlineId: string | null
    aircraftId: string | null
    departureAirportId: string | null
    arrivalAirportId: string | null
    departureTime: Date | null
    arrivalTime: Date | null
    duration: number | null
    distance: number | null
    status: string | null
    gate: string | null
    terminal: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightCountAggregateOutputType = {
    id: number
    flightNumber: number
    airlineId: number
    aircraftId: number
    departureAirportId: number
    arrivalAirportId: number
    departureTime: number
    arrivalTime: number
    duration: number
    distance: number
    status: number
    gate: number
    terminal: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlightAvgAggregateInputType = {
    duration?: true
    distance?: true
  }

  export type FlightSumAggregateInputType = {
    duration?: true
    distance?: true
  }

  export type FlightMinAggregateInputType = {
    id?: true
    flightNumber?: true
    airlineId?: true
    aircraftId?: true
    departureAirportId?: true
    arrivalAirportId?: true
    departureTime?: true
    arrivalTime?: true
    duration?: true
    distance?: true
    status?: true
    gate?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightMaxAggregateInputType = {
    id?: true
    flightNumber?: true
    airlineId?: true
    aircraftId?: true
    departureAirportId?: true
    arrivalAirportId?: true
    departureTime?: true
    arrivalTime?: true
    duration?: true
    distance?: true
    status?: true
    gate?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightCountAggregateInputType = {
    id?: true
    flightNumber?: true
    airlineId?: true
    aircraftId?: true
    departureAirportId?: true
    arrivalAirportId?: true
    departureTime?: true
    arrivalTime?: true
    duration?: true
    distance?: true
    status?: true
    gate?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flight to aggregate.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flights
    **/
    _count?: true | FlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightMaxAggregateInputType
  }

  export type GetFlightAggregateType<T extends FlightAggregateArgs> = {
        [P in keyof T & keyof AggregateFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlight[P]>
      : GetScalarType<T[P], AggregateFlight[P]>
  }




  export type FlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithAggregationInput | FlightOrderByWithAggregationInput[]
    by: FlightScalarFieldEnum[] | FlightScalarFieldEnum
    having?: FlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightCountAggregateInputType | true
    _avg?: FlightAvgAggregateInputType
    _sum?: FlightSumAggregateInputType
    _min?: FlightMinAggregateInputType
    _max?: FlightMaxAggregateInputType
  }

  export type FlightGroupByOutputType = {
    id: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date
    arrivalTime: Date
    duration: number
    distance: number | null
    status: string
    gate: string | null
    terminal: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  type GetFlightGroupByPayload<T extends FlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightGroupByOutputType[P]>
            : GetScalarType<T[P], FlightGroupByOutputType[P]>
        }
      >
    >


  export type FlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    airlineId?: boolean
    aircraftId?: boolean
    departureAirportId?: boolean
    arrivalAirportId?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    duration?: boolean
    distance?: boolean
    status?: boolean
    gate?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Flight$bookingsArgs<ExtArgs>
    flightSchedules?: boolean | Flight$flightSchedulesArgs<ExtArgs>
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flight"]>

  export type FlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    airlineId?: boolean
    aircraftId?: boolean
    departureAirportId?: boolean
    arrivalAirportId?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    duration?: boolean
    distance?: boolean
    status?: boolean
    gate?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flight"]>

  export type FlightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    airlineId?: boolean
    aircraftId?: boolean
    departureAirportId?: boolean
    arrivalAirportId?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    duration?: boolean
    distance?: boolean
    status?: boolean
    gate?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flight"]>

  export type FlightSelectScalar = {
    id?: boolean
    flightNumber?: boolean
    airlineId?: boolean
    aircraftId?: boolean
    departureAirportId?: boolean
    arrivalAirportId?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    duration?: boolean
    distance?: boolean
    status?: boolean
    gate?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flightNumber" | "airlineId" | "aircraftId" | "departureAirportId" | "arrivalAirportId" | "departureTime" | "arrivalTime" | "duration" | "distance" | "status" | "gate" | "terminal" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["flight"]>
  export type FlightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Flight$bookingsArgs<ExtArgs>
    flightSchedules?: boolean | Flight$flightSchedulesArgs<ExtArgs>
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
  }
  export type FlightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AircraftDefaultArgs<ExtArgs>
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
    arrivalAirport?: boolean | AirportDefaultArgs<ExtArgs>
    departureAirport?: boolean | AirportDefaultArgs<ExtArgs>
  }

  export type $FlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flight"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      flightSchedules: Prisma.$FlightSchedulePayload<ExtArgs>[]
      aircraft: Prisma.$AircraftPayload<ExtArgs>
      airline: Prisma.$AirlinePayload<ExtArgs>
      arrivalAirport: Prisma.$AirportPayload<ExtArgs>
      departureAirport: Prisma.$AirportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flightNumber: string
      airlineId: string
      aircraftId: string
      departureAirportId: string
      arrivalAirportId: string
      departureTime: Date
      arrivalTime: Date
      duration: number
      distance: number | null
      status: string
      gate: string | null
      terminal: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flight"]>
    composites: {}
  }

  type FlightGetPayload<S extends boolean | null | undefined | FlightDefaultArgs> = $Result.GetResult<Prisma.$FlightPayload, S>

  type FlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightCountAggregateInputType | true
    }

  export interface FlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flight'], meta: { name: 'Flight' } }
    /**
     * Find zero or one Flight that matches the filter.
     * @param {FlightFindUniqueArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightFindUniqueArgs>(args: SelectSubset<T, FlightFindUniqueArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlightFindUniqueOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindFirstArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightFindFirstArgs>(args?: SelectSubset<T, FlightFindFirstArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindFirstOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flights
     * const flights = await prisma.flight.findMany()
     * 
     * // Get first 10 Flights
     * const flights = await prisma.flight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightWithIdOnly = await prisma.flight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightFindManyArgs>(args?: SelectSubset<T, FlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flight.
     * @param {FlightCreateArgs} args - Arguments to create a Flight.
     * @example
     * // Create one Flight
     * const Flight = await prisma.flight.create({
     *   data: {
     *     // ... data to create a Flight
     *   }
     * })
     * 
     */
    create<T extends FlightCreateArgs>(args: SelectSubset<T, FlightCreateArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flights.
     * @param {FlightCreateManyArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightCreateManyArgs>(args?: SelectSubset<T, FlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flights and returns the data saved in the database.
     * @param {FlightCreateManyAndReturnArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flights and only return the `id`
     * const flightWithIdOnly = await prisma.flight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flight.
     * @param {FlightDeleteArgs} args - Arguments to delete one Flight.
     * @example
     * // Delete one Flight
     * const Flight = await prisma.flight.delete({
     *   where: {
     *     // ... filter to delete one Flight
     *   }
     * })
     * 
     */
    delete<T extends FlightDeleteArgs>(args: SelectSubset<T, FlightDeleteArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flight.
     * @param {FlightUpdateArgs} args - Arguments to update one Flight.
     * @example
     * // Update one Flight
     * const flight = await prisma.flight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightUpdateArgs>(args: SelectSubset<T, FlightUpdateArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flights.
     * @param {FlightDeleteManyArgs} args - Arguments to filter Flights to delete.
     * @example
     * // Delete a few Flights
     * const { count } = await prisma.flight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightDeleteManyArgs>(args?: SelectSubset<T, FlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flights
     * const flight = await prisma.flight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightUpdateManyArgs>(args: SelectSubset<T, FlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flights and returns the data updated in the database.
     * @param {FlightUpdateManyAndReturnArgs} args - Arguments to update many Flights.
     * @example
     * // Update many Flights
     * const flight = await prisma.flight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flights and only return the `id`
     * const flightWithIdOnly = await prisma.flight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlightUpdateManyAndReturnArgs>(args: SelectSubset<T, FlightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flight.
     * @param {FlightUpsertArgs} args - Arguments to update or create a Flight.
     * @example
     * // Update or create a Flight
     * const flight = await prisma.flight.upsert({
     *   create: {
     *     // ... data to create a Flight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flight we want to update
     *   }
     * })
     */
    upsert<T extends FlightUpsertArgs>(args: SelectSubset<T, FlightUpsertArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightCountArgs} args - Arguments to filter Flights to count.
     * @example
     * // Count the number of Flights
     * const count = await prisma.flight.count({
     *   where: {
     *     // ... the filter for the Flights we want to count
     *   }
     * })
    **/
    count<T extends FlightCountArgs>(
      args?: Subset<T, FlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightAggregateArgs>(args: Subset<T, FlightAggregateArgs>): Prisma.PrismaPromise<GetFlightAggregateType<T>>

    /**
     * Group by Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightGroupByArgs['orderBy'] }
        : { orderBy?: FlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flight model
   */
  readonly fields: FlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Flight$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Flight$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flightSchedules<T extends Flight$flightSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Flight$flightSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aircraft<T extends AircraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AircraftDefaultArgs<ExtArgs>>): Prisma__AircraftClient<$Result.GetResult<Prisma.$AircraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    airline<T extends AirlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirlineDefaultArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    arrivalAirport<T extends AirportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirportDefaultArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    departureAirport<T extends AirportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirportDefaultArgs<ExtArgs>>): Prisma__AirportClient<$Result.GetResult<Prisma.$AirportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flight model
   */
  interface FlightFieldRefs {
    readonly id: FieldRef<"Flight", 'String'>
    readonly flightNumber: FieldRef<"Flight", 'String'>
    readonly airlineId: FieldRef<"Flight", 'String'>
    readonly aircraftId: FieldRef<"Flight", 'String'>
    readonly departureAirportId: FieldRef<"Flight", 'String'>
    readonly arrivalAirportId: FieldRef<"Flight", 'String'>
    readonly departureTime: FieldRef<"Flight", 'DateTime'>
    readonly arrivalTime: FieldRef<"Flight", 'DateTime'>
    readonly duration: FieldRef<"Flight", 'Int'>
    readonly distance: FieldRef<"Flight", 'Int'>
    readonly status: FieldRef<"Flight", 'String'>
    readonly gate: FieldRef<"Flight", 'String'>
    readonly terminal: FieldRef<"Flight", 'String'>
    readonly isActive: FieldRef<"Flight", 'Boolean'>
    readonly createdAt: FieldRef<"Flight", 'DateTime'>
    readonly updatedAt: FieldRef<"Flight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flight findUnique
   */
  export type FlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight findUniqueOrThrow
   */
  export type FlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight findFirst
   */
  export type FlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight findFirstOrThrow
   */
  export type FlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight findMany
   */
  export type FlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter, which Flights to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight create
   */
  export type FlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * The data needed to create a Flight.
     */
    data: XOR<FlightCreateInput, FlightUncheckedCreateInput>
  }

  /**
   * Flight createMany
   */
  export type FlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flights.
     */
    data: FlightCreateManyInput | FlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flight createManyAndReturn
   */
  export type FlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * The data used to create many Flights.
     */
    data: FlightCreateManyInput | FlightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flight update
   */
  export type FlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * The data needed to update a Flight.
     */
    data: XOR<FlightUpdateInput, FlightUncheckedUpdateInput>
    /**
     * Choose, which Flight to update.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight updateMany
   */
  export type FlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flights.
     */
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyInput>
    /**
     * Filter which Flights to update
     */
    where?: FlightWhereInput
    /**
     * Limit how many Flights to update.
     */
    limit?: number
  }

  /**
   * Flight updateManyAndReturn
   */
  export type FlightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * The data used to update Flights.
     */
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyInput>
    /**
     * Filter which Flights to update
     */
    where?: FlightWhereInput
    /**
     * Limit how many Flights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flight upsert
   */
  export type FlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * The filter to search for the Flight to update in case it exists.
     */
    where: FlightWhereUniqueInput
    /**
     * In case the Flight found by the `where` argument doesn't exist, create a new Flight with this data.
     */
    create: XOR<FlightCreateInput, FlightUncheckedCreateInput>
    /**
     * In case the Flight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightUpdateInput, FlightUncheckedUpdateInput>
  }

  /**
   * Flight delete
   */
  export type FlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    /**
     * Filter which Flight to delete.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight deleteMany
   */
  export type FlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flights to delete
     */
    where?: FlightWhereInput
    /**
     * Limit how many Flights to delete.
     */
    limit?: number
  }

  /**
   * Flight.bookings
   */
  export type Flight$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Flight.flightSchedules
   */
  export type Flight$flightSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    where?: FlightScheduleWhereInput
    orderBy?: FlightScheduleOrderByWithRelationInput | FlightScheduleOrderByWithRelationInput[]
    cursor?: FlightScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScheduleScalarFieldEnum | FlightScheduleScalarFieldEnum[]
  }

  /**
   * Flight without action
   */
  export type FlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
  }


  /**
   * Model FlightSchedule
   */

  export type AggregateFlightSchedule = {
    _count: FlightScheduleCountAggregateOutputType | null
    _avg: FlightScheduleAvgAggregateOutputType | null
    _sum: FlightScheduleSumAggregateOutputType | null
    _min: FlightScheduleMinAggregateOutputType | null
    _max: FlightScheduleMaxAggregateOutputType | null
  }

  export type FlightScheduleAvgAggregateOutputType = {
    availableSeats: number | null
    totalSeats: number | null
    basePrice: number | null
    currentPrice: number | null
  }

  export type FlightScheduleSumAggregateOutputType = {
    availableSeats: number | null
    totalSeats: number | null
    basePrice: number | null
    currentPrice: number | null
  }

  export type FlightScheduleMinAggregateOutputType = {
    id: string | null
    flightId: string | null
    classType: string | null
    availableSeats: number | null
    totalSeats: number | null
    basePrice: number | null
    currentPrice: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightScheduleMaxAggregateOutputType = {
    id: string | null
    flightId: string | null
    classType: string | null
    availableSeats: number | null
    totalSeats: number | null
    basePrice: number | null
    currentPrice: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightScheduleCountAggregateOutputType = {
    id: number
    flightId: number
    classType: number
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlightScheduleAvgAggregateInputType = {
    availableSeats?: true
    totalSeats?: true
    basePrice?: true
    currentPrice?: true
  }

  export type FlightScheduleSumAggregateInputType = {
    availableSeats?: true
    totalSeats?: true
    basePrice?: true
    currentPrice?: true
  }

  export type FlightScheduleMinAggregateInputType = {
    id?: true
    flightId?: true
    classType?: true
    availableSeats?: true
    totalSeats?: true
    basePrice?: true
    currentPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightScheduleMaxAggregateInputType = {
    id?: true
    flightId?: true
    classType?: true
    availableSeats?: true
    totalSeats?: true
    basePrice?: true
    currentPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightScheduleCountAggregateInputType = {
    id?: true
    flightId?: true
    classType?: true
    availableSeats?: true
    totalSeats?: true
    basePrice?: true
    currentPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlightScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightSchedule to aggregate.
     */
    where?: FlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightSchedules to fetch.
     */
    orderBy?: FlightScheduleOrderByWithRelationInput | FlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlightSchedules
    **/
    _count?: true | FlightScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightScheduleMaxAggregateInputType
  }

  export type GetFlightScheduleAggregateType<T extends FlightScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateFlightSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlightSchedule[P]>
      : GetScalarType<T[P], AggregateFlightSchedule[P]>
  }




  export type FlightScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightScheduleWhereInput
    orderBy?: FlightScheduleOrderByWithAggregationInput | FlightScheduleOrderByWithAggregationInput[]
    by: FlightScheduleScalarFieldEnum[] | FlightScheduleScalarFieldEnum
    having?: FlightScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightScheduleCountAggregateInputType | true
    _avg?: FlightScheduleAvgAggregateInputType
    _sum?: FlightScheduleSumAggregateInputType
    _min?: FlightScheduleMinAggregateInputType
    _max?: FlightScheduleMaxAggregateInputType
  }

  export type FlightScheduleGroupByOutputType = {
    id: string
    flightId: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FlightScheduleCountAggregateOutputType | null
    _avg: FlightScheduleAvgAggregateOutputType | null
    _sum: FlightScheduleSumAggregateOutputType | null
    _min: FlightScheduleMinAggregateOutputType | null
    _max: FlightScheduleMaxAggregateOutputType | null
  }

  type GetFlightScheduleGroupByPayload<T extends FlightScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], FlightScheduleGroupByOutputType[P]>
        }
      >
    >


  export type FlightScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightId?: boolean
    classType?: boolean
    availableSeats?: boolean
    totalSeats?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | FlightSchedule$bookingsArgs<ExtArgs>
    flight?: boolean | FlightDefaultArgs<ExtArgs>
    _count?: boolean | FlightScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightSchedule"]>

  export type FlightScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightId?: boolean
    classType?: boolean
    availableSeats?: boolean
    totalSeats?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flight?: boolean | FlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightSchedule"]>

  export type FlightScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightId?: boolean
    classType?: boolean
    availableSeats?: boolean
    totalSeats?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flight?: boolean | FlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightSchedule"]>

  export type FlightScheduleSelectScalar = {
    id?: boolean
    flightId?: boolean
    classType?: boolean
    availableSeats?: boolean
    totalSeats?: boolean
    basePrice?: boolean
    currentPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlightScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flightId" | "classType" | "availableSeats" | "totalSeats" | "basePrice" | "currentPrice" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["flightSchedule"]>
  export type FlightScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | FlightSchedule$bookingsArgs<ExtArgs>
    flight?: boolean | FlightDefaultArgs<ExtArgs>
    _count?: boolean | FlightScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlightScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight?: boolean | FlightDefaultArgs<ExtArgs>
  }
  export type FlightScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flight?: boolean | FlightDefaultArgs<ExtArgs>
  }

  export type $FlightSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlightSchedule"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      flight: Prisma.$FlightPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flightId: string
      classType: string
      availableSeats: number
      totalSeats: number
      basePrice: number
      currentPrice: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flightSchedule"]>
    composites: {}
  }

  type FlightScheduleGetPayload<S extends boolean | null | undefined | FlightScheduleDefaultArgs> = $Result.GetResult<Prisma.$FlightSchedulePayload, S>

  type FlightScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlightScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightScheduleCountAggregateInputType | true
    }

  export interface FlightScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlightSchedule'], meta: { name: 'FlightSchedule' } }
    /**
     * Find zero or one FlightSchedule that matches the filter.
     * @param {FlightScheduleFindUniqueArgs} args - Arguments to find a FlightSchedule
     * @example
     * // Get one FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightScheduleFindUniqueArgs>(args: SelectSubset<T, FlightScheduleFindUniqueArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlightSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlightScheduleFindUniqueOrThrowArgs} args - Arguments to find a FlightSchedule
     * @example
     * // Get one FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlightSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleFindFirstArgs} args - Arguments to find a FlightSchedule
     * @example
     * // Get one FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightScheduleFindFirstArgs>(args?: SelectSubset<T, FlightScheduleFindFirstArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlightSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleFindFirstOrThrowArgs} args - Arguments to find a FlightSchedule
     * @example
     * // Get one FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlightSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlightSchedules
     * const flightSchedules = await prisma.flightSchedule.findMany()
     * 
     * // Get first 10 FlightSchedules
     * const flightSchedules = await prisma.flightSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightScheduleWithIdOnly = await prisma.flightSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightScheduleFindManyArgs>(args?: SelectSubset<T, FlightScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlightSchedule.
     * @param {FlightScheduleCreateArgs} args - Arguments to create a FlightSchedule.
     * @example
     * // Create one FlightSchedule
     * const FlightSchedule = await prisma.flightSchedule.create({
     *   data: {
     *     // ... data to create a FlightSchedule
     *   }
     * })
     * 
     */
    create<T extends FlightScheduleCreateArgs>(args: SelectSubset<T, FlightScheduleCreateArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlightSchedules.
     * @param {FlightScheduleCreateManyArgs} args - Arguments to create many FlightSchedules.
     * @example
     * // Create many FlightSchedules
     * const flightSchedule = await prisma.flightSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightScheduleCreateManyArgs>(args?: SelectSubset<T, FlightScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlightSchedules and returns the data saved in the database.
     * @param {FlightScheduleCreateManyAndReturnArgs} args - Arguments to create many FlightSchedules.
     * @example
     * // Create many FlightSchedules
     * const flightSchedule = await prisma.flightSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlightSchedules and only return the `id`
     * const flightScheduleWithIdOnly = await prisma.flightSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlightSchedule.
     * @param {FlightScheduleDeleteArgs} args - Arguments to delete one FlightSchedule.
     * @example
     * // Delete one FlightSchedule
     * const FlightSchedule = await prisma.flightSchedule.delete({
     *   where: {
     *     // ... filter to delete one FlightSchedule
     *   }
     * })
     * 
     */
    delete<T extends FlightScheduleDeleteArgs>(args: SelectSubset<T, FlightScheduleDeleteArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlightSchedule.
     * @param {FlightScheduleUpdateArgs} args - Arguments to update one FlightSchedule.
     * @example
     * // Update one FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightScheduleUpdateArgs>(args: SelectSubset<T, FlightScheduleUpdateArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlightSchedules.
     * @param {FlightScheduleDeleteManyArgs} args - Arguments to filter FlightSchedules to delete.
     * @example
     * // Delete a few FlightSchedules
     * const { count } = await prisma.flightSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightScheduleDeleteManyArgs>(args?: SelectSubset<T, FlightScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlightSchedules
     * const flightSchedule = await prisma.flightSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightScheduleUpdateManyArgs>(args: SelectSubset<T, FlightScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightSchedules and returns the data updated in the database.
     * @param {FlightScheduleUpdateManyAndReturnArgs} args - Arguments to update many FlightSchedules.
     * @example
     * // Update many FlightSchedules
     * const flightSchedule = await prisma.flightSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlightSchedules and only return the `id`
     * const flightScheduleWithIdOnly = await prisma.flightSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlightScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, FlightScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlightSchedule.
     * @param {FlightScheduleUpsertArgs} args - Arguments to update or create a FlightSchedule.
     * @example
     * // Update or create a FlightSchedule
     * const flightSchedule = await prisma.flightSchedule.upsert({
     *   create: {
     *     // ... data to create a FlightSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlightSchedule we want to update
     *   }
     * })
     */
    upsert<T extends FlightScheduleUpsertArgs>(args: SelectSubset<T, FlightScheduleUpsertArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlightSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleCountArgs} args - Arguments to filter FlightSchedules to count.
     * @example
     * // Count the number of FlightSchedules
     * const count = await prisma.flightSchedule.count({
     *   where: {
     *     // ... the filter for the FlightSchedules we want to count
     *   }
     * })
    **/
    count<T extends FlightScheduleCountArgs>(
      args?: Subset<T, FlightScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlightSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightScheduleAggregateArgs>(args: Subset<T, FlightScheduleAggregateArgs>): Prisma.PrismaPromise<GetFlightScheduleAggregateType<T>>

    /**
     * Group by FlightSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightScheduleGroupByArgs['orderBy'] }
        : { orderBy?: FlightScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlightSchedule model
   */
  readonly fields: FlightScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlightSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends FlightSchedule$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, FlightSchedule$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flight<T extends FlightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlightDefaultArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlightSchedule model
   */
  interface FlightScheduleFieldRefs {
    readonly id: FieldRef<"FlightSchedule", 'String'>
    readonly flightId: FieldRef<"FlightSchedule", 'String'>
    readonly classType: FieldRef<"FlightSchedule", 'String'>
    readonly availableSeats: FieldRef<"FlightSchedule", 'Int'>
    readonly totalSeats: FieldRef<"FlightSchedule", 'Int'>
    readonly basePrice: FieldRef<"FlightSchedule", 'Float'>
    readonly currentPrice: FieldRef<"FlightSchedule", 'Float'>
    readonly isActive: FieldRef<"FlightSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"FlightSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"FlightSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlightSchedule findUnique
   */
  export type FlightScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FlightSchedule to fetch.
     */
    where: FlightScheduleWhereUniqueInput
  }

  /**
   * FlightSchedule findUniqueOrThrow
   */
  export type FlightScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FlightSchedule to fetch.
     */
    where: FlightScheduleWhereUniqueInput
  }

  /**
   * FlightSchedule findFirst
   */
  export type FlightScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FlightSchedule to fetch.
     */
    where?: FlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightSchedules to fetch.
     */
    orderBy?: FlightScheduleOrderByWithRelationInput | FlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightSchedules.
     */
    cursor?: FlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightSchedules.
     */
    distinct?: FlightScheduleScalarFieldEnum | FlightScheduleScalarFieldEnum[]
  }

  /**
   * FlightSchedule findFirstOrThrow
   */
  export type FlightScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FlightSchedule to fetch.
     */
    where?: FlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightSchedules to fetch.
     */
    orderBy?: FlightScheduleOrderByWithRelationInput | FlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightSchedules.
     */
    cursor?: FlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightSchedules.
     */
    distinct?: FlightScheduleScalarFieldEnum | FlightScheduleScalarFieldEnum[]
  }

  /**
   * FlightSchedule findMany
   */
  export type FlightScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FlightSchedules to fetch.
     */
    where?: FlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightSchedules to fetch.
     */
    orderBy?: FlightScheduleOrderByWithRelationInput | FlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlightSchedules.
     */
    cursor?: FlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightSchedules.
     */
    skip?: number
    distinct?: FlightScheduleScalarFieldEnum | FlightScheduleScalarFieldEnum[]
  }

  /**
   * FlightSchedule create
   */
  export type FlightScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a FlightSchedule.
     */
    data: XOR<FlightScheduleCreateInput, FlightScheduleUncheckedCreateInput>
  }

  /**
   * FlightSchedule createMany
   */
  export type FlightScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlightSchedules.
     */
    data: FlightScheduleCreateManyInput | FlightScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlightSchedule createManyAndReturn
   */
  export type FlightScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many FlightSchedules.
     */
    data: FlightScheduleCreateManyInput | FlightScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlightSchedule update
   */
  export type FlightScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a FlightSchedule.
     */
    data: XOR<FlightScheduleUpdateInput, FlightScheduleUncheckedUpdateInput>
    /**
     * Choose, which FlightSchedule to update.
     */
    where: FlightScheduleWhereUniqueInput
  }

  /**
   * FlightSchedule updateMany
   */
  export type FlightScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlightSchedules.
     */
    data: XOR<FlightScheduleUpdateManyMutationInput, FlightScheduleUncheckedUpdateManyInput>
    /**
     * Filter which FlightSchedules to update
     */
    where?: FlightScheduleWhereInput
    /**
     * Limit how many FlightSchedules to update.
     */
    limit?: number
  }

  /**
   * FlightSchedule updateManyAndReturn
   */
  export type FlightScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * The data used to update FlightSchedules.
     */
    data: XOR<FlightScheduleUpdateManyMutationInput, FlightScheduleUncheckedUpdateManyInput>
    /**
     * Filter which FlightSchedules to update
     */
    where?: FlightScheduleWhereInput
    /**
     * Limit how many FlightSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlightSchedule upsert
   */
  export type FlightScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the FlightSchedule to update in case it exists.
     */
    where: FlightScheduleWhereUniqueInput
    /**
     * In case the FlightSchedule found by the `where` argument doesn't exist, create a new FlightSchedule with this data.
     */
    create: XOR<FlightScheduleCreateInput, FlightScheduleUncheckedCreateInput>
    /**
     * In case the FlightSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightScheduleUpdateInput, FlightScheduleUncheckedUpdateInput>
  }

  /**
   * FlightSchedule delete
   */
  export type FlightScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    /**
     * Filter which FlightSchedule to delete.
     */
    where: FlightScheduleWhereUniqueInput
  }

  /**
   * FlightSchedule deleteMany
   */
  export type FlightScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightSchedules to delete
     */
    where?: FlightScheduleWhereInput
    /**
     * Limit how many FlightSchedules to delete.
     */
    limit?: number
  }

  /**
   * FlightSchedule.bookings
   */
  export type FlightSchedule$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * FlightSchedule without action
   */
  export type FlightScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    passengerCount: number | null
    totalPrice: number | null
    taxes: number | null
    fees: number | null
    discountAmount: number | null
    finalPrice: number | null
  }

  export type BookingSumAggregateOutputType = {
    passengerCount: number | null
    totalPrice: number | null
    taxes: number | null
    fees: number | null
    discountAmount: number | null
    finalPrice: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    bookingReference: string | null
    userId: string | null
    flightId: string | null
    flightScheduleId: string | null
    destinationId: string | null
    fromDestinationId: string | null
    departureDate: Date | null
    returnDate: Date | null
    passengerCount: number | null
    bookingClass: string | null
    totalPrice: number | null
    taxes: number | null
    fees: number | null
    discountAmount: number | null
    finalPrice: number | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    bookingReference: string | null
    userId: string | null
    flightId: string | null
    flightScheduleId: string | null
    destinationId: string | null
    fromDestinationId: string | null
    departureDate: Date | null
    returnDate: Date | null
    passengerCount: number | null
    bookingClass: string | null
    totalPrice: number | null
    taxes: number | null
    fees: number | null
    discountAmount: number | null
    finalPrice: number | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    bookingReference: number
    userId: number
    flightId: number
    flightScheduleId: number
    destinationId: number
    fromDestinationId: number
    departureDate: number
    returnDate: number
    passengerCount: number
    bookingClass: number
    totalPrice: number
    taxes: number
    fees: number
    discountAmount: number
    finalPrice: number
    status: number
    paymentStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    passengerCount?: true
    totalPrice?: true
    taxes?: true
    fees?: true
    discountAmount?: true
    finalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    passengerCount?: true
    totalPrice?: true
    taxes?: true
    fees?: true
    discountAmount?: true
    finalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    bookingReference?: true
    userId?: true
    flightId?: true
    flightScheduleId?: true
    destinationId?: true
    fromDestinationId?: true
    departureDate?: true
    returnDate?: true
    passengerCount?: true
    bookingClass?: true
    totalPrice?: true
    taxes?: true
    fees?: true
    discountAmount?: true
    finalPrice?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    bookingReference?: true
    userId?: true
    flightId?: true
    flightScheduleId?: true
    destinationId?: true
    fromDestinationId?: true
    departureDate?: true
    returnDate?: true
    passengerCount?: true
    bookingClass?: true
    totalPrice?: true
    taxes?: true
    fees?: true
    discountAmount?: true
    finalPrice?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    bookingReference?: true
    userId?: true
    flightId?: true
    flightScheduleId?: true
    destinationId?: true
    fromDestinationId?: true
    departureDate?: true
    returnDate?: true
    passengerCount?: true
    bookingClass?: true
    totalPrice?: true
    taxes?: true
    fees?: true
    discountAmount?: true
    finalPrice?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    bookingReference: string
    userId: string
    flightId: string | null
    flightScheduleId: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date
    returnDate: Date | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes: number
    fees: number
    discountAmount: number
    finalPrice: number
    status: string
    paymentStatus: string
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingReference?: boolean
    userId?: boolean
    flightId?: boolean
    flightScheduleId?: boolean
    destinationId?: boolean
    fromDestinationId?: boolean
    departureDate?: boolean
    returnDate?: boolean
    passengerCount?: boolean
    bookingClass?: boolean
    totalPrice?: boolean
    taxes?: boolean
    fees?: boolean
    discountAmount?: boolean
    finalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingReference?: boolean
    userId?: boolean
    flightId?: boolean
    flightScheduleId?: boolean
    destinationId?: boolean
    fromDestinationId?: boolean
    departureDate?: boolean
    returnDate?: boolean
    passengerCount?: boolean
    bookingClass?: boolean
    totalPrice?: boolean
    taxes?: boolean
    fees?: boolean
    discountAmount?: boolean
    finalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingReference?: boolean
    userId?: boolean
    flightId?: boolean
    flightScheduleId?: boolean
    destinationId?: boolean
    fromDestinationId?: boolean
    departureDate?: boolean
    returnDate?: boolean
    passengerCount?: boolean
    bookingClass?: boolean
    totalPrice?: boolean
    taxes?: boolean
    fees?: boolean
    discountAmount?: boolean
    finalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    bookingReference?: boolean
    userId?: boolean
    flightId?: boolean
    flightScheduleId?: boolean
    destinationId?: boolean
    fromDestinationId?: boolean
    departureDate?: boolean
    returnDate?: boolean
    passengerCount?: boolean
    bookingClass?: boolean
    totalPrice?: boolean
    taxes?: boolean
    fees?: boolean
    discountAmount?: boolean
    finalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingReference" | "userId" | "flightId" | "flightScheduleId" | "destinationId" | "fromDestinationId" | "departureDate" | "returnDate" | "passengerCount" | "bookingClass" | "totalPrice" | "taxes" | "fees" | "discountAmount" | "finalPrice" | "status" | "paymentStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | DestinationDefaultArgs<ExtArgs>
    flight?: boolean | Booking$flightArgs<ExtArgs>
    flightSchedule?: boolean | Booking$flightScheduleArgs<ExtArgs>
    fromDestination?: boolean | DestinationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs>
      flight: Prisma.$FlightPayload<ExtArgs> | null
      flightSchedule: Prisma.$FlightSchedulePayload<ExtArgs> | null
      fromDestination: Prisma.$DestinationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      passengers: Prisma.$PassengerDetailPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingReference: string
      userId: string
      flightId: string | null
      flightScheduleId: string | null
      destinationId: string
      fromDestinationId: string
      departureDate: Date
      returnDate: Date | null
      passengerCount: number
      bookingClass: string
      totalPrice: number
      taxes: number
      fees: number
      discountAmount: number
      finalPrice: number
      status: string
      paymentStatus: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flight<T extends Booking$flightArgs<ExtArgs> = {}>(args?: Subset<T, Booking$flightArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    flightSchedule<T extends Booking$flightScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Booking$flightScheduleArgs<ExtArgs>>): Prisma__FlightScheduleClient<$Result.GetResult<Prisma.$FlightSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fromDestination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Booking$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends Booking$passengersArgs<ExtArgs> = {}>(args?: Subset<T, Booking$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly bookingReference: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly flightId: FieldRef<"Booking", 'String'>
    readonly flightScheduleId: FieldRef<"Booking", 'String'>
    readonly destinationId: FieldRef<"Booking", 'String'>
    readonly fromDestinationId: FieldRef<"Booking", 'String'>
    readonly departureDate: FieldRef<"Booking", 'DateTime'>
    readonly returnDate: FieldRef<"Booking", 'DateTime'>
    readonly passengerCount: FieldRef<"Booking", 'Int'>
    readonly bookingClass: FieldRef<"Booking", 'String'>
    readonly totalPrice: FieldRef<"Booking", 'Float'>
    readonly taxes: FieldRef<"Booking", 'Float'>
    readonly fees: FieldRef<"Booking", 'Float'>
    readonly discountAmount: FieldRef<"Booking", 'Float'>
    readonly finalPrice: FieldRef<"Booking", 'Float'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly paymentStatus: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.flight
   */
  export type Booking$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flight
     */
    omit?: FlightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightInclude<ExtArgs> | null
    where?: FlightWhereInput
  }

  /**
   * Booking.flightSchedule
   */
  export type Booking$flightScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightSchedule
     */
    select?: FlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightSchedule
     */
    omit?: FlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightScheduleInclude<ExtArgs> | null
    where?: FlightScheduleWhereInput
  }

  /**
   * Booking.notifications
   */
  export type Booking$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Booking.passengers
   */
  export type Booking$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    where?: PassengerDetailWhereInput
    orderBy?: PassengerDetailOrderByWithRelationInput | PassengerDetailOrderByWithRelationInput[]
    cursor?: PassengerDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassengerDetailScalarFieldEnum | PassengerDetailScalarFieldEnum[]
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model PassengerDetail
   */

  export type AggregatePassengerDetail = {
    _count: PassengerDetailCountAggregateOutputType | null
    _min: PassengerDetailMinAggregateOutputType | null
    _max: PassengerDetailMaxAggregateOutputType | null
  }

  export type PassengerDetailMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    seatNumber: string | null
    mealPreference: string | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerDetailMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    seatNumber: string | null
    mealPreference: string | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerDetailCountAggregateOutputType = {
    id: number
    bookingId: number
    title: number
    firstName: number
    lastName: number
    dateOfBirth: number
    nationality: number
    passportNumber: number
    passportExpiry: number
    seatNumber: number
    mealPreference: number
    specialRequests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PassengerDetailMinAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    passportExpiry?: true
    seatNumber?: true
    mealPreference?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerDetailMaxAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    passportExpiry?: true
    seatNumber?: true
    mealPreference?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerDetailCountAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    passportNumber?: true
    passportExpiry?: true
    seatNumber?: true
    mealPreference?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PassengerDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassengerDetail to aggregate.
     */
    where?: PassengerDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerDetails to fetch.
     */
    orderBy?: PassengerDetailOrderByWithRelationInput | PassengerDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PassengerDetails
    **/
    _count?: true | PassengerDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerDetailMaxAggregateInputType
  }

  export type GetPassengerDetailAggregateType<T extends PassengerDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePassengerDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassengerDetail[P]>
      : GetScalarType<T[P], AggregatePassengerDetail[P]>
  }




  export type PassengerDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerDetailWhereInput
    orderBy?: PassengerDetailOrderByWithAggregationInput | PassengerDetailOrderByWithAggregationInput[]
    by: PassengerDetailScalarFieldEnum[] | PassengerDetailScalarFieldEnum
    having?: PassengerDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerDetailCountAggregateInputType | true
    _min?: PassengerDetailMinAggregateInputType
    _max?: PassengerDetailMaxAggregateInputType
  }

  export type PassengerDetailGroupByOutputType = {
    id: string
    bookingId: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date
    nationality: string
    passportNumber: string | null
    passportExpiry: Date | null
    seatNumber: string | null
    mealPreference: string | null
    specialRequests: string | null
    createdAt: Date
    updatedAt: Date
    _count: PassengerDetailCountAggregateOutputType | null
    _min: PassengerDetailMinAggregateOutputType | null
    _max: PassengerDetailMaxAggregateOutputType | null
  }

  type GetPassengerDetailGroupByPayload<T extends PassengerDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerDetailGroupByOutputType[P]>
        }
      >
    >


  export type PassengerDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    seatNumber?: boolean
    mealPreference?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerDetail"]>

  export type PassengerDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    seatNumber?: boolean
    mealPreference?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerDetail"]>

  export type PassengerDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    seatNumber?: boolean
    mealPreference?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerDetail"]>

  export type PassengerDetailSelectScalar = {
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    seatNumber?: boolean
    mealPreference?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PassengerDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "title" | "firstName" | "lastName" | "dateOfBirth" | "nationality" | "passportNumber" | "passportExpiry" | "seatNumber" | "mealPreference" | "specialRequests" | "createdAt" | "updatedAt", ExtArgs["result"]["passengerDetail"]>
  export type PassengerDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PassengerDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PassengerDetail"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      title: string
      firstName: string
      lastName: string
      dateOfBirth: Date
      nationality: string
      passportNumber: string | null
      passportExpiry: Date | null
      seatNumber: string | null
      mealPreference: string | null
      specialRequests: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passengerDetail"]>
    composites: {}
  }

  type PassengerDetailGetPayload<S extends boolean | null | undefined | PassengerDetailDefaultArgs> = $Result.GetResult<Prisma.$PassengerDetailPayload, S>

  type PassengerDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerDetailCountAggregateInputType | true
    }

  export interface PassengerDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PassengerDetail'], meta: { name: 'PassengerDetail' } }
    /**
     * Find zero or one PassengerDetail that matches the filter.
     * @param {PassengerDetailFindUniqueArgs} args - Arguments to find a PassengerDetail
     * @example
     * // Get one PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerDetailFindUniqueArgs>(args: SelectSubset<T, PassengerDetailFindUniqueArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PassengerDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerDetailFindUniqueOrThrowArgs} args - Arguments to find a PassengerDetail
     * @example
     * // Get one PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassengerDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailFindFirstArgs} args - Arguments to find a PassengerDetail
     * @example
     * // Get one PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerDetailFindFirstArgs>(args?: SelectSubset<T, PassengerDetailFindFirstArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassengerDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailFindFirstOrThrowArgs} args - Arguments to find a PassengerDetail
     * @example
     * // Get one PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PassengerDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PassengerDetails
     * const passengerDetails = await prisma.passengerDetail.findMany()
     * 
     * // Get first 10 PassengerDetails
     * const passengerDetails = await prisma.passengerDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerDetailWithIdOnly = await prisma.passengerDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerDetailFindManyArgs>(args?: SelectSubset<T, PassengerDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PassengerDetail.
     * @param {PassengerDetailCreateArgs} args - Arguments to create a PassengerDetail.
     * @example
     * // Create one PassengerDetail
     * const PassengerDetail = await prisma.passengerDetail.create({
     *   data: {
     *     // ... data to create a PassengerDetail
     *   }
     * })
     * 
     */
    create<T extends PassengerDetailCreateArgs>(args: SelectSubset<T, PassengerDetailCreateArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PassengerDetails.
     * @param {PassengerDetailCreateManyArgs} args - Arguments to create many PassengerDetails.
     * @example
     * // Create many PassengerDetails
     * const passengerDetail = await prisma.passengerDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerDetailCreateManyArgs>(args?: SelectSubset<T, PassengerDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PassengerDetails and returns the data saved in the database.
     * @param {PassengerDetailCreateManyAndReturnArgs} args - Arguments to create many PassengerDetails.
     * @example
     * // Create many PassengerDetails
     * const passengerDetail = await prisma.passengerDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PassengerDetails and only return the `id`
     * const passengerDetailWithIdOnly = await prisma.passengerDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PassengerDetail.
     * @param {PassengerDetailDeleteArgs} args - Arguments to delete one PassengerDetail.
     * @example
     * // Delete one PassengerDetail
     * const PassengerDetail = await prisma.passengerDetail.delete({
     *   where: {
     *     // ... filter to delete one PassengerDetail
     *   }
     * })
     * 
     */
    delete<T extends PassengerDetailDeleteArgs>(args: SelectSubset<T, PassengerDetailDeleteArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PassengerDetail.
     * @param {PassengerDetailUpdateArgs} args - Arguments to update one PassengerDetail.
     * @example
     * // Update one PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerDetailUpdateArgs>(args: SelectSubset<T, PassengerDetailUpdateArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PassengerDetails.
     * @param {PassengerDetailDeleteManyArgs} args - Arguments to filter PassengerDetails to delete.
     * @example
     * // Delete a few PassengerDetails
     * const { count } = await prisma.passengerDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDetailDeleteManyArgs>(args?: SelectSubset<T, PassengerDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassengerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PassengerDetails
     * const passengerDetail = await prisma.passengerDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerDetailUpdateManyArgs>(args: SelectSubset<T, PassengerDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassengerDetails and returns the data updated in the database.
     * @param {PassengerDetailUpdateManyAndReturnArgs} args - Arguments to update many PassengerDetails.
     * @example
     * // Update many PassengerDetails
     * const passengerDetail = await prisma.passengerDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PassengerDetails and only return the `id`
     * const passengerDetailWithIdOnly = await prisma.passengerDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PassengerDetail.
     * @param {PassengerDetailUpsertArgs} args - Arguments to update or create a PassengerDetail.
     * @example
     * // Update or create a PassengerDetail
     * const passengerDetail = await prisma.passengerDetail.upsert({
     *   create: {
     *     // ... data to create a PassengerDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PassengerDetail we want to update
     *   }
     * })
     */
    upsert<T extends PassengerDetailUpsertArgs>(args: SelectSubset<T, PassengerDetailUpsertArgs<ExtArgs>>): Prisma__PassengerDetailClient<$Result.GetResult<Prisma.$PassengerDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PassengerDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailCountArgs} args - Arguments to filter PassengerDetails to count.
     * @example
     * // Count the number of PassengerDetails
     * const count = await prisma.passengerDetail.count({
     *   where: {
     *     // ... the filter for the PassengerDetails we want to count
     *   }
     * })
    **/
    count<T extends PassengerDetailCountArgs>(
      args?: Subset<T, PassengerDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PassengerDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerDetailAggregateArgs>(args: Subset<T, PassengerDetailAggregateArgs>): Prisma.PrismaPromise<GetPassengerDetailAggregateType<T>>

    /**
     * Group by PassengerDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerDetailGroupByArgs['orderBy'] }
        : { orderBy?: PassengerDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PassengerDetail model
   */
  readonly fields: PassengerDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PassengerDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PassengerDetail model
   */
  interface PassengerDetailFieldRefs {
    readonly id: FieldRef<"PassengerDetail", 'String'>
    readonly bookingId: FieldRef<"PassengerDetail", 'String'>
    readonly title: FieldRef<"PassengerDetail", 'String'>
    readonly firstName: FieldRef<"PassengerDetail", 'String'>
    readonly lastName: FieldRef<"PassengerDetail", 'String'>
    readonly dateOfBirth: FieldRef<"PassengerDetail", 'DateTime'>
    readonly nationality: FieldRef<"PassengerDetail", 'String'>
    readonly passportNumber: FieldRef<"PassengerDetail", 'String'>
    readonly passportExpiry: FieldRef<"PassengerDetail", 'DateTime'>
    readonly seatNumber: FieldRef<"PassengerDetail", 'String'>
    readonly mealPreference: FieldRef<"PassengerDetail", 'String'>
    readonly specialRequests: FieldRef<"PassengerDetail", 'String'>
    readonly createdAt: FieldRef<"PassengerDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"PassengerDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PassengerDetail findUnique
   */
  export type PassengerDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter, which PassengerDetail to fetch.
     */
    where: PassengerDetailWhereUniqueInput
  }

  /**
   * PassengerDetail findUniqueOrThrow
   */
  export type PassengerDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter, which PassengerDetail to fetch.
     */
    where: PassengerDetailWhereUniqueInput
  }

  /**
   * PassengerDetail findFirst
   */
  export type PassengerDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter, which PassengerDetail to fetch.
     */
    where?: PassengerDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerDetails to fetch.
     */
    orderBy?: PassengerDetailOrderByWithRelationInput | PassengerDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassengerDetails.
     */
    cursor?: PassengerDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassengerDetails.
     */
    distinct?: PassengerDetailScalarFieldEnum | PassengerDetailScalarFieldEnum[]
  }

  /**
   * PassengerDetail findFirstOrThrow
   */
  export type PassengerDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter, which PassengerDetail to fetch.
     */
    where?: PassengerDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerDetails to fetch.
     */
    orderBy?: PassengerDetailOrderByWithRelationInput | PassengerDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassengerDetails.
     */
    cursor?: PassengerDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassengerDetails.
     */
    distinct?: PassengerDetailScalarFieldEnum | PassengerDetailScalarFieldEnum[]
  }

  /**
   * PassengerDetail findMany
   */
  export type PassengerDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter, which PassengerDetails to fetch.
     */
    where?: PassengerDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerDetails to fetch.
     */
    orderBy?: PassengerDetailOrderByWithRelationInput | PassengerDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PassengerDetails.
     */
    cursor?: PassengerDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerDetails.
     */
    skip?: number
    distinct?: PassengerDetailScalarFieldEnum | PassengerDetailScalarFieldEnum[]
  }

  /**
   * PassengerDetail create
   */
  export type PassengerDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a PassengerDetail.
     */
    data: XOR<PassengerDetailCreateInput, PassengerDetailUncheckedCreateInput>
  }

  /**
   * PassengerDetail createMany
   */
  export type PassengerDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PassengerDetails.
     */
    data: PassengerDetailCreateManyInput | PassengerDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PassengerDetail createManyAndReturn
   */
  export type PassengerDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * The data used to create many PassengerDetails.
     */
    data: PassengerDetailCreateManyInput | PassengerDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PassengerDetail update
   */
  export type PassengerDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a PassengerDetail.
     */
    data: XOR<PassengerDetailUpdateInput, PassengerDetailUncheckedUpdateInput>
    /**
     * Choose, which PassengerDetail to update.
     */
    where: PassengerDetailWhereUniqueInput
  }

  /**
   * PassengerDetail updateMany
   */
  export type PassengerDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PassengerDetails.
     */
    data: XOR<PassengerDetailUpdateManyMutationInput, PassengerDetailUncheckedUpdateManyInput>
    /**
     * Filter which PassengerDetails to update
     */
    where?: PassengerDetailWhereInput
    /**
     * Limit how many PassengerDetails to update.
     */
    limit?: number
  }

  /**
   * PassengerDetail updateManyAndReturn
   */
  export type PassengerDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * The data used to update PassengerDetails.
     */
    data: XOR<PassengerDetailUpdateManyMutationInput, PassengerDetailUncheckedUpdateManyInput>
    /**
     * Filter which PassengerDetails to update
     */
    where?: PassengerDetailWhereInput
    /**
     * Limit how many PassengerDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PassengerDetail upsert
   */
  export type PassengerDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the PassengerDetail to update in case it exists.
     */
    where: PassengerDetailWhereUniqueInput
    /**
     * In case the PassengerDetail found by the `where` argument doesn't exist, create a new PassengerDetail with this data.
     */
    create: XOR<PassengerDetailCreateInput, PassengerDetailUncheckedCreateInput>
    /**
     * In case the PassengerDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerDetailUpdateInput, PassengerDetailUncheckedUpdateInput>
  }

  /**
   * PassengerDetail delete
   */
  export type PassengerDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
    /**
     * Filter which PassengerDetail to delete.
     */
    where: PassengerDetailWhereUniqueInput
  }

  /**
   * PassengerDetail deleteMany
   */
  export type PassengerDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassengerDetails to delete
     */
    where?: PassengerDetailWhereInput
    /**
     * Limit how many PassengerDetails to delete.
     */
    limit?: number
  }

  /**
   * PassengerDetail without action
   */
  export type PassengerDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerDetail
     */
    select?: PassengerDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerDetail
     */
    omit?: PassengerDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerDetailInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentProvider: string | null
    transactionId: string | null
    status: string | null
    paidAt: Date | null
    failedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentProvider: string | null
    transactionId: string | null
    status: string | null
    paidAt: Date | null
    failedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    userId: number
    amount: number
    currency: number
    paymentMethod: number
    paymentProvider: number
    transactionId: number
    status: number
    paidAt: number
    failedReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentProvider?: true
    transactionId?: true
    status?: true
    paidAt?: true
    failedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentProvider?: true
    transactionId?: true
    status?: true
    paidAt?: true
    failedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentProvider?: true
    transactionId?: true
    status?: true
    paidAt?: true
    failedReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    userId: string
    amount: number
    currency: string
    paymentMethod: string
    paymentProvider: string | null
    transactionId: string | null
    status: string
    paidAt: Date | null
    failedReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentProvider?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    failedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentProvider?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    failedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentProvider?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    failedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentProvider?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    failedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "userId" | "amount" | "currency" | "paymentMethod" | "paymentProvider" | "transactionId" | "status" | "paidAt" | "failedReason" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      userId: string
      amount: number
      currency: string
      paymentMethod: string
      paymentProvider: string | null
      transactionId: string | null
      status: string
      paidAt: Date | null
      failedReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly paymentProvider: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly failedReason: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    destinationId: string | null
    bookingId: string | null
    rating: number | null
    title: string | null
    comment: string | null
    isVerified: boolean | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    destinationId: string | null
    bookingId: string | null
    rating: number | null
    title: string | null
    comment: string | null
    isVerified: boolean | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    destinationId: number
    bookingId: number
    rating: number
    title: number
    comment: number
    isVerified: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    bookingId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    bookingId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    destinationId?: true
    bookingId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    destinationId: string | null
    bookingId: string | null
    rating: number
    title: string | null
    comment: string | null
    isVerified: boolean
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    bookingId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    bookingId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    bookingId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    destinationId?: boolean
    bookingId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "destinationId" | "bookingId" | "rating" | "title" | "comment" | "isVerified" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Review$destinationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      destinationId: string | null
      bookingId: string | null
      rating: number
      title: string | null
      comment: string | null
      isVerified: boolean
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends Review$destinationArgs<ExtArgs> = {}>(args?: Subset<T, Review$destinationArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly destinationId: FieldRef<"Review", 'String'>
    readonly bookingId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly title: FieldRef<"Review", 'String'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isVerified: FieldRef<"Review", 'Boolean'>
    readonly isPublished: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.destination
   */
  export type Review$destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discountValue: number | null
    minPurchase: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromotionSumAggregateOutputType = {
    discountValue: number | null
    minPurchase: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    code: string | null
    discountType: string | null
    discountValue: number | null
    minPurchase: number | null
    maxDiscount: number | null
    startDate: Date | null
    endDate: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    destinationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    code: string | null
    discountType: string | null
    discountValue: number | null
    minPurchase: number | null
    maxDiscount: number | null
    startDate: Date | null
    endDate: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    destinationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    code: number
    discountType: number
    discountValue: number
    minPurchase: number
    maxDiscount: number
    startDate: number
    endDate: number
    usageLimit: number
    usedCount: number
    isActive: number
    destinationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discountValue?: true
    minPurchase?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromotionSumAggregateInputType = {
    discountValue?: true
    minPurchase?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    minPurchase?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    destinationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    minPurchase?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    destinationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    minPurchase?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    destinationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    code: string | null
    discountType: string
    discountValue: number
    minPurchase: number | null
    maxDiscount: number | null
    startDate: Date
    endDate: Date
    usageLimit: number | null
    usedCount: number
    isActive: boolean
    destinationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    minPurchase?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    destinationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    minPurchase?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    destinationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    minPurchase?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    destinationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    minPurchase?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    destinationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "code" | "discountType" | "discountValue" | "minPurchase" | "maxDiscount" | "startDate" | "endDate" | "usageLimit" | "usedCount" | "isActive" | "destinationId" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destination?: boolean | Promotion$destinationArgs<ExtArgs>
  }

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      destination: Prisma.$DestinationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      code: string | null
      discountType: string
      discountValue: number
      minPurchase: number | null
      maxDiscount: number | null
      startDate: Date
      endDate: Date
      usageLimit: number | null
      usedCount: number
      isActive: boolean
      destinationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destination<T extends Promotion$destinationArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$destinationArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly title: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'String'>
    readonly discountValue: FieldRef<"Promotion", 'Float'>
    readonly minPurchase: FieldRef<"Promotion", 'Float'>
    readonly maxDiscount: FieldRef<"Promotion", 'Float'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly usageLimit: FieldRef<"Promotion", 'Int'>
    readonly usedCount: FieldRef<"Promotion", 'Int'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly destinationId: FieldRef<"Promotion", 'String'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.destination
   */
  export type Promotion$destinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    where?: DestinationWhereInput
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookingId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookingId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    bookingId: number
    title: number
    message: number
    type: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    bookingId: string | null
    title: string
    message: string
    type: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookingId" | "title" | "message" | "type" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookingId: string | null
      title: string
      message: string
      type: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends Notification$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Notification$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly bookingId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.booking
   */
  export type Notification$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly category: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly isActive: FieldRef<"SystemConfig", 'Boolean'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model AdminFlightSchedule
   */

  export type AggregateAdminFlightSchedule = {
    _count: AdminFlightScheduleCountAggregateOutputType | null
    _avg: AdminFlightScheduleAvgAggregateOutputType | null
    _sum: AdminFlightScheduleSumAggregateOutputType | null
    _min: AdminFlightScheduleMinAggregateOutputType | null
    _max: AdminFlightScheduleMaxAggregateOutputType | null
  }

  export type AdminFlightScheduleAvgAggregateOutputType = {
    basePrice: number | null
    seats: number | null
  }

  export type AdminFlightScheduleSumAggregateOutputType = {
    basePrice: number | null
    seats: number | null
  }

  export type AdminFlightScheduleMinAggregateOutputType = {
    id: string | null
    airlineId: string | null
    flightNo: string | null
    origin: string | null
    destination: string | null
    departure: Date | null
    arrival: Date | null
    basePrice: number | null
    seats: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminFlightScheduleMaxAggregateOutputType = {
    id: string | null
    airlineId: string | null
    flightNo: string | null
    origin: string | null
    destination: string | null
    departure: Date | null
    arrival: Date | null
    basePrice: number | null
    seats: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminFlightScheduleCountAggregateOutputType = {
    id: number
    airlineId: number
    flightNo: number
    origin: number
    destination: number
    departure: number
    arrival: number
    basePrice: number
    seats: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminFlightScheduleAvgAggregateInputType = {
    basePrice?: true
    seats?: true
  }

  export type AdminFlightScheduleSumAggregateInputType = {
    basePrice?: true
    seats?: true
  }

  export type AdminFlightScheduleMinAggregateInputType = {
    id?: true
    airlineId?: true
    flightNo?: true
    origin?: true
    destination?: true
    departure?: true
    arrival?: true
    basePrice?: true
    seats?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminFlightScheduleMaxAggregateInputType = {
    id?: true
    airlineId?: true
    flightNo?: true
    origin?: true
    destination?: true
    departure?: true
    arrival?: true
    basePrice?: true
    seats?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminFlightScheduleCountAggregateInputType = {
    id?: true
    airlineId?: true
    flightNo?: true
    origin?: true
    destination?: true
    departure?: true
    arrival?: true
    basePrice?: true
    seats?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminFlightScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminFlightSchedule to aggregate.
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminFlightSchedules to fetch.
     */
    orderBy?: AdminFlightScheduleOrderByWithRelationInput | AdminFlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminFlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminFlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminFlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminFlightSchedules
    **/
    _count?: true | AdminFlightScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminFlightScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminFlightScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminFlightScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminFlightScheduleMaxAggregateInputType
  }

  export type GetAdminFlightScheduleAggregateType<T extends AdminFlightScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminFlightSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminFlightSchedule[P]>
      : GetScalarType<T[P], AggregateAdminFlightSchedule[P]>
  }




  export type AdminFlightScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminFlightScheduleWhereInput
    orderBy?: AdminFlightScheduleOrderByWithAggregationInput | AdminFlightScheduleOrderByWithAggregationInput[]
    by: AdminFlightScheduleScalarFieldEnum[] | AdminFlightScheduleScalarFieldEnum
    having?: AdminFlightScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminFlightScheduleCountAggregateInputType | true
    _avg?: AdminFlightScheduleAvgAggregateInputType
    _sum?: AdminFlightScheduleSumAggregateInputType
    _min?: AdminFlightScheduleMinAggregateInputType
    _max?: AdminFlightScheduleMaxAggregateInputType
  }

  export type AdminFlightScheduleGroupByOutputType = {
    id: string
    airlineId: string
    flightNo: string
    origin: string
    destination: string
    departure: Date
    arrival: Date
    basePrice: number
    seats: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdminFlightScheduleCountAggregateOutputType | null
    _avg: AdminFlightScheduleAvgAggregateOutputType | null
    _sum: AdminFlightScheduleSumAggregateOutputType | null
    _min: AdminFlightScheduleMinAggregateOutputType | null
    _max: AdminFlightScheduleMaxAggregateOutputType | null
  }

  type GetAdminFlightScheduleGroupByPayload<T extends AdminFlightScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminFlightScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminFlightScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminFlightScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], AdminFlightScheduleGroupByOutputType[P]>
        }
      >
    >


  export type AdminFlightScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    airlineId?: boolean
    flightNo?: boolean
    origin?: boolean
    destination?: boolean
    departure?: boolean
    arrival?: boolean
    basePrice?: boolean
    seats?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminFlightSchedule"]>

  export type AdminFlightScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    airlineId?: boolean
    flightNo?: boolean
    origin?: boolean
    destination?: boolean
    departure?: boolean
    arrival?: boolean
    basePrice?: boolean
    seats?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminFlightSchedule"]>

  export type AdminFlightScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    airlineId?: boolean
    flightNo?: boolean
    origin?: boolean
    destination?: boolean
    departure?: boolean
    arrival?: boolean
    basePrice?: boolean
    seats?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminFlightSchedule"]>

  export type AdminFlightScheduleSelectScalar = {
    id?: boolean
    airlineId?: boolean
    flightNo?: boolean
    origin?: boolean
    destination?: boolean
    departure?: boolean
    arrival?: boolean
    basePrice?: boolean
    seats?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminFlightScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "airlineId" | "flightNo" | "origin" | "destination" | "departure" | "arrival" | "basePrice" | "seats" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["adminFlightSchedule"]>
  export type AdminFlightScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }
  export type AdminFlightScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }
  export type AdminFlightScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | AirlineDefaultArgs<ExtArgs>
  }

  export type $AdminFlightSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminFlightSchedule"
    objects: {
      airline: Prisma.$AirlinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      airlineId: string
      flightNo: string
      origin: string
      destination: string
      departure: Date
      arrival: Date
      basePrice: number
      seats: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminFlightSchedule"]>
    composites: {}
  }

  type AdminFlightScheduleGetPayload<S extends boolean | null | undefined | AdminFlightScheduleDefaultArgs> = $Result.GetResult<Prisma.$AdminFlightSchedulePayload, S>

  type AdminFlightScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFlightScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminFlightScheduleCountAggregateInputType | true
    }

  export interface AdminFlightScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminFlightSchedule'], meta: { name: 'AdminFlightSchedule' } }
    /**
     * Find zero or one AdminFlightSchedule that matches the filter.
     * @param {AdminFlightScheduleFindUniqueArgs} args - Arguments to find a AdminFlightSchedule
     * @example
     * // Get one AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFlightScheduleFindUniqueArgs>(args: SelectSubset<T, AdminFlightScheduleFindUniqueArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminFlightSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFlightScheduleFindUniqueOrThrowArgs} args - Arguments to find a AdminFlightSchedule
     * @example
     * // Get one AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFlightScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFlightScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminFlightSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleFindFirstArgs} args - Arguments to find a AdminFlightSchedule
     * @example
     * // Get one AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFlightScheduleFindFirstArgs>(args?: SelectSubset<T, AdminFlightScheduleFindFirstArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminFlightSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleFindFirstOrThrowArgs} args - Arguments to find a AdminFlightSchedule
     * @example
     * // Get one AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFlightScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFlightScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminFlightSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminFlightSchedules
     * const adminFlightSchedules = await prisma.adminFlightSchedule.findMany()
     * 
     * // Get first 10 AdminFlightSchedules
     * const adminFlightSchedules = await prisma.adminFlightSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminFlightScheduleWithIdOnly = await prisma.adminFlightSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFlightScheduleFindManyArgs>(args?: SelectSubset<T, AdminFlightScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminFlightSchedule.
     * @param {AdminFlightScheduleCreateArgs} args - Arguments to create a AdminFlightSchedule.
     * @example
     * // Create one AdminFlightSchedule
     * const AdminFlightSchedule = await prisma.adminFlightSchedule.create({
     *   data: {
     *     // ... data to create a AdminFlightSchedule
     *   }
     * })
     * 
     */
    create<T extends AdminFlightScheduleCreateArgs>(args: SelectSubset<T, AdminFlightScheduleCreateArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminFlightSchedules.
     * @param {AdminFlightScheduleCreateManyArgs} args - Arguments to create many AdminFlightSchedules.
     * @example
     * // Create many AdminFlightSchedules
     * const adminFlightSchedule = await prisma.adminFlightSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminFlightScheduleCreateManyArgs>(args?: SelectSubset<T, AdminFlightScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminFlightSchedules and returns the data saved in the database.
     * @param {AdminFlightScheduleCreateManyAndReturnArgs} args - Arguments to create many AdminFlightSchedules.
     * @example
     * // Create many AdminFlightSchedules
     * const adminFlightSchedule = await prisma.adminFlightSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminFlightSchedules and only return the `id`
     * const adminFlightScheduleWithIdOnly = await prisma.adminFlightSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminFlightScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminFlightScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminFlightSchedule.
     * @param {AdminFlightScheduleDeleteArgs} args - Arguments to delete one AdminFlightSchedule.
     * @example
     * // Delete one AdminFlightSchedule
     * const AdminFlightSchedule = await prisma.adminFlightSchedule.delete({
     *   where: {
     *     // ... filter to delete one AdminFlightSchedule
     *   }
     * })
     * 
     */
    delete<T extends AdminFlightScheduleDeleteArgs>(args: SelectSubset<T, AdminFlightScheduleDeleteArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminFlightSchedule.
     * @param {AdminFlightScheduleUpdateArgs} args - Arguments to update one AdminFlightSchedule.
     * @example
     * // Update one AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminFlightScheduleUpdateArgs>(args: SelectSubset<T, AdminFlightScheduleUpdateArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminFlightSchedules.
     * @param {AdminFlightScheduleDeleteManyArgs} args - Arguments to filter AdminFlightSchedules to delete.
     * @example
     * // Delete a few AdminFlightSchedules
     * const { count } = await prisma.adminFlightSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminFlightScheduleDeleteManyArgs>(args?: SelectSubset<T, AdminFlightScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminFlightSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminFlightSchedules
     * const adminFlightSchedule = await prisma.adminFlightSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminFlightScheduleUpdateManyArgs>(args: SelectSubset<T, AdminFlightScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminFlightSchedules and returns the data updated in the database.
     * @param {AdminFlightScheduleUpdateManyAndReturnArgs} args - Arguments to update many AdminFlightSchedules.
     * @example
     * // Update many AdminFlightSchedules
     * const adminFlightSchedule = await prisma.adminFlightSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminFlightSchedules and only return the `id`
     * const adminFlightScheduleWithIdOnly = await prisma.adminFlightSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminFlightScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminFlightScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminFlightSchedule.
     * @param {AdminFlightScheduleUpsertArgs} args - Arguments to update or create a AdminFlightSchedule.
     * @example
     * // Update or create a AdminFlightSchedule
     * const adminFlightSchedule = await prisma.adminFlightSchedule.upsert({
     *   create: {
     *     // ... data to create a AdminFlightSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminFlightSchedule we want to update
     *   }
     * })
     */
    upsert<T extends AdminFlightScheduleUpsertArgs>(args: SelectSubset<T, AdminFlightScheduleUpsertArgs<ExtArgs>>): Prisma__AdminFlightScheduleClient<$Result.GetResult<Prisma.$AdminFlightSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminFlightSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleCountArgs} args - Arguments to filter AdminFlightSchedules to count.
     * @example
     * // Count the number of AdminFlightSchedules
     * const count = await prisma.adminFlightSchedule.count({
     *   where: {
     *     // ... the filter for the AdminFlightSchedules we want to count
     *   }
     * })
    **/
    count<T extends AdminFlightScheduleCountArgs>(
      args?: Subset<T, AdminFlightScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminFlightScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminFlightSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminFlightScheduleAggregateArgs>(args: Subset<T, AdminFlightScheduleAggregateArgs>): Prisma.PrismaPromise<GetAdminFlightScheduleAggregateType<T>>

    /**
     * Group by AdminFlightSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFlightScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminFlightScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminFlightScheduleGroupByArgs['orderBy'] }
        : { orderBy?: AdminFlightScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminFlightScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminFlightScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminFlightSchedule model
   */
  readonly fields: AdminFlightScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminFlightSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminFlightScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airline<T extends AirlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirlineDefaultArgs<ExtArgs>>): Prisma__AirlineClient<$Result.GetResult<Prisma.$AirlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminFlightSchedule model
   */
  interface AdminFlightScheduleFieldRefs {
    readonly id: FieldRef<"AdminFlightSchedule", 'String'>
    readonly airlineId: FieldRef<"AdminFlightSchedule", 'String'>
    readonly flightNo: FieldRef<"AdminFlightSchedule", 'String'>
    readonly origin: FieldRef<"AdminFlightSchedule", 'String'>
    readonly destination: FieldRef<"AdminFlightSchedule", 'String'>
    readonly departure: FieldRef<"AdminFlightSchedule", 'DateTime'>
    readonly arrival: FieldRef<"AdminFlightSchedule", 'DateTime'>
    readonly basePrice: FieldRef<"AdminFlightSchedule", 'Float'>
    readonly seats: FieldRef<"AdminFlightSchedule", 'Int'>
    readonly status: FieldRef<"AdminFlightSchedule", 'String'>
    readonly createdAt: FieldRef<"AdminFlightSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminFlightSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminFlightSchedule findUnique
   */
  export type AdminFlightScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AdminFlightSchedule to fetch.
     */
    where: AdminFlightScheduleWhereUniqueInput
  }

  /**
   * AdminFlightSchedule findUniqueOrThrow
   */
  export type AdminFlightScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AdminFlightSchedule to fetch.
     */
    where: AdminFlightScheduleWhereUniqueInput
  }

  /**
   * AdminFlightSchedule findFirst
   */
  export type AdminFlightScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AdminFlightSchedule to fetch.
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminFlightSchedules to fetch.
     */
    orderBy?: AdminFlightScheduleOrderByWithRelationInput | AdminFlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminFlightSchedules.
     */
    cursor?: AdminFlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminFlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminFlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminFlightSchedules.
     */
    distinct?: AdminFlightScheduleScalarFieldEnum | AdminFlightScheduleScalarFieldEnum[]
  }

  /**
   * AdminFlightSchedule findFirstOrThrow
   */
  export type AdminFlightScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AdminFlightSchedule to fetch.
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminFlightSchedules to fetch.
     */
    orderBy?: AdminFlightScheduleOrderByWithRelationInput | AdminFlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminFlightSchedules.
     */
    cursor?: AdminFlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminFlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminFlightSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminFlightSchedules.
     */
    distinct?: AdminFlightScheduleScalarFieldEnum | AdminFlightScheduleScalarFieldEnum[]
  }

  /**
   * AdminFlightSchedule findMany
   */
  export type AdminFlightScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AdminFlightSchedules to fetch.
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminFlightSchedules to fetch.
     */
    orderBy?: AdminFlightScheduleOrderByWithRelationInput | AdminFlightScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminFlightSchedules.
     */
    cursor?: AdminFlightScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminFlightSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminFlightSchedules.
     */
    skip?: number
    distinct?: AdminFlightScheduleScalarFieldEnum | AdminFlightScheduleScalarFieldEnum[]
  }

  /**
   * AdminFlightSchedule create
   */
  export type AdminFlightScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminFlightSchedule.
     */
    data: XOR<AdminFlightScheduleCreateInput, AdminFlightScheduleUncheckedCreateInput>
  }

  /**
   * AdminFlightSchedule createMany
   */
  export type AdminFlightScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminFlightSchedules.
     */
    data: AdminFlightScheduleCreateManyInput | AdminFlightScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminFlightSchedule createManyAndReturn
   */
  export type AdminFlightScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many AdminFlightSchedules.
     */
    data: AdminFlightScheduleCreateManyInput | AdminFlightScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminFlightSchedule update
   */
  export type AdminFlightScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminFlightSchedule.
     */
    data: XOR<AdminFlightScheduleUpdateInput, AdminFlightScheduleUncheckedUpdateInput>
    /**
     * Choose, which AdminFlightSchedule to update.
     */
    where: AdminFlightScheduleWhereUniqueInput
  }

  /**
   * AdminFlightSchedule updateMany
   */
  export type AdminFlightScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminFlightSchedules.
     */
    data: XOR<AdminFlightScheduleUpdateManyMutationInput, AdminFlightScheduleUncheckedUpdateManyInput>
    /**
     * Filter which AdminFlightSchedules to update
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * Limit how many AdminFlightSchedules to update.
     */
    limit?: number
  }

  /**
   * AdminFlightSchedule updateManyAndReturn
   */
  export type AdminFlightScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * The data used to update AdminFlightSchedules.
     */
    data: XOR<AdminFlightScheduleUpdateManyMutationInput, AdminFlightScheduleUncheckedUpdateManyInput>
    /**
     * Filter which AdminFlightSchedules to update
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * Limit how many AdminFlightSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminFlightSchedule upsert
   */
  export type AdminFlightScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminFlightSchedule to update in case it exists.
     */
    where: AdminFlightScheduleWhereUniqueInput
    /**
     * In case the AdminFlightSchedule found by the `where` argument doesn't exist, create a new AdminFlightSchedule with this data.
     */
    create: XOR<AdminFlightScheduleCreateInput, AdminFlightScheduleUncheckedCreateInput>
    /**
     * In case the AdminFlightSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminFlightScheduleUpdateInput, AdminFlightScheduleUncheckedUpdateInput>
  }

  /**
   * AdminFlightSchedule delete
   */
  export type AdminFlightScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
    /**
     * Filter which AdminFlightSchedule to delete.
     */
    where: AdminFlightScheduleWhereUniqueInput
  }

  /**
   * AdminFlightSchedule deleteMany
   */
  export type AdminFlightScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminFlightSchedules to delete
     */
    where?: AdminFlightScheduleWhereInput
    /**
     * Limit how many AdminFlightSchedules to delete.
     */
    limit?: number
  }

  /**
   * AdminFlightSchedule without action
   */
  export type AdminFlightScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminFlightSchedule
     */
    select?: AdminFlightScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminFlightSchedule
     */
    omit?: AdminFlightScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminFlightScheduleInclude<ExtArgs> | null
  }


  /**
   * Model AdminPromotion
   */

  export type AggregateAdminPromotion = {
    _count: AdminPromotionCountAggregateOutputType | null
    _avg: AdminPromotionAvgAggregateOutputType | null
    _sum: AdminPromotionSumAggregateOutputType | null
    _min: AdminPromotionMinAggregateOutputType | null
    _max: AdminPromotionMaxAggregateOutputType | null
  }

  export type AdminPromotionAvgAggregateOutputType = {
    discountPercent: number | null
  }

  export type AdminPromotionSumAggregateOutputType = {
    discountPercent: number | null
  }

  export type AdminPromotionMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    discountPercent: number | null
    startsAt: Date | null
    endsAt: Date | null
    conditions: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminPromotionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    discountPercent: number | null
    startsAt: Date | null
    endsAt: Date | null
    conditions: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminPromotionCountAggregateOutputType = {
    id: number
    title: number
    code: number
    discountPercent: number
    startsAt: number
    endsAt: number
    conditions: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminPromotionAvgAggregateInputType = {
    discountPercent?: true
  }

  export type AdminPromotionSumAggregateInputType = {
    discountPercent?: true
  }

  export type AdminPromotionMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    discountPercent?: true
    startsAt?: true
    endsAt?: true
    conditions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminPromotionMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    discountPercent?: true
    startsAt?: true
    endsAt?: true
    conditions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminPromotionCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    discountPercent?: true
    startsAt?: true
    endsAt?: true
    conditions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminPromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPromotion to aggregate.
     */
    where?: AdminPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPromotions to fetch.
     */
    orderBy?: AdminPromotionOrderByWithRelationInput | AdminPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPromotions
    **/
    _count?: true | AdminPromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminPromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminPromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPromotionMaxAggregateInputType
  }

  export type GetAdminPromotionAggregateType<T extends AdminPromotionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPromotion[P]>
      : GetScalarType<T[P], AggregateAdminPromotion[P]>
  }




  export type AdminPromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPromotionWhereInput
    orderBy?: AdminPromotionOrderByWithAggregationInput | AdminPromotionOrderByWithAggregationInput[]
    by: AdminPromotionScalarFieldEnum[] | AdminPromotionScalarFieldEnum
    having?: AdminPromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPromotionCountAggregateInputType | true
    _avg?: AdminPromotionAvgAggregateInputType
    _sum?: AdminPromotionSumAggregateInputType
    _min?: AdminPromotionMinAggregateInputType
    _max?: AdminPromotionMaxAggregateInputType
  }

  export type AdminPromotionGroupByOutputType = {
    id: string
    title: string
    code: string
    discountPercent: number
    startsAt: Date
    endsAt: Date
    conditions: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminPromotionCountAggregateOutputType | null
    _avg: AdminPromotionAvgAggregateOutputType | null
    _sum: AdminPromotionSumAggregateOutputType | null
    _min: AdminPromotionMinAggregateOutputType | null
    _max: AdminPromotionMaxAggregateOutputType | null
  }

  type GetAdminPromotionGroupByPayload<T extends AdminPromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPromotionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPromotionGroupByOutputType[P]>
        }
      >
    >


  export type AdminPromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    discountPercent?: boolean
    startsAt?: boolean
    endsAt?: boolean
    conditions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPromotion"]>

  export type AdminPromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    discountPercent?: boolean
    startsAt?: boolean
    endsAt?: boolean
    conditions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPromotion"]>

  export type AdminPromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    discountPercent?: boolean
    startsAt?: boolean
    endsAt?: boolean
    conditions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPromotion"]>

  export type AdminPromotionSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    discountPercent?: boolean
    startsAt?: boolean
    endsAt?: boolean
    conditions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminPromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "code" | "discountPercent" | "startsAt" | "endsAt" | "conditions" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["adminPromotion"]>

  export type $AdminPromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPromotion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      code: string
      discountPercent: number
      startsAt: Date
      endsAt: Date
      conditions: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminPromotion"]>
    composites: {}
  }

  type AdminPromotionGetPayload<S extends boolean | null | undefined | AdminPromotionDefaultArgs> = $Result.GetResult<Prisma.$AdminPromotionPayload, S>

  type AdminPromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPromotionCountAggregateInputType | true
    }

  export interface AdminPromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPromotion'], meta: { name: 'AdminPromotion' } }
    /**
     * Find zero or one AdminPromotion that matches the filter.
     * @param {AdminPromotionFindUniqueArgs} args - Arguments to find a AdminPromotion
     * @example
     * // Get one AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPromotionFindUniqueArgs>(args: SelectSubset<T, AdminPromotionFindUniqueArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPromotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPromotionFindUniqueOrThrowArgs} args - Arguments to find a AdminPromotion
     * @example
     * // Get one AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionFindFirstArgs} args - Arguments to find a AdminPromotion
     * @example
     * // Get one AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPromotionFindFirstArgs>(args?: SelectSubset<T, AdminPromotionFindFirstArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionFindFirstOrThrowArgs} args - Arguments to find a AdminPromotion
     * @example
     * // Get one AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPromotions
     * const adminPromotions = await prisma.adminPromotion.findMany()
     * 
     * // Get first 10 AdminPromotions
     * const adminPromotions = await prisma.adminPromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPromotionWithIdOnly = await prisma.adminPromotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPromotionFindManyArgs>(args?: SelectSubset<T, AdminPromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPromotion.
     * @param {AdminPromotionCreateArgs} args - Arguments to create a AdminPromotion.
     * @example
     * // Create one AdminPromotion
     * const AdminPromotion = await prisma.adminPromotion.create({
     *   data: {
     *     // ... data to create a AdminPromotion
     *   }
     * })
     * 
     */
    create<T extends AdminPromotionCreateArgs>(args: SelectSubset<T, AdminPromotionCreateArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPromotions.
     * @param {AdminPromotionCreateManyArgs} args - Arguments to create many AdminPromotions.
     * @example
     * // Create many AdminPromotions
     * const adminPromotion = await prisma.adminPromotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPromotionCreateManyArgs>(args?: SelectSubset<T, AdminPromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPromotions and returns the data saved in the database.
     * @param {AdminPromotionCreateManyAndReturnArgs} args - Arguments to create many AdminPromotions.
     * @example
     * // Create many AdminPromotions
     * const adminPromotion = await prisma.adminPromotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPromotions and only return the `id`
     * const adminPromotionWithIdOnly = await prisma.adminPromotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPromotion.
     * @param {AdminPromotionDeleteArgs} args - Arguments to delete one AdminPromotion.
     * @example
     * // Delete one AdminPromotion
     * const AdminPromotion = await prisma.adminPromotion.delete({
     *   where: {
     *     // ... filter to delete one AdminPromotion
     *   }
     * })
     * 
     */
    delete<T extends AdminPromotionDeleteArgs>(args: SelectSubset<T, AdminPromotionDeleteArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPromotion.
     * @param {AdminPromotionUpdateArgs} args - Arguments to update one AdminPromotion.
     * @example
     * // Update one AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPromotionUpdateArgs>(args: SelectSubset<T, AdminPromotionUpdateArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPromotions.
     * @param {AdminPromotionDeleteManyArgs} args - Arguments to filter AdminPromotions to delete.
     * @example
     * // Delete a few AdminPromotions
     * const { count } = await prisma.adminPromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPromotionDeleteManyArgs>(args?: SelectSubset<T, AdminPromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPromotions
     * const adminPromotion = await prisma.adminPromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPromotionUpdateManyArgs>(args: SelectSubset<T, AdminPromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPromotions and returns the data updated in the database.
     * @param {AdminPromotionUpdateManyAndReturnArgs} args - Arguments to update many AdminPromotions.
     * @example
     * // Update many AdminPromotions
     * const adminPromotion = await prisma.adminPromotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPromotions and only return the `id`
     * const adminPromotionWithIdOnly = await prisma.adminPromotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPromotion.
     * @param {AdminPromotionUpsertArgs} args - Arguments to update or create a AdminPromotion.
     * @example
     * // Update or create a AdminPromotion
     * const adminPromotion = await prisma.adminPromotion.upsert({
     *   create: {
     *     // ... data to create a AdminPromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPromotion we want to update
     *   }
     * })
     */
    upsert<T extends AdminPromotionUpsertArgs>(args: SelectSubset<T, AdminPromotionUpsertArgs<ExtArgs>>): Prisma__AdminPromotionClient<$Result.GetResult<Prisma.$AdminPromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionCountArgs} args - Arguments to filter AdminPromotions to count.
     * @example
     * // Count the number of AdminPromotions
     * const count = await prisma.adminPromotion.count({
     *   where: {
     *     // ... the filter for the AdminPromotions we want to count
     *   }
     * })
    **/
    count<T extends AdminPromotionCountArgs>(
      args?: Subset<T, AdminPromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPromotionAggregateArgs>(args: Subset<T, AdminPromotionAggregateArgs>): Prisma.PrismaPromise<GetAdminPromotionAggregateType<T>>

    /**
     * Group by AdminPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPromotionGroupByArgs['orderBy'] }
        : { orderBy?: AdminPromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPromotion model
   */
  readonly fields: AdminPromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPromotion model
   */
  interface AdminPromotionFieldRefs {
    readonly id: FieldRef<"AdminPromotion", 'String'>
    readonly title: FieldRef<"AdminPromotion", 'String'>
    readonly code: FieldRef<"AdminPromotion", 'String'>
    readonly discountPercent: FieldRef<"AdminPromotion", 'Int'>
    readonly startsAt: FieldRef<"AdminPromotion", 'DateTime'>
    readonly endsAt: FieldRef<"AdminPromotion", 'DateTime'>
    readonly conditions: FieldRef<"AdminPromotion", 'String'>
    readonly active: FieldRef<"AdminPromotion", 'Boolean'>
    readonly createdAt: FieldRef<"AdminPromotion", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminPromotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminPromotion findUnique
   */
  export type AdminPromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter, which AdminPromotion to fetch.
     */
    where: AdminPromotionWhereUniqueInput
  }

  /**
   * AdminPromotion findUniqueOrThrow
   */
  export type AdminPromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter, which AdminPromotion to fetch.
     */
    where: AdminPromotionWhereUniqueInput
  }

  /**
   * AdminPromotion findFirst
   */
  export type AdminPromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter, which AdminPromotion to fetch.
     */
    where?: AdminPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPromotions to fetch.
     */
    orderBy?: AdminPromotionOrderByWithRelationInput | AdminPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPromotions.
     */
    cursor?: AdminPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPromotions.
     */
    distinct?: AdminPromotionScalarFieldEnum | AdminPromotionScalarFieldEnum[]
  }

  /**
   * AdminPromotion findFirstOrThrow
   */
  export type AdminPromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter, which AdminPromotion to fetch.
     */
    where?: AdminPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPromotions to fetch.
     */
    orderBy?: AdminPromotionOrderByWithRelationInput | AdminPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPromotions.
     */
    cursor?: AdminPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPromotions.
     */
    distinct?: AdminPromotionScalarFieldEnum | AdminPromotionScalarFieldEnum[]
  }

  /**
   * AdminPromotion findMany
   */
  export type AdminPromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter, which AdminPromotions to fetch.
     */
    where?: AdminPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPromotions to fetch.
     */
    orderBy?: AdminPromotionOrderByWithRelationInput | AdminPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPromotions.
     */
    cursor?: AdminPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPromotions.
     */
    skip?: number
    distinct?: AdminPromotionScalarFieldEnum | AdminPromotionScalarFieldEnum[]
  }

  /**
   * AdminPromotion create
   */
  export type AdminPromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminPromotion.
     */
    data: XOR<AdminPromotionCreateInput, AdminPromotionUncheckedCreateInput>
  }

  /**
   * AdminPromotion createMany
   */
  export type AdminPromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPromotions.
     */
    data: AdminPromotionCreateManyInput | AdminPromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPromotion createManyAndReturn
   */
  export type AdminPromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPromotions.
     */
    data: AdminPromotionCreateManyInput | AdminPromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPromotion update
   */
  export type AdminPromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminPromotion.
     */
    data: XOR<AdminPromotionUpdateInput, AdminPromotionUncheckedUpdateInput>
    /**
     * Choose, which AdminPromotion to update.
     */
    where: AdminPromotionWhereUniqueInput
  }

  /**
   * AdminPromotion updateMany
   */
  export type AdminPromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPromotions.
     */
    data: XOR<AdminPromotionUpdateManyMutationInput, AdminPromotionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPromotions to update
     */
    where?: AdminPromotionWhereInput
    /**
     * Limit how many AdminPromotions to update.
     */
    limit?: number
  }

  /**
   * AdminPromotion updateManyAndReturn
   */
  export type AdminPromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * The data used to update AdminPromotions.
     */
    data: XOR<AdminPromotionUpdateManyMutationInput, AdminPromotionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPromotions to update
     */
    where?: AdminPromotionWhereInput
    /**
     * Limit how many AdminPromotions to update.
     */
    limit?: number
  }

  /**
   * AdminPromotion upsert
   */
  export type AdminPromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminPromotion to update in case it exists.
     */
    where: AdminPromotionWhereUniqueInput
    /**
     * In case the AdminPromotion found by the `where` argument doesn't exist, create a new AdminPromotion with this data.
     */
    create: XOR<AdminPromotionCreateInput, AdminPromotionUncheckedCreateInput>
    /**
     * In case the AdminPromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPromotionUpdateInput, AdminPromotionUncheckedUpdateInput>
  }

  /**
   * AdminPromotion delete
   */
  export type AdminPromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
    /**
     * Filter which AdminPromotion to delete.
     */
    where: AdminPromotionWhereUniqueInput
  }

  /**
   * AdminPromotion deleteMany
   */
  export type AdminPromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPromotions to delete
     */
    where?: AdminPromotionWhereInput
    /**
     * Limit how many AdminPromotions to delete.
     */
    limit?: number
  }

  /**
   * AdminPromotion without action
   */
  export type AdminPromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPromotion
     */
    select?: AdminPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPromotion
     */
    omit?: AdminPromotionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    passportNumber: 'passportNumber',
    role: 'role',
    isActive: 'isActive',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    continent: 'continent',
    currency: 'currency',
    timezone: 'timezone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId',
    state: 'state',
    population: 'population',
    timezone: 'timezone',
    lat: 'lat',
    lon: 'lon',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const AirportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iataCode: 'iataCode',
    icaoCode: 'icaoCode',
    cityId: 'cityId',
    countryId: 'countryId',
    municipality: 'municipality',
    lat: 'lat',
    lon: 'lon',
    elevation: 'elevation',
    timezone: 'timezone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AirportScalarFieldEnum = (typeof AirportScalarFieldEnum)[keyof typeof AirportScalarFieldEnum]


  export const AirlineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    icaoCode: 'icaoCode',
    countryId: 'countryId',
    logo: 'logo',
    description: 'description',
    website: 'website',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AirlineScalarFieldEnum = (typeof AirlineScalarFieldEnum)[keyof typeof AirlineScalarFieldEnum]


  export const AircraftTypeScalarFieldEnum: {
    id: 'id',
    manufacturer: 'manufacturer',
    model: 'model',
    variant: 'variant',
    capacity: 'capacity',
    range: 'range',
    cruiseSpeed: 'cruiseSpeed',
    fuelCapacity: 'fuelCapacity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AircraftTypeScalarFieldEnum = (typeof AircraftTypeScalarFieldEnum)[keyof typeof AircraftTypeScalarFieldEnum]


  export const AircraftScalarFieldEnum: {
    id: 'id',
    registration: 'registration',
    airlineId: 'airlineId',
    aircraftTypeId: 'aircraftTypeId',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AircraftScalarFieldEnum = (typeof AircraftScalarFieldEnum)[keyof typeof AircraftScalarFieldEnum]


  export const DestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cityId: 'cityId',
    countryId: 'countryId',
    airportId: 'airportId',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    rating: 'rating',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DestinationScalarFieldEnum = (typeof DestinationScalarFieldEnum)[keyof typeof DestinationScalarFieldEnum]


  export const FlightScalarFieldEnum: {
    id: 'id',
    flightNumber: 'flightNumber',
    airlineId: 'airlineId',
    aircraftId: 'aircraftId',
    departureAirportId: 'departureAirportId',
    arrivalAirportId: 'arrivalAirportId',
    departureTime: 'departureTime',
    arrivalTime: 'arrivalTime',
    duration: 'duration',
    distance: 'distance',
    status: 'status',
    gate: 'gate',
    terminal: 'terminal',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlightScalarFieldEnum = (typeof FlightScalarFieldEnum)[keyof typeof FlightScalarFieldEnum]


  export const FlightScheduleScalarFieldEnum: {
    id: 'id',
    flightId: 'flightId',
    classType: 'classType',
    availableSeats: 'availableSeats',
    totalSeats: 'totalSeats',
    basePrice: 'basePrice',
    currentPrice: 'currentPrice',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlightScheduleScalarFieldEnum = (typeof FlightScheduleScalarFieldEnum)[keyof typeof FlightScheduleScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    bookingReference: 'bookingReference',
    userId: 'userId',
    flightId: 'flightId',
    flightScheduleId: 'flightScheduleId',
    destinationId: 'destinationId',
    fromDestinationId: 'fromDestinationId',
    departureDate: 'departureDate',
    returnDate: 'returnDate',
    passengerCount: 'passengerCount',
    bookingClass: 'bookingClass',
    totalPrice: 'totalPrice',
    taxes: 'taxes',
    fees: 'fees',
    discountAmount: 'discountAmount',
    finalPrice: 'finalPrice',
    status: 'status',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PassengerDetailScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    passportNumber: 'passportNumber',
    passportExpiry: 'passportExpiry',
    seatNumber: 'seatNumber',
    mealPreference: 'mealPreference',
    specialRequests: 'specialRequests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PassengerDetailScalarFieldEnum = (typeof PassengerDetailScalarFieldEnum)[keyof typeof PassengerDetailScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentProvider: 'paymentProvider',
    transactionId: 'transactionId',
    status: 'status',
    paidAt: 'paidAt',
    failedReason: 'failedReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    destinationId: 'destinationId',
    bookingId: 'bookingId',
    rating: 'rating',
    title: 'title',
    comment: 'comment',
    isVerified: 'isVerified',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    code: 'code',
    discountType: 'discountType',
    discountValue: 'discountValue',
    minPurchase: 'minPurchase',
    maxDiscount: 'maxDiscount',
    startDate: 'startDate',
    endDate: 'endDate',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    isActive: 'isActive',
    destinationId: 'destinationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookingId: 'bookingId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const AdminFlightScheduleScalarFieldEnum: {
    id: 'id',
    airlineId: 'airlineId',
    flightNo: 'flightNo',
    origin: 'origin',
    destination: 'destination',
    departure: 'departure',
    arrival: 'arrival',
    basePrice: 'basePrice',
    seats: 'seats',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminFlightScheduleScalarFieldEnum = (typeof AdminFlightScheduleScalarFieldEnum)[keyof typeof AdminFlightScheduleScalarFieldEnum]


  export const AdminPromotionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    discountPercent: 'discountPercent',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    conditions: 'conditions',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminPromotionScalarFieldEnum = (typeof AdminPromotionScalarFieldEnum)[keyof typeof AdminPromotionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    nationality?: StringNullableFilter<"User"> | string | null
    passportNumber?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookings?: BookingListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    nationality?: StringNullableFilter<"User"> | string | null
    passportNumber?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookings?: BookingListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"User"> | string | null
    passportNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    code?: StringFilter<"Country"> | string
    continent?: StringFilter<"Country"> | string
    currency?: StringFilter<"Country"> | string
    timezone?: StringFilter<"Country"> | string
    isActive?: BoolFilter<"Country"> | boolean
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    airlines?: AirlineListRelationFilter
    airports?: AirportListRelationFilter
    cities?: CityListRelationFilter
    destinations?: DestinationListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    airlines?: AirlineOrderByRelationAggregateInput
    airports?: AirportOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    destinations?: DestinationOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    continent?: StringFilter<"Country"> | string
    currency?: StringFilter<"Country"> | string
    timezone?: StringFilter<"Country"> | string
    isActive?: BoolFilter<"Country"> | boolean
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    airlines?: AirlineListRelationFilter
    airports?: AirportListRelationFilter
    cities?: CityListRelationFilter
    destinations?: DestinationListRelationFilter
  }, "id" | "name" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    code?: StringWithAggregatesFilter<"Country"> | string
    continent?: StringWithAggregatesFilter<"Country"> | string
    currency?: StringWithAggregatesFilter<"Country"> | string
    timezone?: StringWithAggregatesFilter<"Country"> | string
    isActive?: BoolWithAggregatesFilter<"Country"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    state?: StringNullableFilter<"City"> | string | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    lat?: FloatNullableFilter<"City"> | number | null
    lon?: FloatNullableFilter<"City"> | number | null
    isActive?: BoolFilter<"City"> | boolean
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    airports?: AirportListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    destinations?: DestinationListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    state?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    airports?: AirportOrderByRelationAggregateInput
    country?: CountryOrderByWithRelationInput
    destinations?: DestinationOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    state?: StringNullableFilter<"City"> | string | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    lat?: FloatNullableFilter<"City"> | number | null
    lon?: FloatNullableFilter<"City"> | number | null
    isActive?: BoolFilter<"City"> | boolean
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    airports?: AirportListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    destinations?: DestinationListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    state?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    countryId?: StringWithAggregatesFilter<"City"> | string
    state?: StringNullableWithAggregatesFilter<"City"> | string | null
    population?: IntNullableWithAggregatesFilter<"City"> | number | null
    timezone?: StringNullableWithAggregatesFilter<"City"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"City"> | number | null
    lon?: FloatNullableWithAggregatesFilter<"City"> | number | null
    isActive?: BoolWithAggregatesFilter<"City"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type AirportWhereInput = {
    AND?: AirportWhereInput | AirportWhereInput[]
    OR?: AirportWhereInput[]
    NOT?: AirportWhereInput | AirportWhereInput[]
    id?: StringFilter<"Airport"> | string
    name?: StringFilter<"Airport"> | string
    iataCode?: StringNullableFilter<"Airport"> | string | null
    icaoCode?: StringNullableFilter<"Airport"> | string | null
    cityId?: StringFilter<"Airport"> | string
    countryId?: StringFilter<"Airport"> | string
    municipality?: StringNullableFilter<"Airport"> | string | null
    lat?: FloatNullableFilter<"Airport"> | number | null
    lon?: FloatNullableFilter<"Airport"> | number | null
    elevation?: IntNullableFilter<"Airport"> | number | null
    timezone?: StringNullableFilter<"Airport"> | string | null
    isActive?: BoolFilter<"Airport"> | boolean
    createdAt?: DateTimeFilter<"Airport"> | Date | string
    updatedAt?: DateTimeFilter<"Airport"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    destinations?: DestinationListRelationFilter
    arrivalFlights?: FlightListRelationFilter
    departureFlights?: FlightListRelationFilter
  }

  export type AirportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iataCode?: SortOrderInput | SortOrder
    icaoCode?: SortOrderInput | SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    municipality?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    destinations?: DestinationOrderByRelationAggregateInput
    arrivalFlights?: FlightOrderByRelationAggregateInput
    departureFlights?: FlightOrderByRelationAggregateInput
  }

  export type AirportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    iataCode?: string
    icaoCode?: string
    AND?: AirportWhereInput | AirportWhereInput[]
    OR?: AirportWhereInput[]
    NOT?: AirportWhereInput | AirportWhereInput[]
    name?: StringFilter<"Airport"> | string
    cityId?: StringFilter<"Airport"> | string
    countryId?: StringFilter<"Airport"> | string
    municipality?: StringNullableFilter<"Airport"> | string | null
    lat?: FloatNullableFilter<"Airport"> | number | null
    lon?: FloatNullableFilter<"Airport"> | number | null
    elevation?: IntNullableFilter<"Airport"> | number | null
    timezone?: StringNullableFilter<"Airport"> | string | null
    isActive?: BoolFilter<"Airport"> | boolean
    createdAt?: DateTimeFilter<"Airport"> | Date | string
    updatedAt?: DateTimeFilter<"Airport"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    destinations?: DestinationListRelationFilter
    arrivalFlights?: FlightListRelationFilter
    departureFlights?: FlightListRelationFilter
  }, "id" | "iataCode" | "icaoCode">

  export type AirportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iataCode?: SortOrderInput | SortOrder
    icaoCode?: SortOrderInput | SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    municipality?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    elevation?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AirportCountOrderByAggregateInput
    _avg?: AirportAvgOrderByAggregateInput
    _max?: AirportMaxOrderByAggregateInput
    _min?: AirportMinOrderByAggregateInput
    _sum?: AirportSumOrderByAggregateInput
  }

  export type AirportScalarWhereWithAggregatesInput = {
    AND?: AirportScalarWhereWithAggregatesInput | AirportScalarWhereWithAggregatesInput[]
    OR?: AirportScalarWhereWithAggregatesInput[]
    NOT?: AirportScalarWhereWithAggregatesInput | AirportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Airport"> | string
    name?: StringWithAggregatesFilter<"Airport"> | string
    iataCode?: StringNullableWithAggregatesFilter<"Airport"> | string | null
    icaoCode?: StringNullableWithAggregatesFilter<"Airport"> | string | null
    cityId?: StringWithAggregatesFilter<"Airport"> | string
    countryId?: StringWithAggregatesFilter<"Airport"> | string
    municipality?: StringNullableWithAggregatesFilter<"Airport"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"Airport"> | number | null
    lon?: FloatNullableWithAggregatesFilter<"Airport"> | number | null
    elevation?: IntNullableWithAggregatesFilter<"Airport"> | number | null
    timezone?: StringNullableWithAggregatesFilter<"Airport"> | string | null
    isActive?: BoolWithAggregatesFilter<"Airport"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Airport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Airport"> | Date | string
  }

  export type AirlineWhereInput = {
    AND?: AirlineWhereInput | AirlineWhereInput[]
    OR?: AirlineWhereInput[]
    NOT?: AirlineWhereInput | AirlineWhereInput[]
    id?: StringFilter<"Airline"> | string
    name?: StringFilter<"Airline"> | string
    code?: StringFilter<"Airline"> | string
    icaoCode?: StringNullableFilter<"Airline"> | string | null
    countryId?: StringFilter<"Airline"> | string
    logo?: StringNullableFilter<"Airline"> | string | null
    description?: StringNullableFilter<"Airline"> | string | null
    website?: StringNullableFilter<"Airline"> | string | null
    isActive?: BoolFilter<"Airline"> | boolean
    createdAt?: DateTimeFilter<"Airline"> | Date | string
    updatedAt?: DateTimeFilter<"Airline"> | Date | string
    aircraft?: AircraftListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    flights?: FlightListRelationFilter
    adminFlightSchedules?: AdminFlightScheduleListRelationFilter
  }

  export type AirlineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icaoCode?: SortOrderInput | SortOrder
    countryId?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aircraft?: AircraftOrderByRelationAggregateInput
    country?: CountryOrderByWithRelationInput
    flights?: FlightOrderByRelationAggregateInput
    adminFlightSchedules?: AdminFlightScheduleOrderByRelationAggregateInput
  }

  export type AirlineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    icaoCode?: string
    AND?: AirlineWhereInput | AirlineWhereInput[]
    OR?: AirlineWhereInput[]
    NOT?: AirlineWhereInput | AirlineWhereInput[]
    name?: StringFilter<"Airline"> | string
    countryId?: StringFilter<"Airline"> | string
    logo?: StringNullableFilter<"Airline"> | string | null
    description?: StringNullableFilter<"Airline"> | string | null
    website?: StringNullableFilter<"Airline"> | string | null
    isActive?: BoolFilter<"Airline"> | boolean
    createdAt?: DateTimeFilter<"Airline"> | Date | string
    updatedAt?: DateTimeFilter<"Airline"> | Date | string
    aircraft?: AircraftListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    flights?: FlightListRelationFilter
    adminFlightSchedules?: AdminFlightScheduleListRelationFilter
  }, "id" | "code" | "icaoCode">

  export type AirlineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icaoCode?: SortOrderInput | SortOrder
    countryId?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AirlineCountOrderByAggregateInput
    _max?: AirlineMaxOrderByAggregateInput
    _min?: AirlineMinOrderByAggregateInput
  }

  export type AirlineScalarWhereWithAggregatesInput = {
    AND?: AirlineScalarWhereWithAggregatesInput | AirlineScalarWhereWithAggregatesInput[]
    OR?: AirlineScalarWhereWithAggregatesInput[]
    NOT?: AirlineScalarWhereWithAggregatesInput | AirlineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Airline"> | string
    name?: StringWithAggregatesFilter<"Airline"> | string
    code?: StringWithAggregatesFilter<"Airline"> | string
    icaoCode?: StringNullableWithAggregatesFilter<"Airline"> | string | null
    countryId?: StringWithAggregatesFilter<"Airline"> | string
    logo?: StringNullableWithAggregatesFilter<"Airline"> | string | null
    description?: StringNullableWithAggregatesFilter<"Airline"> | string | null
    website?: StringNullableWithAggregatesFilter<"Airline"> | string | null
    isActive?: BoolWithAggregatesFilter<"Airline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Airline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Airline"> | Date | string
  }

  export type AircraftTypeWhereInput = {
    AND?: AircraftTypeWhereInput | AircraftTypeWhereInput[]
    OR?: AircraftTypeWhereInput[]
    NOT?: AircraftTypeWhereInput | AircraftTypeWhereInput[]
    id?: StringFilter<"AircraftType"> | string
    manufacturer?: StringFilter<"AircraftType"> | string
    model?: StringFilter<"AircraftType"> | string
    variant?: StringNullableFilter<"AircraftType"> | string | null
    capacity?: IntFilter<"AircraftType"> | number
    range?: IntNullableFilter<"AircraftType"> | number | null
    cruiseSpeed?: IntNullableFilter<"AircraftType"> | number | null
    fuelCapacity?: IntNullableFilter<"AircraftType"> | number | null
    isActive?: BoolFilter<"AircraftType"> | boolean
    createdAt?: DateTimeFilter<"AircraftType"> | Date | string
    updatedAt?: DateTimeFilter<"AircraftType"> | Date | string
    aircraft?: AircraftListRelationFilter
  }

  export type AircraftTypeOrderByWithRelationInput = {
    id?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    variant?: SortOrderInput | SortOrder
    capacity?: SortOrder
    range?: SortOrderInput | SortOrder
    cruiseSpeed?: SortOrderInput | SortOrder
    fuelCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aircraft?: AircraftOrderByRelationAggregateInput
  }

  export type AircraftTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    manufacturer_model_variant?: AircraftTypeManufacturerModelVariantCompoundUniqueInput
    AND?: AircraftTypeWhereInput | AircraftTypeWhereInput[]
    OR?: AircraftTypeWhereInput[]
    NOT?: AircraftTypeWhereInput | AircraftTypeWhereInput[]
    manufacturer?: StringFilter<"AircraftType"> | string
    model?: StringFilter<"AircraftType"> | string
    variant?: StringNullableFilter<"AircraftType"> | string | null
    capacity?: IntFilter<"AircraftType"> | number
    range?: IntNullableFilter<"AircraftType"> | number | null
    cruiseSpeed?: IntNullableFilter<"AircraftType"> | number | null
    fuelCapacity?: IntNullableFilter<"AircraftType"> | number | null
    isActive?: BoolFilter<"AircraftType"> | boolean
    createdAt?: DateTimeFilter<"AircraftType"> | Date | string
    updatedAt?: DateTimeFilter<"AircraftType"> | Date | string
    aircraft?: AircraftListRelationFilter
  }, "id" | "manufacturer_model_variant">

  export type AircraftTypeOrderByWithAggregationInput = {
    id?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    variant?: SortOrderInput | SortOrder
    capacity?: SortOrder
    range?: SortOrderInput | SortOrder
    cruiseSpeed?: SortOrderInput | SortOrder
    fuelCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AircraftTypeCountOrderByAggregateInput
    _avg?: AircraftTypeAvgOrderByAggregateInput
    _max?: AircraftTypeMaxOrderByAggregateInput
    _min?: AircraftTypeMinOrderByAggregateInput
    _sum?: AircraftTypeSumOrderByAggregateInput
  }

  export type AircraftTypeScalarWhereWithAggregatesInput = {
    AND?: AircraftTypeScalarWhereWithAggregatesInput | AircraftTypeScalarWhereWithAggregatesInput[]
    OR?: AircraftTypeScalarWhereWithAggregatesInput[]
    NOT?: AircraftTypeScalarWhereWithAggregatesInput | AircraftTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AircraftType"> | string
    manufacturer?: StringWithAggregatesFilter<"AircraftType"> | string
    model?: StringWithAggregatesFilter<"AircraftType"> | string
    variant?: StringNullableWithAggregatesFilter<"AircraftType"> | string | null
    capacity?: IntWithAggregatesFilter<"AircraftType"> | number
    range?: IntNullableWithAggregatesFilter<"AircraftType"> | number | null
    cruiseSpeed?: IntNullableWithAggregatesFilter<"AircraftType"> | number | null
    fuelCapacity?: IntNullableWithAggregatesFilter<"AircraftType"> | number | null
    isActive?: BoolWithAggregatesFilter<"AircraftType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AircraftType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AircraftType"> | Date | string
  }

  export type AircraftWhereInput = {
    AND?: AircraftWhereInput | AircraftWhereInput[]
    OR?: AircraftWhereInput[]
    NOT?: AircraftWhereInput | AircraftWhereInput[]
    id?: StringFilter<"Aircraft"> | string
    registration?: StringFilter<"Aircraft"> | string
    airlineId?: StringFilter<"Aircraft"> | string
    aircraftTypeId?: StringFilter<"Aircraft"> | string
    name?: StringNullableFilter<"Aircraft"> | string | null
    isActive?: BoolFilter<"Aircraft"> | boolean
    createdAt?: DateTimeFilter<"Aircraft"> | Date | string
    updatedAt?: DateTimeFilter<"Aircraft"> | Date | string
    aircraftType?: XOR<AircraftTypeScalarRelationFilter, AircraftTypeWhereInput>
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
    flights?: FlightListRelationFilter
  }

  export type AircraftOrderByWithRelationInput = {
    id?: SortOrder
    registration?: SortOrder
    airlineId?: SortOrder
    aircraftTypeId?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aircraftType?: AircraftTypeOrderByWithRelationInput
    airline?: AirlineOrderByWithRelationInput
    flights?: FlightOrderByRelationAggregateInput
  }

  export type AircraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    registration?: string
    AND?: AircraftWhereInput | AircraftWhereInput[]
    OR?: AircraftWhereInput[]
    NOT?: AircraftWhereInput | AircraftWhereInput[]
    airlineId?: StringFilter<"Aircraft"> | string
    aircraftTypeId?: StringFilter<"Aircraft"> | string
    name?: StringNullableFilter<"Aircraft"> | string | null
    isActive?: BoolFilter<"Aircraft"> | boolean
    createdAt?: DateTimeFilter<"Aircraft"> | Date | string
    updatedAt?: DateTimeFilter<"Aircraft"> | Date | string
    aircraftType?: XOR<AircraftTypeScalarRelationFilter, AircraftTypeWhereInput>
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
    flights?: FlightListRelationFilter
  }, "id" | "registration">

  export type AircraftOrderByWithAggregationInput = {
    id?: SortOrder
    registration?: SortOrder
    airlineId?: SortOrder
    aircraftTypeId?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AircraftCountOrderByAggregateInput
    _max?: AircraftMaxOrderByAggregateInput
    _min?: AircraftMinOrderByAggregateInput
  }

  export type AircraftScalarWhereWithAggregatesInput = {
    AND?: AircraftScalarWhereWithAggregatesInput | AircraftScalarWhereWithAggregatesInput[]
    OR?: AircraftScalarWhereWithAggregatesInput[]
    NOT?: AircraftScalarWhereWithAggregatesInput | AircraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Aircraft"> | string
    registration?: StringWithAggregatesFilter<"Aircraft"> | string
    airlineId?: StringWithAggregatesFilter<"Aircraft"> | string
    aircraftTypeId?: StringWithAggregatesFilter<"Aircraft"> | string
    name?: StringNullableWithAggregatesFilter<"Aircraft"> | string | null
    isActive?: BoolWithAggregatesFilter<"Aircraft"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Aircraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Aircraft"> | Date | string
  }

  export type DestinationWhereInput = {
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    cityId?: StringFilter<"Destination"> | string
    countryId?: StringFilter<"Destination"> | string
    airportId?: StringFilter<"Destination"> | string
    description?: StringNullableFilter<"Destination"> | string | null
    imageUrl?: StringNullableFilter<"Destination"> | string | null
    category?: StringFilter<"Destination"> | string
    rating?: FloatNullableFilter<"Destination"> | number | null
    isActive?: BoolFilter<"Destination"> | boolean
    isFeatured?: BoolFilter<"Destination"> | boolean
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    bookingsTo?: BookingListRelationFilter
    bookingsFrom?: BookingListRelationFilter
    airport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    promotions?: PromotionListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type DestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    airportId?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    rating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingsTo?: BookingOrderByRelationAggregateInput
    bookingsFrom?: BookingOrderByRelationAggregateInput
    airport?: AirportOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    promotions?: PromotionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type DestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    name?: StringFilter<"Destination"> | string
    cityId?: StringFilter<"Destination"> | string
    countryId?: StringFilter<"Destination"> | string
    airportId?: StringFilter<"Destination"> | string
    description?: StringNullableFilter<"Destination"> | string | null
    imageUrl?: StringNullableFilter<"Destination"> | string | null
    category?: StringFilter<"Destination"> | string
    rating?: FloatNullableFilter<"Destination"> | number | null
    isActive?: BoolFilter<"Destination"> | boolean
    isFeatured?: BoolFilter<"Destination"> | boolean
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    bookingsTo?: BookingListRelationFilter
    bookingsFrom?: BookingListRelationFilter
    airport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    promotions?: PromotionListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type DestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    airportId?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    rating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DestinationCountOrderByAggregateInput
    _avg?: DestinationAvgOrderByAggregateInput
    _max?: DestinationMaxOrderByAggregateInput
    _min?: DestinationMinOrderByAggregateInput
    _sum?: DestinationSumOrderByAggregateInput
  }

  export type DestinationScalarWhereWithAggregatesInput = {
    AND?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    OR?: DestinationScalarWhereWithAggregatesInput[]
    NOT?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Destination"> | string
    name?: StringWithAggregatesFilter<"Destination"> | string
    cityId?: StringWithAggregatesFilter<"Destination"> | string
    countryId?: StringWithAggregatesFilter<"Destination"> | string
    airportId?: StringWithAggregatesFilter<"Destination"> | string
    description?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Destination"> | string | null
    category?: StringWithAggregatesFilter<"Destination"> | string
    rating?: FloatNullableWithAggregatesFilter<"Destination"> | number | null
    isActive?: BoolWithAggregatesFilter<"Destination"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Destination"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
  }

  export type FlightWhereInput = {
    AND?: FlightWhereInput | FlightWhereInput[]
    OR?: FlightWhereInput[]
    NOT?: FlightWhereInput | FlightWhereInput[]
    id?: StringFilter<"Flight"> | string
    flightNumber?: StringFilter<"Flight"> | string
    airlineId?: StringFilter<"Flight"> | string
    aircraftId?: StringFilter<"Flight"> | string
    departureAirportId?: StringFilter<"Flight"> | string
    arrivalAirportId?: StringFilter<"Flight"> | string
    departureTime?: DateTimeFilter<"Flight"> | Date | string
    arrivalTime?: DateTimeFilter<"Flight"> | Date | string
    duration?: IntFilter<"Flight"> | number
    distance?: IntNullableFilter<"Flight"> | number | null
    status?: StringFilter<"Flight"> | string
    gate?: StringNullableFilter<"Flight"> | string | null
    terminal?: StringNullableFilter<"Flight"> | string | null
    isActive?: BoolFilter<"Flight"> | boolean
    createdAt?: DateTimeFilter<"Flight"> | Date | string
    updatedAt?: DateTimeFilter<"Flight"> | Date | string
    bookings?: BookingListRelationFilter
    flightSchedules?: FlightScheduleListRelationFilter
    aircraft?: XOR<AircraftScalarRelationFilter, AircraftWhereInput>
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
    arrivalAirport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
    departureAirport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
  }

  export type FlightOrderByWithRelationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    airlineId?: SortOrder
    aircraftId?: SortOrder
    departureAirportId?: SortOrder
    arrivalAirportId?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrderInput | SortOrder
    status?: SortOrder
    gate?: SortOrderInput | SortOrder
    terminal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    flightSchedules?: FlightScheduleOrderByRelationAggregateInput
    aircraft?: AircraftOrderByWithRelationInput
    airline?: AirlineOrderByWithRelationInput
    arrivalAirport?: AirportOrderByWithRelationInput
    departureAirport?: AirportOrderByWithRelationInput
  }

  export type FlightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlightWhereInput | FlightWhereInput[]
    OR?: FlightWhereInput[]
    NOT?: FlightWhereInput | FlightWhereInput[]
    flightNumber?: StringFilter<"Flight"> | string
    airlineId?: StringFilter<"Flight"> | string
    aircraftId?: StringFilter<"Flight"> | string
    departureAirportId?: StringFilter<"Flight"> | string
    arrivalAirportId?: StringFilter<"Flight"> | string
    departureTime?: DateTimeFilter<"Flight"> | Date | string
    arrivalTime?: DateTimeFilter<"Flight"> | Date | string
    duration?: IntFilter<"Flight"> | number
    distance?: IntNullableFilter<"Flight"> | number | null
    status?: StringFilter<"Flight"> | string
    gate?: StringNullableFilter<"Flight"> | string | null
    terminal?: StringNullableFilter<"Flight"> | string | null
    isActive?: BoolFilter<"Flight"> | boolean
    createdAt?: DateTimeFilter<"Flight"> | Date | string
    updatedAt?: DateTimeFilter<"Flight"> | Date | string
    bookings?: BookingListRelationFilter
    flightSchedules?: FlightScheduleListRelationFilter
    aircraft?: XOR<AircraftScalarRelationFilter, AircraftWhereInput>
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
    arrivalAirport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
    departureAirport?: XOR<AirportScalarRelationFilter, AirportWhereInput>
  }, "id">

  export type FlightOrderByWithAggregationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    airlineId?: SortOrder
    aircraftId?: SortOrder
    departureAirportId?: SortOrder
    arrivalAirportId?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrderInput | SortOrder
    status?: SortOrder
    gate?: SortOrderInput | SortOrder
    terminal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlightCountOrderByAggregateInput
    _avg?: FlightAvgOrderByAggregateInput
    _max?: FlightMaxOrderByAggregateInput
    _min?: FlightMinOrderByAggregateInput
    _sum?: FlightSumOrderByAggregateInput
  }

  export type FlightScalarWhereWithAggregatesInput = {
    AND?: FlightScalarWhereWithAggregatesInput | FlightScalarWhereWithAggregatesInput[]
    OR?: FlightScalarWhereWithAggregatesInput[]
    NOT?: FlightScalarWhereWithAggregatesInput | FlightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flight"> | string
    flightNumber?: StringWithAggregatesFilter<"Flight"> | string
    airlineId?: StringWithAggregatesFilter<"Flight"> | string
    aircraftId?: StringWithAggregatesFilter<"Flight"> | string
    departureAirportId?: StringWithAggregatesFilter<"Flight"> | string
    arrivalAirportId?: StringWithAggregatesFilter<"Flight"> | string
    departureTime?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
    arrivalTime?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
    duration?: IntWithAggregatesFilter<"Flight"> | number
    distance?: IntNullableWithAggregatesFilter<"Flight"> | number | null
    status?: StringWithAggregatesFilter<"Flight"> | string
    gate?: StringNullableWithAggregatesFilter<"Flight"> | string | null
    terminal?: StringNullableWithAggregatesFilter<"Flight"> | string | null
    isActive?: BoolWithAggregatesFilter<"Flight"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
  }

  export type FlightScheduleWhereInput = {
    AND?: FlightScheduleWhereInput | FlightScheduleWhereInput[]
    OR?: FlightScheduleWhereInput[]
    NOT?: FlightScheduleWhereInput | FlightScheduleWhereInput[]
    id?: StringFilter<"FlightSchedule"> | string
    flightId?: StringFilter<"FlightSchedule"> | string
    classType?: StringFilter<"FlightSchedule"> | string
    availableSeats?: IntFilter<"FlightSchedule"> | number
    totalSeats?: IntFilter<"FlightSchedule"> | number
    basePrice?: FloatFilter<"FlightSchedule"> | number
    currentPrice?: FloatFilter<"FlightSchedule"> | number
    isActive?: BoolFilter<"FlightSchedule"> | boolean
    createdAt?: DateTimeFilter<"FlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"FlightSchedule"> | Date | string
    bookings?: BookingListRelationFilter
    flight?: XOR<FlightScalarRelationFilter, FlightWhereInput>
  }

  export type FlightScheduleOrderByWithRelationInput = {
    id?: SortOrder
    flightId?: SortOrder
    classType?: SortOrder
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    flight?: FlightOrderByWithRelationInput
  }

  export type FlightScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlightScheduleWhereInput | FlightScheduleWhereInput[]
    OR?: FlightScheduleWhereInput[]
    NOT?: FlightScheduleWhereInput | FlightScheduleWhereInput[]
    flightId?: StringFilter<"FlightSchedule"> | string
    classType?: StringFilter<"FlightSchedule"> | string
    availableSeats?: IntFilter<"FlightSchedule"> | number
    totalSeats?: IntFilter<"FlightSchedule"> | number
    basePrice?: FloatFilter<"FlightSchedule"> | number
    currentPrice?: FloatFilter<"FlightSchedule"> | number
    isActive?: BoolFilter<"FlightSchedule"> | boolean
    createdAt?: DateTimeFilter<"FlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"FlightSchedule"> | Date | string
    bookings?: BookingListRelationFilter
    flight?: XOR<FlightScalarRelationFilter, FlightWhereInput>
  }, "id">

  export type FlightScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    flightId?: SortOrder
    classType?: SortOrder
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlightScheduleCountOrderByAggregateInput
    _avg?: FlightScheduleAvgOrderByAggregateInput
    _max?: FlightScheduleMaxOrderByAggregateInput
    _min?: FlightScheduleMinOrderByAggregateInput
    _sum?: FlightScheduleSumOrderByAggregateInput
  }

  export type FlightScheduleScalarWhereWithAggregatesInput = {
    AND?: FlightScheduleScalarWhereWithAggregatesInput | FlightScheduleScalarWhereWithAggregatesInput[]
    OR?: FlightScheduleScalarWhereWithAggregatesInput[]
    NOT?: FlightScheduleScalarWhereWithAggregatesInput | FlightScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlightSchedule"> | string
    flightId?: StringWithAggregatesFilter<"FlightSchedule"> | string
    classType?: StringWithAggregatesFilter<"FlightSchedule"> | string
    availableSeats?: IntWithAggregatesFilter<"FlightSchedule"> | number
    totalSeats?: IntWithAggregatesFilter<"FlightSchedule"> | number
    basePrice?: FloatWithAggregatesFilter<"FlightSchedule"> | number
    currentPrice?: FloatWithAggregatesFilter<"FlightSchedule"> | number
    isActive?: BoolWithAggregatesFilter<"FlightSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FlightSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FlightSchedule"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookingReference?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    flightId?: StringNullableFilter<"Booking"> | string | null
    flightScheduleId?: StringNullableFilter<"Booking"> | string | null
    destinationId?: StringFilter<"Booking"> | string
    fromDestinationId?: StringFilter<"Booking"> | string
    departureDate?: DateTimeFilter<"Booking"> | Date | string
    returnDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    passengerCount?: IntFilter<"Booking"> | number
    bookingClass?: StringFilter<"Booking"> | string
    totalPrice?: FloatFilter<"Booking"> | number
    taxes?: FloatFilter<"Booking"> | number
    fees?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    finalPrice?: FloatFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    flight?: XOR<FlightNullableScalarRelationFilter, FlightWhereInput> | null
    flightSchedule?: XOR<FlightScheduleNullableScalarRelationFilter, FlightScheduleWhereInput> | null
    fromDestination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
    passengers?: PassengerDetailListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    bookingReference?: SortOrder
    userId?: SortOrder
    flightId?: SortOrderInput | SortOrder
    flightScheduleId?: SortOrderInput | SortOrder
    destinationId?: SortOrder
    fromDestinationId?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    passengerCount?: SortOrder
    bookingClass?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
    flight?: FlightOrderByWithRelationInput
    flightSchedule?: FlightScheduleOrderByWithRelationInput
    fromDestination?: DestinationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    passengers?: PassengerDetailOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingReference?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    flightId?: StringNullableFilter<"Booking"> | string | null
    flightScheduleId?: StringNullableFilter<"Booking"> | string | null
    destinationId?: StringFilter<"Booking"> | string
    fromDestinationId?: StringFilter<"Booking"> | string
    departureDate?: DateTimeFilter<"Booking"> | Date | string
    returnDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    passengerCount?: IntFilter<"Booking"> | number
    bookingClass?: StringFilter<"Booking"> | string
    totalPrice?: FloatFilter<"Booking"> | number
    taxes?: FloatFilter<"Booking"> | number
    fees?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    finalPrice?: FloatFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    flight?: XOR<FlightNullableScalarRelationFilter, FlightWhereInput> | null
    flightSchedule?: XOR<FlightScheduleNullableScalarRelationFilter, FlightScheduleWhereInput> | null
    fromDestination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
    passengers?: PassengerDetailListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "bookingReference">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    bookingReference?: SortOrder
    userId?: SortOrder
    flightId?: SortOrderInput | SortOrder
    flightScheduleId?: SortOrderInput | SortOrder
    destinationId?: SortOrder
    fromDestinationId?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    passengerCount?: SortOrder
    bookingClass?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    bookingReference?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    flightId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    flightScheduleId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    destinationId?: StringWithAggregatesFilter<"Booking"> | string
    fromDestinationId?: StringWithAggregatesFilter<"Booking"> | string
    departureDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    passengerCount?: IntWithAggregatesFilter<"Booking"> | number
    bookingClass?: StringWithAggregatesFilter<"Booking"> | string
    totalPrice?: FloatWithAggregatesFilter<"Booking"> | number
    taxes?: FloatWithAggregatesFilter<"Booking"> | number
    fees?: FloatWithAggregatesFilter<"Booking"> | number
    discountAmount?: FloatWithAggregatesFilter<"Booking"> | number
    finalPrice?: FloatWithAggregatesFilter<"Booking"> | number
    status?: StringWithAggregatesFilter<"Booking"> | string
    paymentStatus?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PassengerDetailWhereInput = {
    AND?: PassengerDetailWhereInput | PassengerDetailWhereInput[]
    OR?: PassengerDetailWhereInput[]
    NOT?: PassengerDetailWhereInput | PassengerDetailWhereInput[]
    id?: StringFilter<"PassengerDetail"> | string
    bookingId?: StringFilter<"PassengerDetail"> | string
    title?: StringFilter<"PassengerDetail"> | string
    firstName?: StringFilter<"PassengerDetail"> | string
    lastName?: StringFilter<"PassengerDetail"> | string
    dateOfBirth?: DateTimeFilter<"PassengerDetail"> | Date | string
    nationality?: StringFilter<"PassengerDetail"> | string
    passportNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    passportExpiry?: DateTimeNullableFilter<"PassengerDetail"> | Date | string | null
    seatNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    mealPreference?: StringNullableFilter<"PassengerDetail"> | string | null
    specialRequests?: StringNullableFilter<"PassengerDetail"> | string | null
    createdAt?: DateTimeFilter<"PassengerDetail"> | Date | string
    updatedAt?: DateTimeFilter<"PassengerDetail"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PassengerDetailOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    seatNumber?: SortOrderInput | SortOrder
    mealPreference?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PassengerDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PassengerDetailWhereInput | PassengerDetailWhereInput[]
    OR?: PassengerDetailWhereInput[]
    NOT?: PassengerDetailWhereInput | PassengerDetailWhereInput[]
    bookingId?: StringFilter<"PassengerDetail"> | string
    title?: StringFilter<"PassengerDetail"> | string
    firstName?: StringFilter<"PassengerDetail"> | string
    lastName?: StringFilter<"PassengerDetail"> | string
    dateOfBirth?: DateTimeFilter<"PassengerDetail"> | Date | string
    nationality?: StringFilter<"PassengerDetail"> | string
    passportNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    passportExpiry?: DateTimeNullableFilter<"PassengerDetail"> | Date | string | null
    seatNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    mealPreference?: StringNullableFilter<"PassengerDetail"> | string | null
    specialRequests?: StringNullableFilter<"PassengerDetail"> | string | null
    createdAt?: DateTimeFilter<"PassengerDetail"> | Date | string
    updatedAt?: DateTimeFilter<"PassengerDetail"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type PassengerDetailOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    seatNumber?: SortOrderInput | SortOrder
    mealPreference?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PassengerDetailCountOrderByAggregateInput
    _max?: PassengerDetailMaxOrderByAggregateInput
    _min?: PassengerDetailMinOrderByAggregateInput
  }

  export type PassengerDetailScalarWhereWithAggregatesInput = {
    AND?: PassengerDetailScalarWhereWithAggregatesInput | PassengerDetailScalarWhereWithAggregatesInput[]
    OR?: PassengerDetailScalarWhereWithAggregatesInput[]
    NOT?: PassengerDetailScalarWhereWithAggregatesInput | PassengerDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PassengerDetail"> | string
    bookingId?: StringWithAggregatesFilter<"PassengerDetail"> | string
    title?: StringWithAggregatesFilter<"PassengerDetail"> | string
    firstName?: StringWithAggregatesFilter<"PassengerDetail"> | string
    lastName?: StringWithAggregatesFilter<"PassengerDetail"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"PassengerDetail"> | Date | string
    nationality?: StringWithAggregatesFilter<"PassengerDetail"> | string
    passportNumber?: StringNullableWithAggregatesFilter<"PassengerDetail"> | string | null
    passportExpiry?: DateTimeNullableWithAggregatesFilter<"PassengerDetail"> | Date | string | null
    seatNumber?: StringNullableWithAggregatesFilter<"PassengerDetail"> | string | null
    mealPreference?: StringNullableWithAggregatesFilter<"PassengerDetail"> | string | null
    specialRequests?: StringNullableWithAggregatesFilter<"PassengerDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PassengerDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PassengerDetail"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentProvider?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failedReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    failedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentProvider?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failedReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    failedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    paymentProvider?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    failedReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    destinationId?: StringNullableFilter<"Review"> | string | null
    bookingId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isVerified?: BoolFilter<"Review"> | boolean
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    destinationId?: StringNullableFilter<"Review"> | string | null
    bookingId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isVerified?: BoolFilter<"Review"> | boolean
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    destinationId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    title?: StringNullableWithAggregatesFilter<"Review"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Review"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    code?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: FloatFilter<"Promotion"> | number
    minPurchase?: FloatNullableFilter<"Promotion"> | number | null
    maxDiscount?: FloatNullableFilter<"Promotion"> | number | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    usageLimit?: IntNullableFilter<"Promotion"> | number | null
    usedCount?: IntFilter<"Promotion"> | number
    isActive?: BoolFilter<"Promotion"> | boolean
    destinationId?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minPurchase?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    destinationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    destination?: DestinationOrderByWithRelationInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: FloatFilter<"Promotion"> | number
    minPurchase?: FloatNullableFilter<"Promotion"> | number | null
    maxDiscount?: FloatNullableFilter<"Promotion"> | number | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    usageLimit?: IntNullableFilter<"Promotion"> | number | null
    usedCount?: IntFilter<"Promotion"> | number
    isActive?: BoolFilter<"Promotion"> | boolean
    destinationId?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    destination?: XOR<DestinationNullableScalarRelationFilter, DestinationWhereInput> | null
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minPurchase?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    destinationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    title?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    code?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discountType?: StringWithAggregatesFilter<"Promotion"> | string
    discountValue?: FloatWithAggregatesFilter<"Promotion"> | number
    minPurchase?: FloatNullableWithAggregatesFilter<"Promotion"> | number | null
    maxDiscount?: FloatNullableWithAggregatesFilter<"Promotion"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    usageLimit?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    usedCount?: IntWithAggregatesFilter<"Promotion"> | number
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    destinationId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    bookingId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    bookingId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    bookingId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    category?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    category?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    category?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type AdminFlightScheduleWhereInput = {
    AND?: AdminFlightScheduleWhereInput | AdminFlightScheduleWhereInput[]
    OR?: AdminFlightScheduleWhereInput[]
    NOT?: AdminFlightScheduleWhereInput | AdminFlightScheduleWhereInput[]
    id?: StringFilter<"AdminFlightSchedule"> | string
    airlineId?: StringFilter<"AdminFlightSchedule"> | string
    flightNo?: StringFilter<"AdminFlightSchedule"> | string
    origin?: StringFilter<"AdminFlightSchedule"> | string
    destination?: StringFilter<"AdminFlightSchedule"> | string
    departure?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    arrival?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    basePrice?: FloatFilter<"AdminFlightSchedule"> | number
    seats?: IntFilter<"AdminFlightSchedule"> | number
    status?: StringFilter<"AdminFlightSchedule"> | string
    createdAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
  }

  export type AdminFlightScheduleOrderByWithRelationInput = {
    id?: SortOrder
    airlineId?: SortOrder
    flightNo?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departure?: SortOrder
    arrival?: SortOrder
    basePrice?: SortOrder
    seats?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    airline?: AirlineOrderByWithRelationInput
  }

  export type AdminFlightScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminFlightScheduleWhereInput | AdminFlightScheduleWhereInput[]
    OR?: AdminFlightScheduleWhereInput[]
    NOT?: AdminFlightScheduleWhereInput | AdminFlightScheduleWhereInput[]
    airlineId?: StringFilter<"AdminFlightSchedule"> | string
    flightNo?: StringFilter<"AdminFlightSchedule"> | string
    origin?: StringFilter<"AdminFlightSchedule"> | string
    destination?: StringFilter<"AdminFlightSchedule"> | string
    departure?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    arrival?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    basePrice?: FloatFilter<"AdminFlightSchedule"> | number
    seats?: IntFilter<"AdminFlightSchedule"> | number
    status?: StringFilter<"AdminFlightSchedule"> | string
    createdAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    airline?: XOR<AirlineScalarRelationFilter, AirlineWhereInput>
  }, "id">

  export type AdminFlightScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    airlineId?: SortOrder
    flightNo?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departure?: SortOrder
    arrival?: SortOrder
    basePrice?: SortOrder
    seats?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminFlightScheduleCountOrderByAggregateInput
    _avg?: AdminFlightScheduleAvgOrderByAggregateInput
    _max?: AdminFlightScheduleMaxOrderByAggregateInput
    _min?: AdminFlightScheduleMinOrderByAggregateInput
    _sum?: AdminFlightScheduleSumOrderByAggregateInput
  }

  export type AdminFlightScheduleScalarWhereWithAggregatesInput = {
    AND?: AdminFlightScheduleScalarWhereWithAggregatesInput | AdminFlightScheduleScalarWhereWithAggregatesInput[]
    OR?: AdminFlightScheduleScalarWhereWithAggregatesInput[]
    NOT?: AdminFlightScheduleScalarWhereWithAggregatesInput | AdminFlightScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    airlineId?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    flightNo?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    origin?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    destination?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    departure?: DateTimeWithAggregatesFilter<"AdminFlightSchedule"> | Date | string
    arrival?: DateTimeWithAggregatesFilter<"AdminFlightSchedule"> | Date | string
    basePrice?: FloatWithAggregatesFilter<"AdminFlightSchedule"> | number
    seats?: IntWithAggregatesFilter<"AdminFlightSchedule"> | number
    status?: StringWithAggregatesFilter<"AdminFlightSchedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminFlightSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminFlightSchedule"> | Date | string
  }

  export type AdminPromotionWhereInput = {
    AND?: AdminPromotionWhereInput | AdminPromotionWhereInput[]
    OR?: AdminPromotionWhereInput[]
    NOT?: AdminPromotionWhereInput | AdminPromotionWhereInput[]
    id?: StringFilter<"AdminPromotion"> | string
    title?: StringFilter<"AdminPromotion"> | string
    code?: StringFilter<"AdminPromotion"> | string
    discountPercent?: IntFilter<"AdminPromotion"> | number
    startsAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    endsAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    conditions?: StringNullableFilter<"AdminPromotion"> | string | null
    active?: BoolFilter<"AdminPromotion"> | boolean
    createdAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    updatedAt?: DateTimeFilter<"AdminPromotion"> | Date | string
  }

  export type AdminPromotionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    discountPercent?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    conditions?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AdminPromotionWhereInput | AdminPromotionWhereInput[]
    OR?: AdminPromotionWhereInput[]
    NOT?: AdminPromotionWhereInput | AdminPromotionWhereInput[]
    title?: StringFilter<"AdminPromotion"> | string
    discountPercent?: IntFilter<"AdminPromotion"> | number
    startsAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    endsAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    conditions?: StringNullableFilter<"AdminPromotion"> | string | null
    active?: BoolFilter<"AdminPromotion"> | boolean
    createdAt?: DateTimeFilter<"AdminPromotion"> | Date | string
    updatedAt?: DateTimeFilter<"AdminPromotion"> | Date | string
  }, "id" | "code">

  export type AdminPromotionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    discountPercent?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    conditions?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminPromotionCountOrderByAggregateInput
    _avg?: AdminPromotionAvgOrderByAggregateInput
    _max?: AdminPromotionMaxOrderByAggregateInput
    _min?: AdminPromotionMinOrderByAggregateInput
    _sum?: AdminPromotionSumOrderByAggregateInput
  }

  export type AdminPromotionScalarWhereWithAggregatesInput = {
    AND?: AdminPromotionScalarWhereWithAggregatesInput | AdminPromotionScalarWhereWithAggregatesInput[]
    OR?: AdminPromotionScalarWhereWithAggregatesInput[]
    NOT?: AdminPromotionScalarWhereWithAggregatesInput | AdminPromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminPromotion"> | string
    title?: StringWithAggregatesFilter<"AdminPromotion"> | string
    code?: StringWithAggregatesFilter<"AdminPromotion"> | string
    discountPercent?: IntWithAggregatesFilter<"AdminPromotion"> | number
    startsAt?: DateTimeWithAggregatesFilter<"AdminPromotion"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"AdminPromotion"> | Date | string
    conditions?: StringNullableWithAggregatesFilter<"AdminPromotion"> | string | null
    active?: BoolWithAggregatesFilter<"AdminPromotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminPromotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminPromotion"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineCreateNestedManyWithoutCountryInput
    airports?: AirportCreateNestedManyWithoutCountryInput
    cities?: CityCreateNestedManyWithoutCountryInput
    destinations?: DestinationCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineUncheckedCreateNestedManyWithoutCountryInput
    airports?: AirportUncheckedCreateNestedManyWithoutCountryInput
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUpdateManyWithoutCountryNestedInput
    airports?: AirportUpdateManyWithoutCountryNestedInput
    cities?: CityUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUncheckedUpdateManyWithoutCountryNestedInput
    airports?: AirportUncheckedUpdateManyWithoutCountryNestedInput
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportCreateNestedManyWithoutCityInput
    country: CountryCreateNestedOneWithoutCitiesInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    countryId: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUpdateManyWithoutCityNestedInput
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    countryId: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirportCreateInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAirportsInput
    country: CountryCreateNestedOneWithoutAirportsInput
    destinations?: DestinationCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUncheckedCreateInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightUncheckedCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightUncheckedCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAirportsNestedInput
    country?: CountryUpdateOneRequiredWithoutAirportsNestedInput
    destinations?: DestinationUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportCreateManyInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirlineCreateInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftCreateNestedManyWithoutAirlineInput
    country: CountryCreateNestedOneWithoutAirlinesInput
    flights?: FlightCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    countryId: string
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftUncheckedCreateNestedManyWithoutAirlineInput
    flights?: FlightUncheckedCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUpdateManyWithoutAirlineNestedInput
    country?: CountryUpdateOneRequiredWithoutAirlinesNestedInput
    flights?: FlightUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUncheckedUpdateManyWithoutAirlineNestedInput
    flights?: FlightUncheckedUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineCreateManyInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    countryId: string
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirlineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirlineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftTypeCreateInput = {
    id?: string
    manufacturer: string
    model: string
    variant?: string | null
    capacity: number
    range?: number | null
    cruiseSpeed?: number | null
    fuelCapacity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftCreateNestedManyWithoutAircraftTypeInput
  }

  export type AircraftTypeUncheckedCreateInput = {
    id?: string
    manufacturer: string
    model: string
    variant?: string | null
    capacity: number
    range?: number | null
    cruiseSpeed?: number | null
    fuelCapacity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftUncheckedCreateNestedManyWithoutAircraftTypeInput
  }

  export type AircraftTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUpdateManyWithoutAircraftTypeNestedInput
  }

  export type AircraftTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUncheckedUpdateManyWithoutAircraftTypeNestedInput
  }

  export type AircraftTypeCreateManyInput = {
    id?: string
    manufacturer: string
    model: string
    variant?: string | null
    capacity: number
    range?: number | null
    cruiseSpeed?: number | null
    fuelCapacity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftCreateInput = {
    id?: string
    registration: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraftType: AircraftTypeCreateNestedOneWithoutAircraftInput
    airline: AirlineCreateNestedOneWithoutAircraftInput
    flights?: FlightCreateNestedManyWithoutAircraftInput
  }

  export type AircraftUncheckedCreateInput = {
    id?: string
    registration: string
    airlineId: string
    aircraftTypeId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flights?: FlightUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type AircraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraftType?: AircraftTypeUpdateOneRequiredWithoutAircraftNestedInput
    airline?: AirlineUpdateOneRequiredWithoutAircraftNestedInput
    flights?: FlightUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftTypeId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flights?: FlightUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftCreateManyInput = {
    id?: string
    registration: string
    airlineId: string
    aircraftTypeId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftTypeId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationCreateManyInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightCreateInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightCreateManyInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightScheduleCreateInput = {
    id?: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightScheduleInput
    flight: FlightCreateNestedOneWithoutFlightSchedulesInput
  }

  export type FlightScheduleUncheckedCreateInput = {
    id?: string
    flightId: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightScheduleInput
  }

  export type FlightScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightScheduleNestedInput
    flight?: FlightUpdateOneRequiredWithoutFlightSchedulesNestedInput
  }

  export type FlightScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightScheduleNestedInput
  }

  export type FlightScheduleCreateManyInput = {
    id?: string
    flightId: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailCreateInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPassengersInput
  }

  export type PassengerDetailUncheckedCreateInput = {
    id?: string
    bookingId: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPassengersNestedInput
  }

  export type PassengerDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailCreateManyInput = {
    id?: string
    bookingId: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    userId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    userId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destination?: DestinationCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    destinationId?: string | null
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    destinationId?: string | null
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destination?: DestinationCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    destinationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    destinationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    bookingId?: string | null
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    bookingId?: string | null
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleCreateInput = {
    id?: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    airline: AirlineCreateNestedOneWithoutAdminFlightSchedulesInput
  }

  export type AdminFlightScheduleUncheckedCreateInput = {
    id?: string
    airlineId: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminFlightScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airline?: AirlineUpdateOneRequiredWithoutAdminFlightSchedulesNestedInput
  }

  export type AdminFlightScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleCreateManyInput = {
    id?: string
    airlineId: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminFlightScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPromotionCreateInput = {
    id?: string
    title: string
    code: string
    discountPercent: number
    startsAt: Date | string
    endsAt: Date | string
    conditions?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPromotionUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    discountPercent: number
    startsAt: Date | string
    endsAt: Date | string
    conditions?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPromotionCreateManyInput = {
    id?: string
    title: string
    code: string
    discountPercent: number
    startsAt: Date | string
    endsAt: Date | string
    conditions?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AirlineListRelationFilter = {
    every?: AirlineWhereInput
    some?: AirlineWhereInput
    none?: AirlineWhereInput
  }

  export type AirportListRelationFilter = {
    every?: AirportWhereInput
    some?: AirportWhereInput
    none?: AirportWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type DestinationListRelationFilter = {
    every?: DestinationWhereInput
    some?: DestinationWhereInput
    none?: DestinationWhereInput
  }

  export type AirlineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AirportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    state?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    population?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    state?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    state?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    population?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type FlightListRelationFilter = {
    every?: FlightWhereInput
    some?: FlightWhereInput
    none?: FlightWhereInput
  }

  export type FlightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AirportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iataCode?: SortOrder
    icaoCode?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    municipality?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    elevation?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirportAvgOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    elevation?: SortOrder
  }

  export type AirportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iataCode?: SortOrder
    icaoCode?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    municipality?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    elevation?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iataCode?: SortOrder
    icaoCode?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    municipality?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    elevation?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirportSumOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    elevation?: SortOrder
  }

  export type AircraftListRelationFilter = {
    every?: AircraftWhereInput
    some?: AircraftWhereInput
    none?: AircraftWhereInput
  }

  export type AdminFlightScheduleListRelationFilter = {
    every?: AdminFlightScheduleWhereInput
    some?: AdminFlightScheduleWhereInput
    none?: AdminFlightScheduleWhereInput
  }

  export type AircraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminFlightScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AirlineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icaoCode?: SortOrder
    countryId?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirlineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icaoCode?: SortOrder
    countryId?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirlineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    icaoCode?: SortOrder
    countryId?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AircraftTypeManufacturerModelVariantCompoundUniqueInput = {
    manufacturer: string
    model: string
    variant: string
  }

  export type AircraftTypeCountOrderByAggregateInput = {
    id?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    variant?: SortOrder
    capacity?: SortOrder
    range?: SortOrder
    cruiseSpeed?: SortOrder
    fuelCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AircraftTypeAvgOrderByAggregateInput = {
    capacity?: SortOrder
    range?: SortOrder
    cruiseSpeed?: SortOrder
    fuelCapacity?: SortOrder
  }

  export type AircraftTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    variant?: SortOrder
    capacity?: SortOrder
    range?: SortOrder
    cruiseSpeed?: SortOrder
    fuelCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AircraftTypeMinOrderByAggregateInput = {
    id?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    variant?: SortOrder
    capacity?: SortOrder
    range?: SortOrder
    cruiseSpeed?: SortOrder
    fuelCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AircraftTypeSumOrderByAggregateInput = {
    capacity?: SortOrder
    range?: SortOrder
    cruiseSpeed?: SortOrder
    fuelCapacity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AircraftTypeScalarRelationFilter = {
    is?: AircraftTypeWhereInput
    isNot?: AircraftTypeWhereInput
  }

  export type AirlineScalarRelationFilter = {
    is?: AirlineWhereInput
    isNot?: AirlineWhereInput
  }

  export type AircraftCountOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    airlineId?: SortOrder
    aircraftTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AircraftMaxOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    airlineId?: SortOrder
    aircraftTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AircraftMinOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    airlineId?: SortOrder
    aircraftTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirportScalarRelationFilter = {
    is?: AirportWhereInput
    isNot?: AirportWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    airportId?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type DestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    airportId?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cityId?: SortOrder
    countryId?: SortOrder
    airportId?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DestinationSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FlightScheduleListRelationFilter = {
    every?: FlightScheduleWhereInput
    some?: FlightScheduleWhereInput
    none?: FlightScheduleWhereInput
  }

  export type AircraftScalarRelationFilter = {
    is?: AircraftWhereInput
    isNot?: AircraftWhereInput
  }

  export type FlightScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlightCountOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    airlineId?: SortOrder
    aircraftId?: SortOrder
    departureAirportId?: SortOrder
    arrivalAirportId?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    status?: SortOrder
    gate?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightAvgOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
  }

  export type FlightMaxOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    airlineId?: SortOrder
    aircraftId?: SortOrder
    departureAirportId?: SortOrder
    arrivalAirportId?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    status?: SortOrder
    gate?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightMinOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    airlineId?: SortOrder
    aircraftId?: SortOrder
    departureAirportId?: SortOrder
    arrivalAirportId?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    status?: SortOrder
    gate?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightSumOrderByAggregateInput = {
    duration?: SortOrder
    distance?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FlightScalarRelationFilter = {
    is?: FlightWhereInput
    isNot?: FlightWhereInput
  }

  export type FlightScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    flightId?: SortOrder
    classType?: SortOrder
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightScheduleAvgOrderByAggregateInput = {
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
  }

  export type FlightScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    flightId?: SortOrder
    classType?: SortOrder
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    flightId?: SortOrder
    classType?: SortOrder
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightScheduleSumOrderByAggregateInput = {
    availableSeats?: SortOrder
    totalSeats?: SortOrder
    basePrice?: SortOrder
    currentPrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DestinationScalarRelationFilter = {
    is?: DestinationWhereInput
    isNot?: DestinationWhereInput
  }

  export type FlightNullableScalarRelationFilter = {
    is?: FlightWhereInput | null
    isNot?: FlightWhereInput | null
  }

  export type FlightScheduleNullableScalarRelationFilter = {
    is?: FlightScheduleWhereInput | null
    isNot?: FlightScheduleWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PassengerDetailListRelationFilter = {
    every?: PassengerDetailWhereInput
    some?: PassengerDetailWhereInput
    none?: PassengerDetailWhereInput
  }

  export type PassengerDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    bookingReference?: SortOrder
    userId?: SortOrder
    flightId?: SortOrder
    flightScheduleId?: SortOrder
    destinationId?: SortOrder
    fromDestinationId?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    passengerCount?: SortOrder
    bookingClass?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    passengerCount?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingReference?: SortOrder
    userId?: SortOrder
    flightId?: SortOrder
    flightScheduleId?: SortOrder
    destinationId?: SortOrder
    fromDestinationId?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    passengerCount?: SortOrder
    bookingClass?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    bookingReference?: SortOrder
    userId?: SortOrder
    flightId?: SortOrder
    flightScheduleId?: SortOrder
    destinationId?: SortOrder
    fromDestinationId?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    passengerCount?: SortOrder
    bookingClass?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    passengerCount?: SortOrder
    totalPrice?: SortOrder
    taxes?: SortOrder
    fees?: SortOrder
    discountAmount?: SortOrder
    finalPrice?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type PassengerDetailCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    seatNumber?: SortOrder
    mealPreference?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    seatNumber?: SortOrder
    mealPreference?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerDetailMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    seatNumber?: SortOrder
    mealPreference?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentProvider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    failedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentProvider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    failedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentProvider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    failedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DestinationNullableScalarRelationFilter = {
    is?: DestinationWhereInput | null
    isNot?: DestinationWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    bookingId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    bookingId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    destinationId?: SortOrder
    bookingId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minPurchase?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    minPurchase?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minPurchase?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    minPurchase?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    destinationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discountValue?: SortOrder
    minPurchase?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminFlightScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    airlineId?: SortOrder
    flightNo?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departure?: SortOrder
    arrival?: SortOrder
    basePrice?: SortOrder
    seats?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminFlightScheduleAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    seats?: SortOrder
  }

  export type AdminFlightScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    airlineId?: SortOrder
    flightNo?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departure?: SortOrder
    arrival?: SortOrder
    basePrice?: SortOrder
    seats?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminFlightScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    airlineId?: SortOrder
    flightNo?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departure?: SortOrder
    arrival?: SortOrder
    basePrice?: SortOrder
    seats?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminFlightScheduleSumOrderByAggregateInput = {
    basePrice?: SortOrder
    seats?: SortOrder
  }

  export type AdminPromotionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    discountPercent?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    conditions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPromotionAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type AdminPromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    discountPercent?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    conditions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPromotionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    discountPercent?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    conditions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPromotionSumOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type AirlineCreateNestedManyWithoutCountryInput = {
    create?: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput> | AirlineCreateWithoutCountryInput[] | AirlineUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirlineCreateOrConnectWithoutCountryInput | AirlineCreateOrConnectWithoutCountryInput[]
    createMany?: AirlineCreateManyCountryInputEnvelope
    connect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
  }

  export type AirportCreateNestedManyWithoutCountryInput = {
    create?: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput> | AirportCreateWithoutCountryInput[] | AirportUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCountryInput | AirportCreateOrConnectWithoutCountryInput[]
    createMany?: AirportCreateManyCountryInputEnvelope
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DestinationCreateNestedManyWithoutCountryInput = {
    create?: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput> | DestinationCreateWithoutCountryInput[] | DestinationUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCountryInput | DestinationCreateOrConnectWithoutCountryInput[]
    createMany?: DestinationCreateManyCountryInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type AirlineUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput> | AirlineCreateWithoutCountryInput[] | AirlineUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirlineCreateOrConnectWithoutCountryInput | AirlineCreateOrConnectWithoutCountryInput[]
    createMany?: AirlineCreateManyCountryInputEnvelope
    connect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
  }

  export type AirportUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput> | AirportCreateWithoutCountryInput[] | AirportUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCountryInput | AirportCreateOrConnectWithoutCountryInput[]
    createMany?: AirportCreateManyCountryInputEnvelope
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DestinationUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput> | DestinationCreateWithoutCountryInput[] | DestinationUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCountryInput | DestinationCreateOrConnectWithoutCountryInput[]
    createMany?: DestinationCreateManyCountryInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type AirlineUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput> | AirlineCreateWithoutCountryInput[] | AirlineUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirlineCreateOrConnectWithoutCountryInput | AirlineCreateOrConnectWithoutCountryInput[]
    upsert?: AirlineUpsertWithWhereUniqueWithoutCountryInput | AirlineUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AirlineCreateManyCountryInputEnvelope
    set?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    disconnect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    delete?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    connect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    update?: AirlineUpdateWithWhereUniqueWithoutCountryInput | AirlineUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AirlineUpdateManyWithWhereWithoutCountryInput | AirlineUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AirlineScalarWhereInput | AirlineScalarWhereInput[]
  }

  export type AirportUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput> | AirportCreateWithoutCountryInput[] | AirportUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCountryInput | AirportCreateOrConnectWithoutCountryInput[]
    upsert?: AirportUpsertWithWhereUniqueWithoutCountryInput | AirportUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AirportCreateManyCountryInputEnvelope
    set?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    disconnect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    delete?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    update?: AirportUpdateWithWhereUniqueWithoutCountryInput | AirportUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AirportUpdateManyWithWhereWithoutCountryInput | AirportUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AirportScalarWhereInput | AirportScalarWhereInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DestinationUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput> | DestinationCreateWithoutCountryInput[] | DestinationUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCountryInput | DestinationCreateOrConnectWithoutCountryInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCountryInput | DestinationUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DestinationCreateManyCountryInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCountryInput | DestinationUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCountryInput | DestinationUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type AirlineUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput> | AirlineCreateWithoutCountryInput[] | AirlineUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirlineCreateOrConnectWithoutCountryInput | AirlineCreateOrConnectWithoutCountryInput[]
    upsert?: AirlineUpsertWithWhereUniqueWithoutCountryInput | AirlineUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AirlineCreateManyCountryInputEnvelope
    set?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    disconnect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    delete?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    connect?: AirlineWhereUniqueInput | AirlineWhereUniqueInput[]
    update?: AirlineUpdateWithWhereUniqueWithoutCountryInput | AirlineUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AirlineUpdateManyWithWhereWithoutCountryInput | AirlineUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AirlineScalarWhereInput | AirlineScalarWhereInput[]
  }

  export type AirportUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput> | AirportCreateWithoutCountryInput[] | AirportUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCountryInput | AirportCreateOrConnectWithoutCountryInput[]
    upsert?: AirportUpsertWithWhereUniqueWithoutCountryInput | AirportUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AirportCreateManyCountryInputEnvelope
    set?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    disconnect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    delete?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    update?: AirportUpdateWithWhereUniqueWithoutCountryInput | AirportUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AirportUpdateManyWithWhereWithoutCountryInput | AirportUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AirportScalarWhereInput | AirportScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DestinationUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput> | DestinationCreateWithoutCountryInput[] | DestinationUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCountryInput | DestinationCreateOrConnectWithoutCountryInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCountryInput | DestinationUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DestinationCreateManyCountryInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCountryInput | DestinationUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCountryInput | DestinationUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type AirportCreateNestedManyWithoutCityInput = {
    create?: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput> | AirportCreateWithoutCityInput[] | AirportUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCityInput | AirportCreateOrConnectWithoutCityInput[]
    createMany?: AirportCreateManyCityInputEnvelope
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type DestinationCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    createMany?: DestinationCreateManyCityInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type AirportUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput> | AirportCreateWithoutCityInput[] | AirportUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCityInput | AirportCreateOrConnectWithoutCityInput[]
    createMany?: AirportCreateManyCityInputEnvelope
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
  }

  export type DestinationUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    createMany?: DestinationCreateManyCityInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AirportUpdateManyWithoutCityNestedInput = {
    create?: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput> | AirportCreateWithoutCityInput[] | AirportUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCityInput | AirportCreateOrConnectWithoutCityInput[]
    upsert?: AirportUpsertWithWhereUniqueWithoutCityInput | AirportUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AirportCreateManyCityInputEnvelope
    set?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    disconnect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    delete?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    update?: AirportUpdateWithWhereUniqueWithoutCityInput | AirportUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AirportUpdateManyWithWhereWithoutCityInput | AirportUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AirportScalarWhereInput | AirportScalarWhereInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type DestinationUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCityInput | DestinationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DestinationCreateManyCityInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCityInput | DestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCityInput | DestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type AirportUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput> | AirportCreateWithoutCityInput[] | AirportUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AirportCreateOrConnectWithoutCityInput | AirportCreateOrConnectWithoutCityInput[]
    upsert?: AirportUpsertWithWhereUniqueWithoutCityInput | AirportUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AirportCreateManyCityInputEnvelope
    set?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    disconnect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    delete?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    connect?: AirportWhereUniqueInput | AirportWhereUniqueInput[]
    update?: AirportUpdateWithWhereUniqueWithoutCityInput | AirportUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AirportUpdateManyWithWhereWithoutCityInput | AirportUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AirportScalarWhereInput | AirportScalarWhereInput[]
  }

  export type DestinationUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput> | DestinationCreateWithoutCityInput[] | DestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutCityInput | DestinationCreateOrConnectWithoutCityInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutCityInput | DestinationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DestinationCreateManyCityInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutCityInput | DestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutCityInput | DestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutAirportsInput = {
    create?: XOR<CityCreateWithoutAirportsInput, CityUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAirportsInput
    connect?: CityWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutAirportsInput = {
    create?: XOR<CountryCreateWithoutAirportsInput, CountryUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAirportsInput
    connect?: CountryWhereUniqueInput
  }

  export type DestinationCreateNestedManyWithoutAirportInput = {
    create?: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput> | DestinationCreateWithoutAirportInput[] | DestinationUncheckedCreateWithoutAirportInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutAirportInput | DestinationCreateOrConnectWithoutAirportInput[]
    createMany?: DestinationCreateManyAirportInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type FlightCreateNestedManyWithoutArrivalAirportInput = {
    create?: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput> | FlightCreateWithoutArrivalAirportInput[] | FlightUncheckedCreateWithoutArrivalAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutArrivalAirportInput | FlightCreateOrConnectWithoutArrivalAirportInput[]
    createMany?: FlightCreateManyArrivalAirportInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type FlightCreateNestedManyWithoutDepartureAirportInput = {
    create?: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput> | FlightCreateWithoutDepartureAirportInput[] | FlightUncheckedCreateWithoutDepartureAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutDepartureAirportInput | FlightCreateOrConnectWithoutDepartureAirportInput[]
    createMany?: FlightCreateManyDepartureAirportInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type DestinationUncheckedCreateNestedManyWithoutAirportInput = {
    create?: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput> | DestinationCreateWithoutAirportInput[] | DestinationUncheckedCreateWithoutAirportInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutAirportInput | DestinationCreateOrConnectWithoutAirportInput[]
    createMany?: DestinationCreateManyAirportInputEnvelope
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
  }

  export type FlightUncheckedCreateNestedManyWithoutArrivalAirportInput = {
    create?: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput> | FlightCreateWithoutArrivalAirportInput[] | FlightUncheckedCreateWithoutArrivalAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutArrivalAirportInput | FlightCreateOrConnectWithoutArrivalAirportInput[]
    createMany?: FlightCreateManyArrivalAirportInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type FlightUncheckedCreateNestedManyWithoutDepartureAirportInput = {
    create?: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput> | FlightCreateWithoutDepartureAirportInput[] | FlightUncheckedCreateWithoutDepartureAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutDepartureAirportInput | FlightCreateOrConnectWithoutDepartureAirportInput[]
    createMany?: FlightCreateManyDepartureAirportInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutAirportsNestedInput = {
    create?: XOR<CityCreateWithoutAirportsInput, CityUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAirportsInput
    upsert?: CityUpsertWithoutAirportsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAirportsInput, CityUpdateWithoutAirportsInput>, CityUncheckedUpdateWithoutAirportsInput>
  }

  export type CountryUpdateOneRequiredWithoutAirportsNestedInput = {
    create?: XOR<CountryCreateWithoutAirportsInput, CountryUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAirportsInput
    upsert?: CountryUpsertWithoutAirportsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutAirportsInput, CountryUpdateWithoutAirportsInput>, CountryUncheckedUpdateWithoutAirportsInput>
  }

  export type DestinationUpdateManyWithoutAirportNestedInput = {
    create?: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput> | DestinationCreateWithoutAirportInput[] | DestinationUncheckedCreateWithoutAirportInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutAirportInput | DestinationCreateOrConnectWithoutAirportInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutAirportInput | DestinationUpsertWithWhereUniqueWithoutAirportInput[]
    createMany?: DestinationCreateManyAirportInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutAirportInput | DestinationUpdateWithWhereUniqueWithoutAirportInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutAirportInput | DestinationUpdateManyWithWhereWithoutAirportInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type FlightUpdateManyWithoutArrivalAirportNestedInput = {
    create?: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput> | FlightCreateWithoutArrivalAirportInput[] | FlightUncheckedCreateWithoutArrivalAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutArrivalAirportInput | FlightCreateOrConnectWithoutArrivalAirportInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutArrivalAirportInput | FlightUpsertWithWhereUniqueWithoutArrivalAirportInput[]
    createMany?: FlightCreateManyArrivalAirportInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutArrivalAirportInput | FlightUpdateWithWhereUniqueWithoutArrivalAirportInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutArrivalAirportInput | FlightUpdateManyWithWhereWithoutArrivalAirportInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type FlightUpdateManyWithoutDepartureAirportNestedInput = {
    create?: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput> | FlightCreateWithoutDepartureAirportInput[] | FlightUncheckedCreateWithoutDepartureAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutDepartureAirportInput | FlightCreateOrConnectWithoutDepartureAirportInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutDepartureAirportInput | FlightUpsertWithWhereUniqueWithoutDepartureAirportInput[]
    createMany?: FlightCreateManyDepartureAirportInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutDepartureAirportInput | FlightUpdateWithWhereUniqueWithoutDepartureAirportInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutDepartureAirportInput | FlightUpdateManyWithWhereWithoutDepartureAirportInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type DestinationUncheckedUpdateManyWithoutAirportNestedInput = {
    create?: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput> | DestinationCreateWithoutAirportInput[] | DestinationUncheckedCreateWithoutAirportInput[]
    connectOrCreate?: DestinationCreateOrConnectWithoutAirportInput | DestinationCreateOrConnectWithoutAirportInput[]
    upsert?: DestinationUpsertWithWhereUniqueWithoutAirportInput | DestinationUpsertWithWhereUniqueWithoutAirportInput[]
    createMany?: DestinationCreateManyAirportInputEnvelope
    set?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    disconnect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    delete?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    connect?: DestinationWhereUniqueInput | DestinationWhereUniqueInput[]
    update?: DestinationUpdateWithWhereUniqueWithoutAirportInput | DestinationUpdateWithWhereUniqueWithoutAirportInput[]
    updateMany?: DestinationUpdateManyWithWhereWithoutAirportInput | DestinationUpdateManyWithWhereWithoutAirportInput[]
    deleteMany?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
  }

  export type FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput = {
    create?: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput> | FlightCreateWithoutArrivalAirportInput[] | FlightUncheckedCreateWithoutArrivalAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutArrivalAirportInput | FlightCreateOrConnectWithoutArrivalAirportInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutArrivalAirportInput | FlightUpsertWithWhereUniqueWithoutArrivalAirportInput[]
    createMany?: FlightCreateManyArrivalAirportInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutArrivalAirportInput | FlightUpdateWithWhereUniqueWithoutArrivalAirportInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutArrivalAirportInput | FlightUpdateManyWithWhereWithoutArrivalAirportInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput = {
    create?: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput> | FlightCreateWithoutDepartureAirportInput[] | FlightUncheckedCreateWithoutDepartureAirportInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutDepartureAirportInput | FlightCreateOrConnectWithoutDepartureAirportInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutDepartureAirportInput | FlightUpsertWithWhereUniqueWithoutDepartureAirportInput[]
    createMany?: FlightCreateManyDepartureAirportInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutDepartureAirportInput | FlightUpdateWithWhereUniqueWithoutDepartureAirportInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutDepartureAirportInput | FlightUpdateManyWithWhereWithoutDepartureAirportInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type AircraftCreateNestedManyWithoutAirlineInput = {
    create?: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput> | AircraftCreateWithoutAirlineInput[] | AircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAirlineInput | AircraftCreateOrConnectWithoutAirlineInput[]
    createMany?: AircraftCreateManyAirlineInputEnvelope
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
  }

  export type CountryCreateNestedOneWithoutAirlinesInput = {
    create?: XOR<CountryCreateWithoutAirlinesInput, CountryUncheckedCreateWithoutAirlinesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAirlinesInput
    connect?: CountryWhereUniqueInput
  }

  export type FlightCreateNestedManyWithoutAirlineInput = {
    create?: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput> | FlightCreateWithoutAirlineInput[] | FlightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAirlineInput | FlightCreateOrConnectWithoutAirlineInput[]
    createMany?: FlightCreateManyAirlineInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type AdminFlightScheduleCreateNestedManyWithoutAirlineInput = {
    create?: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput> | AdminFlightScheduleCreateWithoutAirlineInput[] | AdminFlightScheduleUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AdminFlightScheduleCreateOrConnectWithoutAirlineInput | AdminFlightScheduleCreateOrConnectWithoutAirlineInput[]
    createMany?: AdminFlightScheduleCreateManyAirlineInputEnvelope
    connect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
  }

  export type AircraftUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput> | AircraftCreateWithoutAirlineInput[] | AircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAirlineInput | AircraftCreateOrConnectWithoutAirlineInput[]
    createMany?: AircraftCreateManyAirlineInputEnvelope
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
  }

  export type FlightUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput> | FlightCreateWithoutAirlineInput[] | FlightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAirlineInput | FlightCreateOrConnectWithoutAirlineInput[]
    createMany?: FlightCreateManyAirlineInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type AdminFlightScheduleUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput> | AdminFlightScheduleCreateWithoutAirlineInput[] | AdminFlightScheduleUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AdminFlightScheduleCreateOrConnectWithoutAirlineInput | AdminFlightScheduleCreateOrConnectWithoutAirlineInput[]
    createMany?: AdminFlightScheduleCreateManyAirlineInputEnvelope
    connect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
  }

  export type AircraftUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput> | AircraftCreateWithoutAirlineInput[] | AircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAirlineInput | AircraftCreateOrConnectWithoutAirlineInput[]
    upsert?: AircraftUpsertWithWhereUniqueWithoutAirlineInput | AircraftUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: AircraftCreateManyAirlineInputEnvelope
    set?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    disconnect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    delete?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    update?: AircraftUpdateWithWhereUniqueWithoutAirlineInput | AircraftUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: AircraftUpdateManyWithWhereWithoutAirlineInput | AircraftUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
  }

  export type CountryUpdateOneRequiredWithoutAirlinesNestedInput = {
    create?: XOR<CountryCreateWithoutAirlinesInput, CountryUncheckedCreateWithoutAirlinesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAirlinesInput
    upsert?: CountryUpsertWithoutAirlinesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutAirlinesInput, CountryUpdateWithoutAirlinesInput>, CountryUncheckedUpdateWithoutAirlinesInput>
  }

  export type FlightUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput> | FlightCreateWithoutAirlineInput[] | FlightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAirlineInput | FlightCreateOrConnectWithoutAirlineInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutAirlineInput | FlightUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: FlightCreateManyAirlineInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutAirlineInput | FlightUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutAirlineInput | FlightUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type AdminFlightScheduleUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput> | AdminFlightScheduleCreateWithoutAirlineInput[] | AdminFlightScheduleUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AdminFlightScheduleCreateOrConnectWithoutAirlineInput | AdminFlightScheduleCreateOrConnectWithoutAirlineInput[]
    upsert?: AdminFlightScheduleUpsertWithWhereUniqueWithoutAirlineInput | AdminFlightScheduleUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: AdminFlightScheduleCreateManyAirlineInputEnvelope
    set?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    disconnect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    delete?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    connect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    update?: AdminFlightScheduleUpdateWithWhereUniqueWithoutAirlineInput | AdminFlightScheduleUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: AdminFlightScheduleUpdateManyWithWhereWithoutAirlineInput | AdminFlightScheduleUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: AdminFlightScheduleScalarWhereInput | AdminFlightScheduleScalarWhereInput[]
  }

  export type AircraftUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput> | AircraftCreateWithoutAirlineInput[] | AircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAirlineInput | AircraftCreateOrConnectWithoutAirlineInput[]
    upsert?: AircraftUpsertWithWhereUniqueWithoutAirlineInput | AircraftUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: AircraftCreateManyAirlineInputEnvelope
    set?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    disconnect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    delete?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    update?: AircraftUpdateWithWhereUniqueWithoutAirlineInput | AircraftUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: AircraftUpdateManyWithWhereWithoutAirlineInput | AircraftUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
  }

  export type FlightUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput> | FlightCreateWithoutAirlineInput[] | FlightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAirlineInput | FlightCreateOrConnectWithoutAirlineInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutAirlineInput | FlightUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: FlightCreateManyAirlineInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutAirlineInput | FlightUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutAirlineInput | FlightUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type AdminFlightScheduleUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput> | AdminFlightScheduleCreateWithoutAirlineInput[] | AdminFlightScheduleUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: AdminFlightScheduleCreateOrConnectWithoutAirlineInput | AdminFlightScheduleCreateOrConnectWithoutAirlineInput[]
    upsert?: AdminFlightScheduleUpsertWithWhereUniqueWithoutAirlineInput | AdminFlightScheduleUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: AdminFlightScheduleCreateManyAirlineInputEnvelope
    set?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    disconnect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    delete?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    connect?: AdminFlightScheduleWhereUniqueInput | AdminFlightScheduleWhereUniqueInput[]
    update?: AdminFlightScheduleUpdateWithWhereUniqueWithoutAirlineInput | AdminFlightScheduleUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: AdminFlightScheduleUpdateManyWithWhereWithoutAirlineInput | AdminFlightScheduleUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: AdminFlightScheduleScalarWhereInput | AdminFlightScheduleScalarWhereInput[]
  }

  export type AircraftCreateNestedManyWithoutAircraftTypeInput = {
    create?: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput> | AircraftCreateWithoutAircraftTypeInput[] | AircraftUncheckedCreateWithoutAircraftTypeInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAircraftTypeInput | AircraftCreateOrConnectWithoutAircraftTypeInput[]
    createMany?: AircraftCreateManyAircraftTypeInputEnvelope
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
  }

  export type AircraftUncheckedCreateNestedManyWithoutAircraftTypeInput = {
    create?: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput> | AircraftCreateWithoutAircraftTypeInput[] | AircraftUncheckedCreateWithoutAircraftTypeInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAircraftTypeInput | AircraftCreateOrConnectWithoutAircraftTypeInput[]
    createMany?: AircraftCreateManyAircraftTypeInputEnvelope
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AircraftUpdateManyWithoutAircraftTypeNestedInput = {
    create?: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput> | AircraftCreateWithoutAircraftTypeInput[] | AircraftUncheckedCreateWithoutAircraftTypeInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAircraftTypeInput | AircraftCreateOrConnectWithoutAircraftTypeInput[]
    upsert?: AircraftUpsertWithWhereUniqueWithoutAircraftTypeInput | AircraftUpsertWithWhereUniqueWithoutAircraftTypeInput[]
    createMany?: AircraftCreateManyAircraftTypeInputEnvelope
    set?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    disconnect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    delete?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    update?: AircraftUpdateWithWhereUniqueWithoutAircraftTypeInput | AircraftUpdateWithWhereUniqueWithoutAircraftTypeInput[]
    updateMany?: AircraftUpdateManyWithWhereWithoutAircraftTypeInput | AircraftUpdateManyWithWhereWithoutAircraftTypeInput[]
    deleteMany?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
  }

  export type AircraftUncheckedUpdateManyWithoutAircraftTypeNestedInput = {
    create?: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput> | AircraftCreateWithoutAircraftTypeInput[] | AircraftUncheckedCreateWithoutAircraftTypeInput[]
    connectOrCreate?: AircraftCreateOrConnectWithoutAircraftTypeInput | AircraftCreateOrConnectWithoutAircraftTypeInput[]
    upsert?: AircraftUpsertWithWhereUniqueWithoutAircraftTypeInput | AircraftUpsertWithWhereUniqueWithoutAircraftTypeInput[]
    createMany?: AircraftCreateManyAircraftTypeInputEnvelope
    set?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    disconnect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    delete?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    connect?: AircraftWhereUniqueInput | AircraftWhereUniqueInput[]
    update?: AircraftUpdateWithWhereUniqueWithoutAircraftTypeInput | AircraftUpdateWithWhereUniqueWithoutAircraftTypeInput[]
    updateMany?: AircraftUpdateManyWithWhereWithoutAircraftTypeInput | AircraftUpdateManyWithWhereWithoutAircraftTypeInput[]
    deleteMany?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
  }

  export type AircraftTypeCreateNestedOneWithoutAircraftInput = {
    create?: XOR<AircraftTypeCreateWithoutAircraftInput, AircraftTypeUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: AircraftTypeCreateOrConnectWithoutAircraftInput
    connect?: AircraftTypeWhereUniqueInput
  }

  export type AirlineCreateNestedOneWithoutAircraftInput = {
    create?: XOR<AirlineCreateWithoutAircraftInput, AirlineUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutAircraftInput
    connect?: AirlineWhereUniqueInput
  }

  export type FlightCreateNestedManyWithoutAircraftInput = {
    create?: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput> | FlightCreateWithoutAircraftInput[] | FlightUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAircraftInput | FlightCreateOrConnectWithoutAircraftInput[]
    createMany?: FlightCreateManyAircraftInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type FlightUncheckedCreateNestedManyWithoutAircraftInput = {
    create?: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput> | FlightCreateWithoutAircraftInput[] | FlightUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAircraftInput | FlightCreateOrConnectWithoutAircraftInput[]
    createMany?: FlightCreateManyAircraftInputEnvelope
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
  }

  export type AircraftTypeUpdateOneRequiredWithoutAircraftNestedInput = {
    create?: XOR<AircraftTypeCreateWithoutAircraftInput, AircraftTypeUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: AircraftTypeCreateOrConnectWithoutAircraftInput
    upsert?: AircraftTypeUpsertWithoutAircraftInput
    connect?: AircraftTypeWhereUniqueInput
    update?: XOR<XOR<AircraftTypeUpdateToOneWithWhereWithoutAircraftInput, AircraftTypeUpdateWithoutAircraftInput>, AircraftTypeUncheckedUpdateWithoutAircraftInput>
  }

  export type AirlineUpdateOneRequiredWithoutAircraftNestedInput = {
    create?: XOR<AirlineCreateWithoutAircraftInput, AirlineUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutAircraftInput
    upsert?: AirlineUpsertWithoutAircraftInput
    connect?: AirlineWhereUniqueInput
    update?: XOR<XOR<AirlineUpdateToOneWithWhereWithoutAircraftInput, AirlineUpdateWithoutAircraftInput>, AirlineUncheckedUpdateWithoutAircraftInput>
  }

  export type FlightUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput> | FlightCreateWithoutAircraftInput[] | FlightUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAircraftInput | FlightCreateOrConnectWithoutAircraftInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutAircraftInput | FlightUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: FlightCreateManyAircraftInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutAircraftInput | FlightUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutAircraftInput | FlightUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type FlightUncheckedUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput> | FlightCreateWithoutAircraftInput[] | FlightUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: FlightCreateOrConnectWithoutAircraftInput | FlightCreateOrConnectWithoutAircraftInput[]
    upsert?: FlightUpsertWithWhereUniqueWithoutAircraftInput | FlightUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: FlightCreateManyAircraftInputEnvelope
    set?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    disconnect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    delete?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    connect?: FlightWhereUniqueInput | FlightWhereUniqueInput[]
    update?: FlightUpdateWithWhereUniqueWithoutAircraftInput | FlightUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: FlightUpdateManyWithWhereWithoutAircraftInput | FlightUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: FlightScalarWhereInput | FlightScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutDestinationInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutFromDestinationInput = {
    create?: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput> | BookingCreateWithoutFromDestinationInput[] | BookingUncheckedCreateWithoutFromDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFromDestinationInput | BookingCreateOrConnectWithoutFromDestinationInput[]
    createMany?: BookingCreateManyFromDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AirportCreateNestedOneWithoutDestinationsInput = {
    create?: XOR<AirportCreateWithoutDestinationsInput, AirportUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutDestinationsInput
    connect?: AirportWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutDestinationsInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput
    connect?: CityWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutDestinationsInput = {
    create?: XOR<CountryCreateWithoutDestinationsInput, CountryUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDestinationsInput
    connect?: CountryWhereUniqueInput
  }

  export type PromotionCreateNestedManyWithoutDestinationInput = {
    create?: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput> | PromotionCreateWithoutDestinationInput[] | PromotionUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutDestinationInput | PromotionCreateOrConnectWithoutDestinationInput[]
    createMany?: PromotionCreateManyDestinationInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput> | ReviewCreateWithoutDestinationInput[] | ReviewUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDestinationInput | ReviewCreateOrConnectWithoutDestinationInput[]
    createMany?: ReviewCreateManyDestinationInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutFromDestinationInput = {
    create?: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput> | BookingCreateWithoutFromDestinationInput[] | BookingUncheckedCreateWithoutFromDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFromDestinationInput | BookingCreateOrConnectWithoutFromDestinationInput[]
    createMany?: BookingCreateManyFromDestinationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput> | PromotionCreateWithoutDestinationInput[] | PromotionUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutDestinationInput | PromotionCreateOrConnectWithoutDestinationInput[]
    createMany?: PromotionCreateManyDestinationInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput> | ReviewCreateWithoutDestinationInput[] | ReviewUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDestinationInput | ReviewCreateOrConnectWithoutDestinationInput[]
    createMany?: ReviewCreateManyDestinationInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDestinationInput | BookingUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDestinationInput | BookingUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDestinationInput | BookingUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutFromDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput> | BookingCreateWithoutFromDestinationInput[] | BookingUncheckedCreateWithoutFromDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFromDestinationInput | BookingCreateOrConnectWithoutFromDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFromDestinationInput | BookingUpsertWithWhereUniqueWithoutFromDestinationInput[]
    createMany?: BookingCreateManyFromDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFromDestinationInput | BookingUpdateWithWhereUniqueWithoutFromDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFromDestinationInput | BookingUpdateManyWithWhereWithoutFromDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AirportUpdateOneRequiredWithoutDestinationsNestedInput = {
    create?: XOR<AirportCreateWithoutDestinationsInput, AirportUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutDestinationsInput
    upsert?: AirportUpsertWithoutDestinationsInput
    connect?: AirportWhereUniqueInput
    update?: XOR<XOR<AirportUpdateToOneWithWhereWithoutDestinationsInput, AirportUpdateWithoutDestinationsInput>, AirportUncheckedUpdateWithoutDestinationsInput>
  }

  export type CityUpdateOneRequiredWithoutDestinationsNestedInput = {
    create?: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutDestinationsInput
    upsert?: CityUpsertWithoutDestinationsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDestinationsInput, CityUpdateWithoutDestinationsInput>, CityUncheckedUpdateWithoutDestinationsInput>
  }

  export type CountryUpdateOneRequiredWithoutDestinationsNestedInput = {
    create?: XOR<CountryCreateWithoutDestinationsInput, CountryUncheckedCreateWithoutDestinationsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDestinationsInput
    upsert?: CountryUpsertWithoutDestinationsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutDestinationsInput, CountryUpdateWithoutDestinationsInput>, CountryUncheckedUpdateWithoutDestinationsInput>
  }

  export type PromotionUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput> | PromotionCreateWithoutDestinationInput[] | PromotionUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutDestinationInput | PromotionCreateOrConnectWithoutDestinationInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutDestinationInput | PromotionUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: PromotionCreateManyDestinationInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutDestinationInput | PromotionUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutDestinationInput | PromotionUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput> | ReviewCreateWithoutDestinationInput[] | ReviewUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDestinationInput | ReviewCreateOrConnectWithoutDestinationInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutDestinationInput | ReviewUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ReviewCreateManyDestinationInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutDestinationInput | ReviewUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutDestinationInput | ReviewUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput> | BookingCreateWithoutDestinationInput[] | BookingUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDestinationInput | BookingCreateOrConnectWithoutDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDestinationInput | BookingUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: BookingCreateManyDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDestinationInput | BookingUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDestinationInput | BookingUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutFromDestinationNestedInput = {
    create?: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput> | BookingCreateWithoutFromDestinationInput[] | BookingUncheckedCreateWithoutFromDestinationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFromDestinationInput | BookingCreateOrConnectWithoutFromDestinationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFromDestinationInput | BookingUpsertWithWhereUniqueWithoutFromDestinationInput[]
    createMany?: BookingCreateManyFromDestinationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFromDestinationInput | BookingUpdateWithWhereUniqueWithoutFromDestinationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFromDestinationInput | BookingUpdateManyWithWhereWithoutFromDestinationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput> | PromotionCreateWithoutDestinationInput[] | PromotionUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutDestinationInput | PromotionCreateOrConnectWithoutDestinationInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutDestinationInput | PromotionUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: PromotionCreateManyDestinationInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutDestinationInput | PromotionUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutDestinationInput | PromotionUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput> | ReviewCreateWithoutDestinationInput[] | ReviewUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDestinationInput | ReviewCreateOrConnectWithoutDestinationInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutDestinationInput | ReviewUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ReviewCreateManyDestinationInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutDestinationInput | ReviewUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutDestinationInput | ReviewUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutFlightInput = {
    create?: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput> | BookingCreateWithoutFlightInput[] | BookingUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightInput | BookingCreateOrConnectWithoutFlightInput[]
    createMany?: BookingCreateManyFlightInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type FlightScheduleCreateNestedManyWithoutFlightInput = {
    create?: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput> | FlightScheduleCreateWithoutFlightInput[] | FlightScheduleUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutFlightInput | FlightScheduleCreateOrConnectWithoutFlightInput[]
    createMany?: FlightScheduleCreateManyFlightInputEnvelope
    connect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
  }

  export type AircraftCreateNestedOneWithoutFlightsInput = {
    create?: XOR<AircraftCreateWithoutFlightsInput, AircraftUncheckedCreateWithoutFlightsInput>
    connectOrCreate?: AircraftCreateOrConnectWithoutFlightsInput
    connect?: AircraftWhereUniqueInput
  }

  export type AirlineCreateNestedOneWithoutFlightsInput = {
    create?: XOR<AirlineCreateWithoutFlightsInput, AirlineUncheckedCreateWithoutFlightsInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutFlightsInput
    connect?: AirlineWhereUniqueInput
  }

  export type AirportCreateNestedOneWithoutArrivalFlightsInput = {
    create?: XOR<AirportCreateWithoutArrivalFlightsInput, AirportUncheckedCreateWithoutArrivalFlightsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutArrivalFlightsInput
    connect?: AirportWhereUniqueInput
  }

  export type AirportCreateNestedOneWithoutDepartureFlightsInput = {
    create?: XOR<AirportCreateWithoutDepartureFlightsInput, AirportUncheckedCreateWithoutDepartureFlightsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutDepartureFlightsInput
    connect?: AirportWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput> | BookingCreateWithoutFlightInput[] | BookingUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightInput | BookingCreateOrConnectWithoutFlightInput[]
    createMany?: BookingCreateManyFlightInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type FlightScheduleUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput> | FlightScheduleCreateWithoutFlightInput[] | FlightScheduleUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutFlightInput | FlightScheduleCreateOrConnectWithoutFlightInput[]
    createMany?: FlightScheduleCreateManyFlightInputEnvelope
    connect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutFlightNestedInput = {
    create?: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput> | BookingCreateWithoutFlightInput[] | BookingUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightInput | BookingCreateOrConnectWithoutFlightInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFlightInput | BookingUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: BookingCreateManyFlightInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFlightInput | BookingUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFlightInput | BookingUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type FlightScheduleUpdateManyWithoutFlightNestedInput = {
    create?: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput> | FlightScheduleCreateWithoutFlightInput[] | FlightScheduleUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutFlightInput | FlightScheduleCreateOrConnectWithoutFlightInput[]
    upsert?: FlightScheduleUpsertWithWhereUniqueWithoutFlightInput | FlightScheduleUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: FlightScheduleCreateManyFlightInputEnvelope
    set?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    disconnect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    delete?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    connect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    update?: FlightScheduleUpdateWithWhereUniqueWithoutFlightInput | FlightScheduleUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: FlightScheduleUpdateManyWithWhereWithoutFlightInput | FlightScheduleUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: FlightScheduleScalarWhereInput | FlightScheduleScalarWhereInput[]
  }

  export type AircraftUpdateOneRequiredWithoutFlightsNestedInput = {
    create?: XOR<AircraftCreateWithoutFlightsInput, AircraftUncheckedCreateWithoutFlightsInput>
    connectOrCreate?: AircraftCreateOrConnectWithoutFlightsInput
    upsert?: AircraftUpsertWithoutFlightsInput
    connect?: AircraftWhereUniqueInput
    update?: XOR<XOR<AircraftUpdateToOneWithWhereWithoutFlightsInput, AircraftUpdateWithoutFlightsInput>, AircraftUncheckedUpdateWithoutFlightsInput>
  }

  export type AirlineUpdateOneRequiredWithoutFlightsNestedInput = {
    create?: XOR<AirlineCreateWithoutFlightsInput, AirlineUncheckedCreateWithoutFlightsInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutFlightsInput
    upsert?: AirlineUpsertWithoutFlightsInput
    connect?: AirlineWhereUniqueInput
    update?: XOR<XOR<AirlineUpdateToOneWithWhereWithoutFlightsInput, AirlineUpdateWithoutFlightsInput>, AirlineUncheckedUpdateWithoutFlightsInput>
  }

  export type AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput = {
    create?: XOR<AirportCreateWithoutArrivalFlightsInput, AirportUncheckedCreateWithoutArrivalFlightsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutArrivalFlightsInput
    upsert?: AirportUpsertWithoutArrivalFlightsInput
    connect?: AirportWhereUniqueInput
    update?: XOR<XOR<AirportUpdateToOneWithWhereWithoutArrivalFlightsInput, AirportUpdateWithoutArrivalFlightsInput>, AirportUncheckedUpdateWithoutArrivalFlightsInput>
  }

  export type AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput = {
    create?: XOR<AirportCreateWithoutDepartureFlightsInput, AirportUncheckedCreateWithoutDepartureFlightsInput>
    connectOrCreate?: AirportCreateOrConnectWithoutDepartureFlightsInput
    upsert?: AirportUpsertWithoutDepartureFlightsInput
    connect?: AirportWhereUniqueInput
    update?: XOR<XOR<AirportUpdateToOneWithWhereWithoutDepartureFlightsInput, AirportUpdateWithoutDepartureFlightsInput>, AirportUncheckedUpdateWithoutDepartureFlightsInput>
  }

  export type BookingUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput> | BookingCreateWithoutFlightInput[] | BookingUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightInput | BookingCreateOrConnectWithoutFlightInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFlightInput | BookingUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: BookingCreateManyFlightInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFlightInput | BookingUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFlightInput | BookingUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput> | FlightScheduleCreateWithoutFlightInput[] | FlightScheduleUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutFlightInput | FlightScheduleCreateOrConnectWithoutFlightInput[]
    upsert?: FlightScheduleUpsertWithWhereUniqueWithoutFlightInput | FlightScheduleUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: FlightScheduleCreateManyFlightInputEnvelope
    set?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    disconnect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    delete?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    connect?: FlightScheduleWhereUniqueInput | FlightScheduleWhereUniqueInput[]
    update?: FlightScheduleUpdateWithWhereUniqueWithoutFlightInput | FlightScheduleUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: FlightScheduleUpdateManyWithWhereWithoutFlightInput | FlightScheduleUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: FlightScheduleScalarWhereInput | FlightScheduleScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutFlightScheduleInput = {
    create?: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput> | BookingCreateWithoutFlightScheduleInput[] | BookingUncheckedCreateWithoutFlightScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightScheduleInput | BookingCreateOrConnectWithoutFlightScheduleInput[]
    createMany?: BookingCreateManyFlightScheduleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type FlightCreateNestedOneWithoutFlightSchedulesInput = {
    create?: XOR<FlightCreateWithoutFlightSchedulesInput, FlightUncheckedCreateWithoutFlightSchedulesInput>
    connectOrCreate?: FlightCreateOrConnectWithoutFlightSchedulesInput
    connect?: FlightWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutFlightScheduleInput = {
    create?: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput> | BookingCreateWithoutFlightScheduleInput[] | BookingUncheckedCreateWithoutFlightScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightScheduleInput | BookingCreateOrConnectWithoutFlightScheduleInput[]
    createMany?: BookingCreateManyFlightScheduleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUpdateManyWithoutFlightScheduleNestedInput = {
    create?: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput> | BookingCreateWithoutFlightScheduleInput[] | BookingUncheckedCreateWithoutFlightScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightScheduleInput | BookingCreateOrConnectWithoutFlightScheduleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFlightScheduleInput | BookingUpsertWithWhereUniqueWithoutFlightScheduleInput[]
    createMany?: BookingCreateManyFlightScheduleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFlightScheduleInput | BookingUpdateWithWhereUniqueWithoutFlightScheduleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFlightScheduleInput | BookingUpdateManyWithWhereWithoutFlightScheduleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type FlightUpdateOneRequiredWithoutFlightSchedulesNestedInput = {
    create?: XOR<FlightCreateWithoutFlightSchedulesInput, FlightUncheckedCreateWithoutFlightSchedulesInput>
    connectOrCreate?: FlightCreateOrConnectWithoutFlightSchedulesInput
    upsert?: FlightUpsertWithoutFlightSchedulesInput
    connect?: FlightWhereUniqueInput
    update?: XOR<XOR<FlightUpdateToOneWithWhereWithoutFlightSchedulesInput, FlightUpdateWithoutFlightSchedulesInput>, FlightUncheckedUpdateWithoutFlightSchedulesInput>
  }

  export type BookingUncheckedUpdateManyWithoutFlightScheduleNestedInput = {
    create?: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput> | BookingCreateWithoutFlightScheduleInput[] | BookingUncheckedCreateWithoutFlightScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutFlightScheduleInput | BookingCreateOrConnectWithoutFlightScheduleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutFlightScheduleInput | BookingUpsertWithWhereUniqueWithoutFlightScheduleInput[]
    createMany?: BookingCreateManyFlightScheduleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutFlightScheduleInput | BookingUpdateWithWhereUniqueWithoutFlightScheduleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutFlightScheduleInput | BookingUpdateManyWithWhereWithoutFlightScheduleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type DestinationCreateNestedOneWithoutBookingsToInput = {
    create?: XOR<DestinationCreateWithoutBookingsToInput, DestinationUncheckedCreateWithoutBookingsToInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsToInput
    connect?: DestinationWhereUniqueInput
  }

  export type FlightCreateNestedOneWithoutBookingsInput = {
    create?: XOR<FlightCreateWithoutBookingsInput, FlightUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FlightCreateOrConnectWithoutBookingsInput
    connect?: FlightWhereUniqueInput
  }

  export type FlightScheduleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<FlightScheduleCreateWithoutBookingsInput, FlightScheduleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutBookingsInput
    connect?: FlightScheduleWhereUniqueInput
  }

  export type DestinationCreateNestedOneWithoutBookingsFromInput = {
    create?: XOR<DestinationCreateWithoutBookingsFromInput, DestinationUncheckedCreateWithoutBookingsFromInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsFromInput
    connect?: DestinationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PassengerDetailCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput> | PassengerDetailCreateWithoutBookingInput[] | PassengerDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerDetailCreateOrConnectWithoutBookingInput | PassengerDetailCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerDetailCreateManyBookingInputEnvelope
    connect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PassengerDetailUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput> | PassengerDetailCreateWithoutBookingInput[] | PassengerDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerDetailCreateOrConnectWithoutBookingInput | PassengerDetailCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerDetailCreateManyBookingInputEnvelope
    connect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DestinationUpdateOneRequiredWithoutBookingsToNestedInput = {
    create?: XOR<DestinationCreateWithoutBookingsToInput, DestinationUncheckedCreateWithoutBookingsToInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsToInput
    upsert?: DestinationUpsertWithoutBookingsToInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutBookingsToInput, DestinationUpdateWithoutBookingsToInput>, DestinationUncheckedUpdateWithoutBookingsToInput>
  }

  export type FlightUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<FlightCreateWithoutBookingsInput, FlightUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FlightCreateOrConnectWithoutBookingsInput
    upsert?: FlightUpsertWithoutBookingsInput
    disconnect?: FlightWhereInput | boolean
    delete?: FlightWhereInput | boolean
    connect?: FlightWhereUniqueInput
    update?: XOR<XOR<FlightUpdateToOneWithWhereWithoutBookingsInput, FlightUpdateWithoutBookingsInput>, FlightUncheckedUpdateWithoutBookingsInput>
  }

  export type FlightScheduleUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<FlightScheduleCreateWithoutBookingsInput, FlightScheduleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FlightScheduleCreateOrConnectWithoutBookingsInput
    upsert?: FlightScheduleUpsertWithoutBookingsInput
    disconnect?: FlightScheduleWhereInput | boolean
    delete?: FlightScheduleWhereInput | boolean
    connect?: FlightScheduleWhereUniqueInput
    update?: XOR<XOR<FlightScheduleUpdateToOneWithWhereWithoutBookingsInput, FlightScheduleUpdateWithoutBookingsInput>, FlightScheduleUncheckedUpdateWithoutBookingsInput>
  }

  export type DestinationUpdateOneRequiredWithoutBookingsFromNestedInput = {
    create?: XOR<DestinationCreateWithoutBookingsFromInput, DestinationUncheckedCreateWithoutBookingsFromInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutBookingsFromInput
    upsert?: DestinationUpsertWithoutBookingsFromInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutBookingsFromInput, DestinationUpdateWithoutBookingsFromInput>, DestinationUncheckedUpdateWithoutBookingsFromInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type NotificationUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PassengerDetailUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput> | PassengerDetailCreateWithoutBookingInput[] | PassengerDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerDetailCreateOrConnectWithoutBookingInput | PassengerDetailCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerDetailUpsertWithWhereUniqueWithoutBookingInput | PassengerDetailUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerDetailCreateManyBookingInputEnvelope
    set?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    disconnect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    delete?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    connect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    update?: PassengerDetailUpdateWithWhereUniqueWithoutBookingInput | PassengerDetailUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerDetailUpdateManyWithWhereWithoutBookingInput | PassengerDetailUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerDetailScalarWhereInput | PassengerDetailScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput> | PassengerDetailCreateWithoutBookingInput[] | PassengerDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerDetailCreateOrConnectWithoutBookingInput | PassengerDetailCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerDetailUpsertWithWhereUniqueWithoutBookingInput | PassengerDetailUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerDetailCreateManyBookingInputEnvelope
    set?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    disconnect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    delete?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    connect?: PassengerDetailWhereUniqueInput | PassengerDetailWhereUniqueInput[]
    update?: PassengerDetailUpdateWithWhereUniqueWithoutBookingInput | PassengerDetailUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerDetailUpdateManyWithWhereWithoutBookingInput | PassengerDetailUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerDetailScalarWhereInput | PassengerDetailScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPassengersInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    upsert?: BookingUpsertWithoutPassengersInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPassengersInput, BookingUpdateWithoutPassengersInput>, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type DestinationCreateNestedOneWithoutReviewsInput = {
    create?: XOR<DestinationCreateWithoutReviewsInput, DestinationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutReviewsInput
    connect?: DestinationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type DestinationUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<DestinationCreateWithoutReviewsInput, DestinationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutReviewsInput
    upsert?: DestinationUpsertWithoutReviewsInput
    disconnect?: DestinationWhereInput | boolean
    delete?: DestinationWhereInput | boolean
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutReviewsInput, DestinationUpdateWithoutReviewsInput>, DestinationUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type DestinationCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<DestinationCreateWithoutPromotionsInput, DestinationUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutPromotionsInput
    connect?: DestinationWhereUniqueInput
  }

  export type DestinationUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<DestinationCreateWithoutPromotionsInput, DestinationUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutPromotionsInput
    upsert?: DestinationUpsertWithoutPromotionsInput
    disconnect?: DestinationWhereInput | boolean
    delete?: DestinationWhereInput | boolean
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutPromotionsInput, DestinationUpdateWithoutPromotionsInput>, DestinationUncheckedUpdateWithoutPromotionsInput>
  }

  export type BookingCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    upsert?: BookingUpsertWithoutNotificationsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutNotificationsInput, BookingUpdateWithoutNotificationsInput>, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type AirlineCreateNestedOneWithoutAdminFlightSchedulesInput = {
    create?: XOR<AirlineCreateWithoutAdminFlightSchedulesInput, AirlineUncheckedCreateWithoutAdminFlightSchedulesInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutAdminFlightSchedulesInput
    connect?: AirlineWhereUniqueInput
  }

  export type AirlineUpdateOneRequiredWithoutAdminFlightSchedulesNestedInput = {
    create?: XOR<AirlineCreateWithoutAdminFlightSchedulesInput, AirlineUncheckedCreateWithoutAdminFlightSchedulesInput>
    connectOrCreate?: AirlineCreateOrConnectWithoutAdminFlightSchedulesInput
    upsert?: AirlineUpsertWithoutAdminFlightSchedulesInput
    connect?: AirlineWhereUniqueInput
    update?: XOR<XOR<AirlineUpdateToOneWithWhereWithoutAdminFlightSchedulesInput, AirlineUpdateWithoutAdminFlightSchedulesInput>, AirlineUncheckedUpdateWithoutAdminFlightSchedulesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    bookingReference: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    bookingId?: string | null
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destination?: DestinationCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    destinationId?: string | null
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookingReference?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    flightId?: StringNullableFilter<"Booking"> | string | null
    flightScheduleId?: StringNullableFilter<"Booking"> | string | null
    destinationId?: StringFilter<"Booking"> | string
    fromDestinationId?: StringFilter<"Booking"> | string
    departureDate?: DateTimeFilter<"Booking"> | Date | string
    returnDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    passengerCount?: IntFilter<"Booking"> | number
    bookingClass?: StringFilter<"Booking"> | string
    totalPrice?: FloatFilter<"Booking"> | number
    taxes?: FloatFilter<"Booking"> | number
    fees?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    finalPrice?: FloatFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    bookingId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentProvider?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failedReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    destinationId?: StringNullableFilter<"Review"> | string | null
    bookingId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isVerified?: BoolFilter<"Review"> | boolean
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type AirlineCreateWithoutCountryInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftCreateNestedManyWithoutAirlineInput
    flights?: FlightCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftUncheckedCreateNestedManyWithoutAirlineInput
    flights?: FlightUncheckedCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type AirlineCreateOrConnectWithoutCountryInput = {
    where: AirlineWhereUniqueInput
    create: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput>
  }

  export type AirlineCreateManyCountryInputEnvelope = {
    data: AirlineCreateManyCountryInput | AirlineCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type AirportCreateWithoutCountryInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAirportsInput
    destinations?: DestinationCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightUncheckedCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightUncheckedCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportCreateOrConnectWithoutCountryInput = {
    where: AirportWhereUniqueInput
    create: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput>
  }

  export type AirportCreateManyCountryInputEnvelope = {
    data: AirportCreateManyCountryInput | AirportCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutCountryInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportCreateNestedManyWithoutCityInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportUncheckedCreateNestedManyWithoutCityInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type DestinationCreateWithoutCountryInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    cityId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutCountryInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput>
  }

  export type DestinationCreateManyCountryInputEnvelope = {
    data: DestinationCreateManyCountryInput | DestinationCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type AirlineUpsertWithWhereUniqueWithoutCountryInput = {
    where: AirlineWhereUniqueInput
    update: XOR<AirlineUpdateWithoutCountryInput, AirlineUncheckedUpdateWithoutCountryInput>
    create: XOR<AirlineCreateWithoutCountryInput, AirlineUncheckedCreateWithoutCountryInput>
  }

  export type AirlineUpdateWithWhereUniqueWithoutCountryInput = {
    where: AirlineWhereUniqueInput
    data: XOR<AirlineUpdateWithoutCountryInput, AirlineUncheckedUpdateWithoutCountryInput>
  }

  export type AirlineUpdateManyWithWhereWithoutCountryInput = {
    where: AirlineScalarWhereInput
    data: XOR<AirlineUpdateManyMutationInput, AirlineUncheckedUpdateManyWithoutCountryInput>
  }

  export type AirlineScalarWhereInput = {
    AND?: AirlineScalarWhereInput | AirlineScalarWhereInput[]
    OR?: AirlineScalarWhereInput[]
    NOT?: AirlineScalarWhereInput | AirlineScalarWhereInput[]
    id?: StringFilter<"Airline"> | string
    name?: StringFilter<"Airline"> | string
    code?: StringFilter<"Airline"> | string
    icaoCode?: StringNullableFilter<"Airline"> | string | null
    countryId?: StringFilter<"Airline"> | string
    logo?: StringNullableFilter<"Airline"> | string | null
    description?: StringNullableFilter<"Airline"> | string | null
    website?: StringNullableFilter<"Airline"> | string | null
    isActive?: BoolFilter<"Airline"> | boolean
    createdAt?: DateTimeFilter<"Airline"> | Date | string
    updatedAt?: DateTimeFilter<"Airline"> | Date | string
  }

  export type AirportUpsertWithWhereUniqueWithoutCountryInput = {
    where: AirportWhereUniqueInput
    update: XOR<AirportUpdateWithoutCountryInput, AirportUncheckedUpdateWithoutCountryInput>
    create: XOR<AirportCreateWithoutCountryInput, AirportUncheckedCreateWithoutCountryInput>
  }

  export type AirportUpdateWithWhereUniqueWithoutCountryInput = {
    where: AirportWhereUniqueInput
    data: XOR<AirportUpdateWithoutCountryInput, AirportUncheckedUpdateWithoutCountryInput>
  }

  export type AirportUpdateManyWithWhereWithoutCountryInput = {
    where: AirportScalarWhereInput
    data: XOR<AirportUpdateManyMutationInput, AirportUncheckedUpdateManyWithoutCountryInput>
  }

  export type AirportScalarWhereInput = {
    AND?: AirportScalarWhereInput | AirportScalarWhereInput[]
    OR?: AirportScalarWhereInput[]
    NOT?: AirportScalarWhereInput | AirportScalarWhereInput[]
    id?: StringFilter<"Airport"> | string
    name?: StringFilter<"Airport"> | string
    iataCode?: StringNullableFilter<"Airport"> | string | null
    icaoCode?: StringNullableFilter<"Airport"> | string | null
    cityId?: StringFilter<"Airport"> | string
    countryId?: StringFilter<"Airport"> | string
    municipality?: StringNullableFilter<"Airport"> | string | null
    lat?: FloatNullableFilter<"Airport"> | number | null
    lon?: FloatNullableFilter<"Airport"> | number | null
    elevation?: IntNullableFilter<"Airport"> | number | null
    timezone?: StringNullableFilter<"Airport"> | string | null
    isActive?: BoolFilter<"Airport"> | boolean
    createdAt?: DateTimeFilter<"Airport"> | Date | string
    updatedAt?: DateTimeFilter<"Airport"> | Date | string
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    state?: StringNullableFilter<"City"> | string | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    lat?: FloatNullableFilter<"City"> | number | null
    lon?: FloatNullableFilter<"City"> | number | null
    isActive?: BoolFilter<"City"> | boolean
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
  }

  export type DestinationUpsertWithWhereUniqueWithoutCountryInput = {
    where: DestinationWhereUniqueInput
    update: XOR<DestinationUpdateWithoutCountryInput, DestinationUncheckedUpdateWithoutCountryInput>
    create: XOR<DestinationCreateWithoutCountryInput, DestinationUncheckedCreateWithoutCountryInput>
  }

  export type DestinationUpdateWithWhereUniqueWithoutCountryInput = {
    where: DestinationWhereUniqueInput
    data: XOR<DestinationUpdateWithoutCountryInput, DestinationUncheckedUpdateWithoutCountryInput>
  }

  export type DestinationUpdateManyWithWhereWithoutCountryInput = {
    where: DestinationScalarWhereInput
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyWithoutCountryInput>
  }

  export type DestinationScalarWhereInput = {
    AND?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
    OR?: DestinationScalarWhereInput[]
    NOT?: DestinationScalarWhereInput | DestinationScalarWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    cityId?: StringFilter<"Destination"> | string
    countryId?: StringFilter<"Destination"> | string
    airportId?: StringFilter<"Destination"> | string
    description?: StringNullableFilter<"Destination"> | string | null
    imageUrl?: StringNullableFilter<"Destination"> | string | null
    category?: StringFilter<"Destination"> | string
    rating?: FloatNullableFilter<"Destination"> | number | null
    isActive?: BoolFilter<"Destination"> | boolean
    isFeatured?: BoolFilter<"Destination"> | boolean
    createdAt?: DateTimeFilter<"Destination"> | Date | string
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
  }

  export type AirportCreateWithoutCityInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutAirportsInput
    destinations?: DestinationCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightUncheckedCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightUncheckedCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportCreateOrConnectWithoutCityInput = {
    where: AirportWhereUniqueInput
    create: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput>
  }

  export type AirportCreateManyCityInputEnvelope = {
    data: AirportCreateManyCityInput | AirportCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutCitiesInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineCreateNestedManyWithoutCountryInput
    airports?: AirportCreateNestedManyWithoutCountryInput
    destinations?: DestinationCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineUncheckedCreateNestedManyWithoutCountryInput
    airports?: AirportUncheckedCreateNestedManyWithoutCountryInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type DestinationCreateWithoutCityInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutCityInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput>
  }

  export type DestinationCreateManyCityInputEnvelope = {
    data: DestinationCreateManyCityInput | DestinationCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type AirportUpsertWithWhereUniqueWithoutCityInput = {
    where: AirportWhereUniqueInput
    update: XOR<AirportUpdateWithoutCityInput, AirportUncheckedUpdateWithoutCityInput>
    create: XOR<AirportCreateWithoutCityInput, AirportUncheckedCreateWithoutCityInput>
  }

  export type AirportUpdateWithWhereUniqueWithoutCityInput = {
    where: AirportWhereUniqueInput
    data: XOR<AirportUpdateWithoutCityInput, AirportUncheckedUpdateWithoutCityInput>
  }

  export type AirportUpdateManyWithWhereWithoutCityInput = {
    where: AirportScalarWhereInput
    data: XOR<AirportUpdateManyMutationInput, AirportUncheckedUpdateManyWithoutCityInput>
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUpdateManyWithoutCountryNestedInput
    airports?: AirportUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUncheckedUpdateManyWithoutCountryNestedInput
    airports?: AirportUncheckedUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type DestinationUpsertWithWhereUniqueWithoutCityInput = {
    where: DestinationWhereUniqueInput
    update: XOR<DestinationUpdateWithoutCityInput, DestinationUncheckedUpdateWithoutCityInput>
    create: XOR<DestinationCreateWithoutCityInput, DestinationUncheckedCreateWithoutCityInput>
  }

  export type DestinationUpdateWithWhereUniqueWithoutCityInput = {
    where: DestinationWhereUniqueInput
    data: XOR<DestinationUpdateWithoutCityInput, DestinationUncheckedUpdateWithoutCityInput>
  }

  export type DestinationUpdateManyWithWhereWithoutCityInput = {
    where: DestinationScalarWhereInput
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyWithoutCityInput>
  }

  export type CityCreateWithoutAirportsInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutCitiesInput
    destinations?: DestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAirportsInput = {
    id?: string
    name: string
    countryId: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAirportsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAirportsInput, CityUncheckedCreateWithoutAirportsInput>
  }

  export type CountryCreateWithoutAirportsInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineCreateNestedManyWithoutCountryInput
    cities?: CityCreateNestedManyWithoutCountryInput
    destinations?: DestinationCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutAirportsInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineUncheckedCreateNestedManyWithoutCountryInput
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutAirportsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAirportsInput, CountryUncheckedCreateWithoutAirportsInput>
  }

  export type DestinationCreateWithoutAirportInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutAirportInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutAirportInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput>
  }

  export type DestinationCreateManyAirportInputEnvelope = {
    data: DestinationCreateManyAirportInput | DestinationCreateManyAirportInput[]
    skipDuplicates?: boolean
  }

  export type FlightCreateWithoutArrivalAirportInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateWithoutArrivalAirportInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutArrivalAirportInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput>
  }

  export type FlightCreateManyArrivalAirportInputEnvelope = {
    data: FlightCreateManyArrivalAirportInput | FlightCreateManyArrivalAirportInput[]
    skipDuplicates?: boolean
  }

  export type FlightCreateWithoutDepartureAirportInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
  }

  export type FlightUncheckedCreateWithoutDepartureAirportInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutDepartureAirportInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput>
  }

  export type FlightCreateManyDepartureAirportInputEnvelope = {
    data: FlightCreateManyDepartureAirportInput | FlightCreateManyDepartureAirportInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutAirportsInput = {
    update: XOR<CityUpdateWithoutAirportsInput, CityUncheckedUpdateWithoutAirportsInput>
    create: XOR<CityCreateWithoutAirportsInput, CityUncheckedCreateWithoutAirportsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAirportsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAirportsInput, CityUncheckedUpdateWithoutAirportsInput>
  }

  export type CityUpdateWithoutAirportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAirportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CountryUpsertWithoutAirportsInput = {
    update: XOR<CountryUpdateWithoutAirportsInput, CountryUncheckedUpdateWithoutAirportsInput>
    create: XOR<CountryCreateWithoutAirportsInput, CountryUncheckedCreateWithoutAirportsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutAirportsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutAirportsInput, CountryUncheckedUpdateWithoutAirportsInput>
  }

  export type CountryUpdateWithoutAirportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUpdateManyWithoutCountryNestedInput
    cities?: CityUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutAirportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUncheckedUpdateManyWithoutCountryNestedInput
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type DestinationUpsertWithWhereUniqueWithoutAirportInput = {
    where: DestinationWhereUniqueInput
    update: XOR<DestinationUpdateWithoutAirportInput, DestinationUncheckedUpdateWithoutAirportInput>
    create: XOR<DestinationCreateWithoutAirportInput, DestinationUncheckedCreateWithoutAirportInput>
  }

  export type DestinationUpdateWithWhereUniqueWithoutAirportInput = {
    where: DestinationWhereUniqueInput
    data: XOR<DestinationUpdateWithoutAirportInput, DestinationUncheckedUpdateWithoutAirportInput>
  }

  export type DestinationUpdateManyWithWhereWithoutAirportInput = {
    where: DestinationScalarWhereInput
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyWithoutAirportInput>
  }

  export type FlightUpsertWithWhereUniqueWithoutArrivalAirportInput = {
    where: FlightWhereUniqueInput
    update: XOR<FlightUpdateWithoutArrivalAirportInput, FlightUncheckedUpdateWithoutArrivalAirportInput>
    create: XOR<FlightCreateWithoutArrivalAirportInput, FlightUncheckedCreateWithoutArrivalAirportInput>
  }

  export type FlightUpdateWithWhereUniqueWithoutArrivalAirportInput = {
    where: FlightWhereUniqueInput
    data: XOR<FlightUpdateWithoutArrivalAirportInput, FlightUncheckedUpdateWithoutArrivalAirportInput>
  }

  export type FlightUpdateManyWithWhereWithoutArrivalAirportInput = {
    where: FlightScalarWhereInput
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyWithoutArrivalAirportInput>
  }

  export type FlightScalarWhereInput = {
    AND?: FlightScalarWhereInput | FlightScalarWhereInput[]
    OR?: FlightScalarWhereInput[]
    NOT?: FlightScalarWhereInput | FlightScalarWhereInput[]
    id?: StringFilter<"Flight"> | string
    flightNumber?: StringFilter<"Flight"> | string
    airlineId?: StringFilter<"Flight"> | string
    aircraftId?: StringFilter<"Flight"> | string
    departureAirportId?: StringFilter<"Flight"> | string
    arrivalAirportId?: StringFilter<"Flight"> | string
    departureTime?: DateTimeFilter<"Flight"> | Date | string
    arrivalTime?: DateTimeFilter<"Flight"> | Date | string
    duration?: IntFilter<"Flight"> | number
    distance?: IntNullableFilter<"Flight"> | number | null
    status?: StringFilter<"Flight"> | string
    gate?: StringNullableFilter<"Flight"> | string | null
    terminal?: StringNullableFilter<"Flight"> | string | null
    isActive?: BoolFilter<"Flight"> | boolean
    createdAt?: DateTimeFilter<"Flight"> | Date | string
    updatedAt?: DateTimeFilter<"Flight"> | Date | string
  }

  export type FlightUpsertWithWhereUniqueWithoutDepartureAirportInput = {
    where: FlightWhereUniqueInput
    update: XOR<FlightUpdateWithoutDepartureAirportInput, FlightUncheckedUpdateWithoutDepartureAirportInput>
    create: XOR<FlightCreateWithoutDepartureAirportInput, FlightUncheckedCreateWithoutDepartureAirportInput>
  }

  export type FlightUpdateWithWhereUniqueWithoutDepartureAirportInput = {
    where: FlightWhereUniqueInput
    data: XOR<FlightUpdateWithoutDepartureAirportInput, FlightUncheckedUpdateWithoutDepartureAirportInput>
  }

  export type FlightUpdateManyWithWhereWithoutDepartureAirportInput = {
    where: FlightScalarWhereInput
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyWithoutDepartureAirportInput>
  }

  export type AircraftCreateWithoutAirlineInput = {
    id?: string
    registration: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraftType: AircraftTypeCreateNestedOneWithoutAircraftInput
    flights?: FlightCreateNestedManyWithoutAircraftInput
  }

  export type AircraftUncheckedCreateWithoutAirlineInput = {
    id?: string
    registration: string
    aircraftTypeId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flights?: FlightUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type AircraftCreateOrConnectWithoutAirlineInput = {
    where: AircraftWhereUniqueInput
    create: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput>
  }

  export type AircraftCreateManyAirlineInputEnvelope = {
    data: AircraftCreateManyAirlineInput | AircraftCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutAirlinesInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportCreateNestedManyWithoutCountryInput
    cities?: CityCreateNestedManyWithoutCountryInput
    destinations?: DestinationCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutAirlinesInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportUncheckedCreateNestedManyWithoutCountryInput
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    destinations?: DestinationUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutAirlinesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAirlinesInput, CountryUncheckedCreateWithoutAirlinesInput>
  }

  export type FlightCreateWithoutAirlineInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateWithoutAirlineInput = {
    id?: string
    flightNumber: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutAirlineInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput>
  }

  export type FlightCreateManyAirlineInputEnvelope = {
    data: FlightCreateManyAirlineInput | FlightCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type AdminFlightScheduleCreateWithoutAirlineInput = {
    id?: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminFlightScheduleUncheckedCreateWithoutAirlineInput = {
    id?: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminFlightScheduleCreateOrConnectWithoutAirlineInput = {
    where: AdminFlightScheduleWhereUniqueInput
    create: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput>
  }

  export type AdminFlightScheduleCreateManyAirlineInputEnvelope = {
    data: AdminFlightScheduleCreateManyAirlineInput | AdminFlightScheduleCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type AircraftUpsertWithWhereUniqueWithoutAirlineInput = {
    where: AircraftWhereUniqueInput
    update: XOR<AircraftUpdateWithoutAirlineInput, AircraftUncheckedUpdateWithoutAirlineInput>
    create: XOR<AircraftCreateWithoutAirlineInput, AircraftUncheckedCreateWithoutAirlineInput>
  }

  export type AircraftUpdateWithWhereUniqueWithoutAirlineInput = {
    where: AircraftWhereUniqueInput
    data: XOR<AircraftUpdateWithoutAirlineInput, AircraftUncheckedUpdateWithoutAirlineInput>
  }

  export type AircraftUpdateManyWithWhereWithoutAirlineInput = {
    where: AircraftScalarWhereInput
    data: XOR<AircraftUpdateManyMutationInput, AircraftUncheckedUpdateManyWithoutAirlineInput>
  }

  export type AircraftScalarWhereInput = {
    AND?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
    OR?: AircraftScalarWhereInput[]
    NOT?: AircraftScalarWhereInput | AircraftScalarWhereInput[]
    id?: StringFilter<"Aircraft"> | string
    registration?: StringFilter<"Aircraft"> | string
    airlineId?: StringFilter<"Aircraft"> | string
    aircraftTypeId?: StringFilter<"Aircraft"> | string
    name?: StringNullableFilter<"Aircraft"> | string | null
    isActive?: BoolFilter<"Aircraft"> | boolean
    createdAt?: DateTimeFilter<"Aircraft"> | Date | string
    updatedAt?: DateTimeFilter<"Aircraft"> | Date | string
  }

  export type CountryUpsertWithoutAirlinesInput = {
    update: XOR<CountryUpdateWithoutAirlinesInput, CountryUncheckedUpdateWithoutAirlinesInput>
    create: XOR<CountryCreateWithoutAirlinesInput, CountryUncheckedCreateWithoutAirlinesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutAirlinesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutAirlinesInput, CountryUncheckedUpdateWithoutAirlinesInput>
  }

  export type CountryUpdateWithoutAirlinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUpdateManyWithoutCountryNestedInput
    cities?: CityUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutAirlinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUncheckedUpdateManyWithoutCountryNestedInput
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type FlightUpsertWithWhereUniqueWithoutAirlineInput = {
    where: FlightWhereUniqueInput
    update: XOR<FlightUpdateWithoutAirlineInput, FlightUncheckedUpdateWithoutAirlineInput>
    create: XOR<FlightCreateWithoutAirlineInput, FlightUncheckedCreateWithoutAirlineInput>
  }

  export type FlightUpdateWithWhereUniqueWithoutAirlineInput = {
    where: FlightWhereUniqueInput
    data: XOR<FlightUpdateWithoutAirlineInput, FlightUncheckedUpdateWithoutAirlineInput>
  }

  export type FlightUpdateManyWithWhereWithoutAirlineInput = {
    where: FlightScalarWhereInput
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyWithoutAirlineInput>
  }

  export type AdminFlightScheduleUpsertWithWhereUniqueWithoutAirlineInput = {
    where: AdminFlightScheduleWhereUniqueInput
    update: XOR<AdminFlightScheduleUpdateWithoutAirlineInput, AdminFlightScheduleUncheckedUpdateWithoutAirlineInput>
    create: XOR<AdminFlightScheduleCreateWithoutAirlineInput, AdminFlightScheduleUncheckedCreateWithoutAirlineInput>
  }

  export type AdminFlightScheduleUpdateWithWhereUniqueWithoutAirlineInput = {
    where: AdminFlightScheduleWhereUniqueInput
    data: XOR<AdminFlightScheduleUpdateWithoutAirlineInput, AdminFlightScheduleUncheckedUpdateWithoutAirlineInput>
  }

  export type AdminFlightScheduleUpdateManyWithWhereWithoutAirlineInput = {
    where: AdminFlightScheduleScalarWhereInput
    data: XOR<AdminFlightScheduleUpdateManyMutationInput, AdminFlightScheduleUncheckedUpdateManyWithoutAirlineInput>
  }

  export type AdminFlightScheduleScalarWhereInput = {
    AND?: AdminFlightScheduleScalarWhereInput | AdminFlightScheduleScalarWhereInput[]
    OR?: AdminFlightScheduleScalarWhereInput[]
    NOT?: AdminFlightScheduleScalarWhereInput | AdminFlightScheduleScalarWhereInput[]
    id?: StringFilter<"AdminFlightSchedule"> | string
    airlineId?: StringFilter<"AdminFlightSchedule"> | string
    flightNo?: StringFilter<"AdminFlightSchedule"> | string
    origin?: StringFilter<"AdminFlightSchedule"> | string
    destination?: StringFilter<"AdminFlightSchedule"> | string
    departure?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    arrival?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    basePrice?: FloatFilter<"AdminFlightSchedule"> | number
    seats?: IntFilter<"AdminFlightSchedule"> | number
    status?: StringFilter<"AdminFlightSchedule"> | string
    createdAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AdminFlightSchedule"> | Date | string
  }

  export type AircraftCreateWithoutAircraftTypeInput = {
    id?: string
    registration: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airline: AirlineCreateNestedOneWithoutAircraftInput
    flights?: FlightCreateNestedManyWithoutAircraftInput
  }

  export type AircraftUncheckedCreateWithoutAircraftTypeInput = {
    id?: string
    registration: string
    airlineId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flights?: FlightUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type AircraftCreateOrConnectWithoutAircraftTypeInput = {
    where: AircraftWhereUniqueInput
    create: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput>
  }

  export type AircraftCreateManyAircraftTypeInputEnvelope = {
    data: AircraftCreateManyAircraftTypeInput | AircraftCreateManyAircraftTypeInput[]
    skipDuplicates?: boolean
  }

  export type AircraftUpsertWithWhereUniqueWithoutAircraftTypeInput = {
    where: AircraftWhereUniqueInput
    update: XOR<AircraftUpdateWithoutAircraftTypeInput, AircraftUncheckedUpdateWithoutAircraftTypeInput>
    create: XOR<AircraftCreateWithoutAircraftTypeInput, AircraftUncheckedCreateWithoutAircraftTypeInput>
  }

  export type AircraftUpdateWithWhereUniqueWithoutAircraftTypeInput = {
    where: AircraftWhereUniqueInput
    data: XOR<AircraftUpdateWithoutAircraftTypeInput, AircraftUncheckedUpdateWithoutAircraftTypeInput>
  }

  export type AircraftUpdateManyWithWhereWithoutAircraftTypeInput = {
    where: AircraftScalarWhereInput
    data: XOR<AircraftUpdateManyMutationInput, AircraftUncheckedUpdateManyWithoutAircraftTypeInput>
  }

  export type AircraftTypeCreateWithoutAircraftInput = {
    id?: string
    manufacturer: string
    model: string
    variant?: string | null
    capacity: number
    range?: number | null
    cruiseSpeed?: number | null
    fuelCapacity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftTypeUncheckedCreateWithoutAircraftInput = {
    id?: string
    manufacturer: string
    model: string
    variant?: string | null
    capacity: number
    range?: number | null
    cruiseSpeed?: number | null
    fuelCapacity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftTypeCreateOrConnectWithoutAircraftInput = {
    where: AircraftTypeWhereUniqueInput
    create: XOR<AircraftTypeCreateWithoutAircraftInput, AircraftTypeUncheckedCreateWithoutAircraftInput>
  }

  export type AirlineCreateWithoutAircraftInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    country: CountryCreateNestedOneWithoutAirlinesInput
    flights?: FlightCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUncheckedCreateWithoutAircraftInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    countryId: string
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flights?: FlightUncheckedCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type AirlineCreateOrConnectWithoutAircraftInput = {
    where: AirlineWhereUniqueInput
    create: XOR<AirlineCreateWithoutAircraftInput, AirlineUncheckedCreateWithoutAircraftInput>
  }

  export type FlightCreateWithoutAircraftInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateWithoutAircraftInput = {
    id?: string
    flightNumber: string
    airlineId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutAircraftInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput>
  }

  export type FlightCreateManyAircraftInputEnvelope = {
    data: FlightCreateManyAircraftInput | FlightCreateManyAircraftInput[]
    skipDuplicates?: boolean
  }

  export type AircraftTypeUpsertWithoutAircraftInput = {
    update: XOR<AircraftTypeUpdateWithoutAircraftInput, AircraftTypeUncheckedUpdateWithoutAircraftInput>
    create: XOR<AircraftTypeCreateWithoutAircraftInput, AircraftTypeUncheckedCreateWithoutAircraftInput>
    where?: AircraftTypeWhereInput
  }

  export type AircraftTypeUpdateToOneWithWhereWithoutAircraftInput = {
    where?: AircraftTypeWhereInput
    data: XOR<AircraftTypeUpdateWithoutAircraftInput, AircraftTypeUncheckedUpdateWithoutAircraftInput>
  }

  export type AircraftTypeUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftTypeUncheckedUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    range?: NullableIntFieldUpdateOperationsInput | number | null
    cruiseSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    fuelCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirlineUpsertWithoutAircraftInput = {
    update: XOR<AirlineUpdateWithoutAircraftInput, AirlineUncheckedUpdateWithoutAircraftInput>
    create: XOR<AirlineCreateWithoutAircraftInput, AirlineUncheckedCreateWithoutAircraftInput>
    where?: AirlineWhereInput
  }

  export type AirlineUpdateToOneWithWhereWithoutAircraftInput = {
    where?: AirlineWhereInput
    data: XOR<AirlineUpdateWithoutAircraftInput, AirlineUncheckedUpdateWithoutAircraftInput>
  }

  export type AirlineUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutAirlinesNestedInput
    flights?: FlightUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flights?: FlightUncheckedUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type FlightUpsertWithWhereUniqueWithoutAircraftInput = {
    where: FlightWhereUniqueInput
    update: XOR<FlightUpdateWithoutAircraftInput, FlightUncheckedUpdateWithoutAircraftInput>
    create: XOR<FlightCreateWithoutAircraftInput, FlightUncheckedCreateWithoutAircraftInput>
  }

  export type FlightUpdateWithWhereUniqueWithoutAircraftInput = {
    where: FlightWhereUniqueInput
    data: XOR<FlightUpdateWithoutAircraftInput, FlightUncheckedUpdateWithoutAircraftInput>
  }

  export type FlightUpdateManyWithWhereWithoutAircraftInput = {
    where: FlightScalarWhereInput
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyWithoutAircraftInput>
  }

  export type BookingCreateWithoutDestinationInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutDestinationInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput>
  }

  export type BookingCreateManyDestinationInputEnvelope = {
    data: BookingCreateManyDestinationInput | BookingCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutFromDestinationInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutFromDestinationInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutFromDestinationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput>
  }

  export type BookingCreateManyFromDestinationInputEnvelope = {
    data: BookingCreateManyFromDestinationInput | BookingCreateManyFromDestinationInput[]
    skipDuplicates?: boolean
  }

  export type AirportCreateWithoutDestinationsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAirportsInput
    country: CountryCreateNestedOneWithoutAirportsInput
    arrivalFlights?: FlightCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUncheckedCreateWithoutDestinationsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    arrivalFlights?: FlightUncheckedCreateNestedManyWithoutArrivalAirportInput
    departureFlights?: FlightUncheckedCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportCreateOrConnectWithoutDestinationsInput = {
    where: AirportWhereUniqueInput
    create: XOR<AirportCreateWithoutDestinationsInput, AirportUncheckedCreateWithoutDestinationsInput>
  }

  export type CityCreateWithoutDestinationsInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportCreateNestedManyWithoutCityInput
    country: CountryCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutDestinationsInput = {
    id?: string
    name: string
    countryId: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airports?: AirportUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDestinationsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
  }

  export type CountryCreateWithoutDestinationsInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineCreateNestedManyWithoutCountryInput
    airports?: AirportCreateNestedManyWithoutCountryInput
    cities?: CityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutDestinationsInput = {
    id?: string
    name: string
    code: string
    continent: string
    currency: string
    timezone: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    airlines?: AirlineUncheckedCreateNestedManyWithoutCountryInput
    airports?: AirportUncheckedCreateNestedManyWithoutCountryInput
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutDestinationsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutDestinationsInput, CountryUncheckedCreateWithoutDestinationsInput>
  }

  export type PromotionCreateWithoutDestinationInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutDestinationInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutDestinationInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput>
  }

  export type PromotionCreateManyDestinationInputEnvelope = {
    data: PromotionCreateManyDestinationInput | PromotionCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutDestinationInput = {
    id?: string
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutDestinationInput = {
    id?: string
    userId: string
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutDestinationInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput>
  }

  export type ReviewCreateManyDestinationInputEnvelope = {
    data: ReviewCreateManyDestinationInput | ReviewCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDestinationInput, BookingUncheckedUpdateWithoutDestinationInput>
    create: XOR<BookingCreateWithoutDestinationInput, BookingUncheckedCreateWithoutDestinationInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDestinationInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDestinationInput, BookingUncheckedUpdateWithoutDestinationInput>
  }

  export type BookingUpdateManyWithWhereWithoutDestinationInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDestinationInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutFromDestinationInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutFromDestinationInput, BookingUncheckedUpdateWithoutFromDestinationInput>
    create: XOR<BookingCreateWithoutFromDestinationInput, BookingUncheckedCreateWithoutFromDestinationInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutFromDestinationInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutFromDestinationInput, BookingUncheckedUpdateWithoutFromDestinationInput>
  }

  export type BookingUpdateManyWithWhereWithoutFromDestinationInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutFromDestinationInput>
  }

  export type AirportUpsertWithoutDestinationsInput = {
    update: XOR<AirportUpdateWithoutDestinationsInput, AirportUncheckedUpdateWithoutDestinationsInput>
    create: XOR<AirportCreateWithoutDestinationsInput, AirportUncheckedCreateWithoutDestinationsInput>
    where?: AirportWhereInput
  }

  export type AirportUpdateToOneWithWhereWithoutDestinationsInput = {
    where?: AirportWhereInput
    data: XOR<AirportUpdateWithoutDestinationsInput, AirportUncheckedUpdateWithoutDestinationsInput>
  }

  export type AirportUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAirportsNestedInput
    country?: CountryUpdateOneRequiredWithoutAirportsNestedInput
    arrivalFlights?: FlightUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalFlights?: FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput
  }

  export type CityUpsertWithoutDestinationsInput = {
    update: XOR<CityUpdateWithoutDestinationsInput, CityUncheckedUpdateWithoutDestinationsInput>
    create: XOR<CityCreateWithoutDestinationsInput, CityUncheckedCreateWithoutDestinationsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDestinationsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDestinationsInput, CityUncheckedUpdateWithoutDestinationsInput>
  }

  export type CityUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUpdateManyWithoutCityNestedInput
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CountryUpsertWithoutDestinationsInput = {
    update: XOR<CountryUpdateWithoutDestinationsInput, CountryUncheckedUpdateWithoutDestinationsInput>
    create: XOR<CountryCreateWithoutDestinationsInput, CountryUncheckedCreateWithoutDestinationsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutDestinationsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutDestinationsInput, CountryUncheckedUpdateWithoutDestinationsInput>
  }

  export type CountryUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUpdateManyWithoutCountryNestedInput
    airports?: AirportUpdateManyWithoutCountryNestedInput
    cities?: CityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airlines?: AirlineUncheckedUpdateManyWithoutCountryNestedInput
    airports?: AirportUncheckedUpdateManyWithoutCountryNestedInput
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type PromotionUpsertWithWhereUniqueWithoutDestinationInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutDestinationInput, PromotionUncheckedUpdateWithoutDestinationInput>
    create: XOR<PromotionCreateWithoutDestinationInput, PromotionUncheckedCreateWithoutDestinationInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutDestinationInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutDestinationInput, PromotionUncheckedUpdateWithoutDestinationInput>
  }

  export type PromotionUpdateManyWithWhereWithoutDestinationInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutDestinationInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: StringFilter<"Promotion"> | string
    title?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    code?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: FloatFilter<"Promotion"> | number
    minPurchase?: FloatNullableFilter<"Promotion"> | number | null
    maxDiscount?: FloatNullableFilter<"Promotion"> | number | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    usageLimit?: IntNullableFilter<"Promotion"> | number | null
    usedCount?: IntFilter<"Promotion"> | number
    isActive?: BoolFilter<"Promotion"> | boolean
    destinationId?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutDestinationInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutDestinationInput, ReviewUncheckedUpdateWithoutDestinationInput>
    create: XOR<ReviewCreateWithoutDestinationInput, ReviewUncheckedCreateWithoutDestinationInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutDestinationInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutDestinationInput, ReviewUncheckedUpdateWithoutDestinationInput>
  }

  export type ReviewUpdateManyWithWhereWithoutDestinationInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutDestinationInput>
  }

  export type BookingCreateWithoutFlightInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutFlightInput = {
    id?: string
    bookingReference: string
    userId: string
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutFlightInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput>
  }

  export type BookingCreateManyFlightInputEnvelope = {
    data: BookingCreateManyFlightInput | BookingCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type FlightScheduleCreateWithoutFlightInput = {
    id?: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightScheduleInput
  }

  export type FlightScheduleUncheckedCreateWithoutFlightInput = {
    id?: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightScheduleInput
  }

  export type FlightScheduleCreateOrConnectWithoutFlightInput = {
    where: FlightScheduleWhereUniqueInput
    create: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput>
  }

  export type FlightScheduleCreateManyFlightInputEnvelope = {
    data: FlightScheduleCreateManyFlightInput | FlightScheduleCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type AircraftCreateWithoutFlightsInput = {
    id?: string
    registration: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraftType: AircraftTypeCreateNestedOneWithoutAircraftInput
    airline: AirlineCreateNestedOneWithoutAircraftInput
  }

  export type AircraftUncheckedCreateWithoutFlightsInput = {
    id?: string
    registration: string
    airlineId: string
    aircraftTypeId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftCreateOrConnectWithoutFlightsInput = {
    where: AircraftWhereUniqueInput
    create: XOR<AircraftCreateWithoutFlightsInput, AircraftUncheckedCreateWithoutFlightsInput>
  }

  export type AirlineCreateWithoutFlightsInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftCreateNestedManyWithoutAirlineInput
    country: CountryCreateNestedOneWithoutAirlinesInput
    adminFlightSchedules?: AdminFlightScheduleCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUncheckedCreateWithoutFlightsInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    countryId: string
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftUncheckedCreateNestedManyWithoutAirlineInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type AirlineCreateOrConnectWithoutFlightsInput = {
    where: AirlineWhereUniqueInput
    create: XOR<AirlineCreateWithoutFlightsInput, AirlineUncheckedCreateWithoutFlightsInput>
  }

  export type AirportCreateWithoutArrivalFlightsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAirportsInput
    country: CountryCreateNestedOneWithoutAirportsInput
    destinations?: DestinationCreateNestedManyWithoutAirportInput
    departureFlights?: FlightCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportUncheckedCreateWithoutArrivalFlightsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutAirportInput
    departureFlights?: FlightUncheckedCreateNestedManyWithoutDepartureAirportInput
  }

  export type AirportCreateOrConnectWithoutArrivalFlightsInput = {
    where: AirportWhereUniqueInput
    create: XOR<AirportCreateWithoutArrivalFlightsInput, AirportUncheckedCreateWithoutArrivalFlightsInput>
  }

  export type AirportCreateWithoutDepartureFlightsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAirportsInput
    country: CountryCreateNestedOneWithoutAirportsInput
    destinations?: DestinationCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightCreateNestedManyWithoutArrivalAirportInput
  }

  export type AirportUncheckedCreateWithoutDepartureFlightsInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destinations?: DestinationUncheckedCreateNestedManyWithoutAirportInput
    arrivalFlights?: FlightUncheckedCreateNestedManyWithoutArrivalAirportInput
  }

  export type AirportCreateOrConnectWithoutDepartureFlightsInput = {
    where: AirportWhereUniqueInput
    create: XOR<AirportCreateWithoutDepartureFlightsInput, AirportUncheckedCreateWithoutDepartureFlightsInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutFlightInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutFlightInput, BookingUncheckedUpdateWithoutFlightInput>
    create: XOR<BookingCreateWithoutFlightInput, BookingUncheckedCreateWithoutFlightInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutFlightInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutFlightInput, BookingUncheckedUpdateWithoutFlightInput>
  }

  export type BookingUpdateManyWithWhereWithoutFlightInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutFlightInput>
  }

  export type FlightScheduleUpsertWithWhereUniqueWithoutFlightInput = {
    where: FlightScheduleWhereUniqueInput
    update: XOR<FlightScheduleUpdateWithoutFlightInput, FlightScheduleUncheckedUpdateWithoutFlightInput>
    create: XOR<FlightScheduleCreateWithoutFlightInput, FlightScheduleUncheckedCreateWithoutFlightInput>
  }

  export type FlightScheduleUpdateWithWhereUniqueWithoutFlightInput = {
    where: FlightScheduleWhereUniqueInput
    data: XOR<FlightScheduleUpdateWithoutFlightInput, FlightScheduleUncheckedUpdateWithoutFlightInput>
  }

  export type FlightScheduleUpdateManyWithWhereWithoutFlightInput = {
    where: FlightScheduleScalarWhereInput
    data: XOR<FlightScheduleUpdateManyMutationInput, FlightScheduleUncheckedUpdateManyWithoutFlightInput>
  }

  export type FlightScheduleScalarWhereInput = {
    AND?: FlightScheduleScalarWhereInput | FlightScheduleScalarWhereInput[]
    OR?: FlightScheduleScalarWhereInput[]
    NOT?: FlightScheduleScalarWhereInput | FlightScheduleScalarWhereInput[]
    id?: StringFilter<"FlightSchedule"> | string
    flightId?: StringFilter<"FlightSchedule"> | string
    classType?: StringFilter<"FlightSchedule"> | string
    availableSeats?: IntFilter<"FlightSchedule"> | number
    totalSeats?: IntFilter<"FlightSchedule"> | number
    basePrice?: FloatFilter<"FlightSchedule"> | number
    currentPrice?: FloatFilter<"FlightSchedule"> | number
    isActive?: BoolFilter<"FlightSchedule"> | boolean
    createdAt?: DateTimeFilter<"FlightSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"FlightSchedule"> | Date | string
  }

  export type AircraftUpsertWithoutFlightsInput = {
    update: XOR<AircraftUpdateWithoutFlightsInput, AircraftUncheckedUpdateWithoutFlightsInput>
    create: XOR<AircraftCreateWithoutFlightsInput, AircraftUncheckedCreateWithoutFlightsInput>
    where?: AircraftWhereInput
  }

  export type AircraftUpdateToOneWithWhereWithoutFlightsInput = {
    where?: AircraftWhereInput
    data: XOR<AircraftUpdateWithoutFlightsInput, AircraftUncheckedUpdateWithoutFlightsInput>
  }

  export type AircraftUpdateWithoutFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraftType?: AircraftTypeUpdateOneRequiredWithoutAircraftNestedInput
    airline?: AirlineUpdateOneRequiredWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateWithoutFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftTypeId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirlineUpsertWithoutFlightsInput = {
    update: XOR<AirlineUpdateWithoutFlightsInput, AirlineUncheckedUpdateWithoutFlightsInput>
    create: XOR<AirlineCreateWithoutFlightsInput, AirlineUncheckedCreateWithoutFlightsInput>
    where?: AirlineWhereInput
  }

  export type AirlineUpdateToOneWithWhereWithoutFlightsInput = {
    where?: AirlineWhereInput
    data: XOR<AirlineUpdateWithoutFlightsInput, AirlineUncheckedUpdateWithoutFlightsInput>
  }

  export type AirlineUpdateWithoutFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUpdateManyWithoutAirlineNestedInput
    country?: CountryUpdateOneRequiredWithoutAirlinesNestedInput
    adminFlightSchedules?: AdminFlightScheduleUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateWithoutFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUncheckedUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type AirportUpsertWithoutArrivalFlightsInput = {
    update: XOR<AirportUpdateWithoutArrivalFlightsInput, AirportUncheckedUpdateWithoutArrivalFlightsInput>
    create: XOR<AirportCreateWithoutArrivalFlightsInput, AirportUncheckedCreateWithoutArrivalFlightsInput>
    where?: AirportWhereInput
  }

  export type AirportUpdateToOneWithWhereWithoutArrivalFlightsInput = {
    where?: AirportWhereInput
    data: XOR<AirportUpdateWithoutArrivalFlightsInput, AirportUncheckedUpdateWithoutArrivalFlightsInput>
  }

  export type AirportUpdateWithoutArrivalFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAirportsNestedInput
    country?: CountryUpdateOneRequiredWithoutAirportsNestedInput
    destinations?: DestinationUpdateManyWithoutAirportNestedInput
    departureFlights?: FlightUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateWithoutArrivalFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutAirportNestedInput
    departureFlights?: FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUpsertWithoutDepartureFlightsInput = {
    update: XOR<AirportUpdateWithoutDepartureFlightsInput, AirportUncheckedUpdateWithoutDepartureFlightsInput>
    create: XOR<AirportCreateWithoutDepartureFlightsInput, AirportUncheckedCreateWithoutDepartureFlightsInput>
    where?: AirportWhereInput
  }

  export type AirportUpdateToOneWithWhereWithoutDepartureFlightsInput = {
    where?: AirportWhereInput
    data: XOR<AirportUpdateWithoutDepartureFlightsInput, AirportUncheckedUpdateWithoutDepartureFlightsInput>
  }

  export type AirportUpdateWithoutDepartureFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAirportsNestedInput
    country?: CountryUpdateOneRequiredWithoutAirportsNestedInput
    destinations?: DestinationUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUpdateManyWithoutArrivalAirportNestedInput
  }

  export type AirportUncheckedUpdateWithoutDepartureFlightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput
  }

  export type BookingCreateWithoutFlightScheduleInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutFlightScheduleInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutFlightScheduleInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput>
  }

  export type BookingCreateManyFlightScheduleInputEnvelope = {
    data: BookingCreateManyFlightScheduleInput | BookingCreateManyFlightScheduleInput[]
    skipDuplicates?: boolean
  }

  export type FlightCreateWithoutFlightSchedulesInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateWithoutFlightSchedulesInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutFlightSchedulesInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutFlightSchedulesInput, FlightUncheckedCreateWithoutFlightSchedulesInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutFlightScheduleInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutFlightScheduleInput, BookingUncheckedUpdateWithoutFlightScheduleInput>
    create: XOR<BookingCreateWithoutFlightScheduleInput, BookingUncheckedCreateWithoutFlightScheduleInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutFlightScheduleInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutFlightScheduleInput, BookingUncheckedUpdateWithoutFlightScheduleInput>
  }

  export type BookingUpdateManyWithWhereWithoutFlightScheduleInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutFlightScheduleInput>
  }

  export type FlightUpsertWithoutFlightSchedulesInput = {
    update: XOR<FlightUpdateWithoutFlightSchedulesInput, FlightUncheckedUpdateWithoutFlightSchedulesInput>
    create: XOR<FlightCreateWithoutFlightSchedulesInput, FlightUncheckedCreateWithoutFlightSchedulesInput>
    where?: FlightWhereInput
  }

  export type FlightUpdateToOneWithWhereWithoutFlightSchedulesInput = {
    where?: FlightWhereInput
    data: XOR<FlightUpdateWithoutFlightSchedulesInput, FlightUncheckedUpdateWithoutFlightSchedulesInput>
  }

  export type FlightUpdateWithoutFlightSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutFlightSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type DestinationCreateWithoutBookingsToInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutBookingsToInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutBookingsToInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutBookingsToInput, DestinationUncheckedCreateWithoutBookingsToInput>
  }

  export type FlightCreateWithoutBookingsInput = {
    id?: string
    flightNumber: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flightSchedules?: FlightScheduleCreateNestedManyWithoutFlightInput
    aircraft: AircraftCreateNestedOneWithoutFlightsInput
    airline: AirlineCreateNestedOneWithoutFlightsInput
    arrivalAirport: AirportCreateNestedOneWithoutArrivalFlightsInput
    departureAirport: AirportCreateNestedOneWithoutDepartureFlightsInput
  }

  export type FlightUncheckedCreateWithoutBookingsInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flightSchedules?: FlightScheduleUncheckedCreateNestedManyWithoutFlightInput
  }

  export type FlightCreateOrConnectWithoutBookingsInput = {
    where: FlightWhereUniqueInput
    create: XOR<FlightCreateWithoutBookingsInput, FlightUncheckedCreateWithoutBookingsInput>
  }

  export type FlightScheduleCreateWithoutBookingsInput = {
    id?: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flight: FlightCreateNestedOneWithoutFlightSchedulesInput
  }

  export type FlightScheduleUncheckedCreateWithoutBookingsInput = {
    id?: string
    flightId: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightScheduleCreateOrConnectWithoutBookingsInput = {
    where: FlightScheduleWhereUniqueInput
    create: XOR<FlightScheduleCreateWithoutBookingsInput, FlightScheduleUncheckedCreateWithoutBookingsInput>
  }

  export type DestinationCreateWithoutBookingsFromInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutBookingsFromInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutBookingsFromInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutBookingsFromInput, DestinationUncheckedCreateWithoutBookingsFromInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type NotificationCreateWithoutBookingInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationCreateManyBookingInputEnvelope = {
    data: NotificationCreateManyBookingInput | NotificationCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PassengerDetailCreateWithoutBookingInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerDetailUncheckedCreateWithoutBookingInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerDetailCreateOrConnectWithoutBookingInput = {
    where: PassengerDetailWhereUniqueInput
    create: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput>
  }

  export type PassengerDetailCreateManyBookingInputEnvelope = {
    data: PassengerDetailCreateManyBookingInput | PassengerDetailCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type DestinationUpsertWithoutBookingsToInput = {
    update: XOR<DestinationUpdateWithoutBookingsToInput, DestinationUncheckedUpdateWithoutBookingsToInput>
    create: XOR<DestinationCreateWithoutBookingsToInput, DestinationUncheckedCreateWithoutBookingsToInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutBookingsToInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutBookingsToInput, DestinationUncheckedUpdateWithoutBookingsToInput>
  }

  export type DestinationUpdateWithoutBookingsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutBookingsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type FlightUpsertWithoutBookingsInput = {
    update: XOR<FlightUpdateWithoutBookingsInput, FlightUncheckedUpdateWithoutBookingsInput>
    create: XOR<FlightCreateWithoutBookingsInput, FlightUncheckedCreateWithoutBookingsInput>
    where?: FlightWhereInput
  }

  export type FlightUpdateToOneWithWhereWithoutBookingsInput = {
    where?: FlightWhereInput
    data: XOR<FlightUpdateWithoutBookingsInput, FlightUncheckedUpdateWithoutBookingsInput>
  }

  export type FlightUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightScheduleUpsertWithoutBookingsInput = {
    update: XOR<FlightScheduleUpdateWithoutBookingsInput, FlightScheduleUncheckedUpdateWithoutBookingsInput>
    create: XOR<FlightScheduleCreateWithoutBookingsInput, FlightScheduleUncheckedCreateWithoutBookingsInput>
    where?: FlightScheduleWhereInput
  }

  export type FlightScheduleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: FlightScheduleWhereInput
    data: XOR<FlightScheduleUpdateWithoutBookingsInput, FlightScheduleUncheckedUpdateWithoutBookingsInput>
  }

  export type FlightScheduleUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flight?: FlightUpdateOneRequiredWithoutFlightSchedulesNestedInput
  }

  export type FlightScheduleUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUpsertWithoutBookingsFromInput = {
    update: XOR<DestinationUpdateWithoutBookingsFromInput, DestinationUncheckedUpdateWithoutBookingsFromInput>
    create: XOR<DestinationCreateWithoutBookingsFromInput, DestinationUncheckedCreateWithoutBookingsFromInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutBookingsFromInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutBookingsFromInput, DestinationUncheckedUpdateWithoutBookingsFromInput>
  }

  export type DestinationUpdateWithoutBookingsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutBookingsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBookingInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBookingInput>
  }

  export type PassengerDetailUpsertWithWhereUniqueWithoutBookingInput = {
    where: PassengerDetailWhereUniqueInput
    update: XOR<PassengerDetailUpdateWithoutBookingInput, PassengerDetailUncheckedUpdateWithoutBookingInput>
    create: XOR<PassengerDetailCreateWithoutBookingInput, PassengerDetailUncheckedCreateWithoutBookingInput>
  }

  export type PassengerDetailUpdateWithWhereUniqueWithoutBookingInput = {
    where: PassengerDetailWhereUniqueInput
    data: XOR<PassengerDetailUpdateWithoutBookingInput, PassengerDetailUncheckedUpdateWithoutBookingInput>
  }

  export type PassengerDetailUpdateManyWithWhereWithoutBookingInput = {
    where: PassengerDetailScalarWhereInput
    data: XOR<PassengerDetailUpdateManyMutationInput, PassengerDetailUncheckedUpdateManyWithoutBookingInput>
  }

  export type PassengerDetailScalarWhereInput = {
    AND?: PassengerDetailScalarWhereInput | PassengerDetailScalarWhereInput[]
    OR?: PassengerDetailScalarWhereInput[]
    NOT?: PassengerDetailScalarWhereInput | PassengerDetailScalarWhereInput[]
    id?: StringFilter<"PassengerDetail"> | string
    bookingId?: StringFilter<"PassengerDetail"> | string
    title?: StringFilter<"PassengerDetail"> | string
    firstName?: StringFilter<"PassengerDetail"> | string
    lastName?: StringFilter<"PassengerDetail"> | string
    dateOfBirth?: DateTimeFilter<"PassengerDetail"> | Date | string
    nationality?: StringFilter<"PassengerDetail"> | string
    passportNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    passportExpiry?: DateTimeNullableFilter<"PassengerDetail"> | Date | string | null
    seatNumber?: StringNullableFilter<"PassengerDetail"> | string | null
    mealPreference?: StringNullableFilter<"PassengerDetail"> | string | null
    specialRequests?: StringNullableFilter<"PassengerDetail"> | string | null
    createdAt?: DateTimeFilter<"PassengerDetail"> | Date | string
    updatedAt?: DateTimeFilter<"PassengerDetail"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCreateWithoutPassengersInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPassengersInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPassengersInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
  }

  export type BookingUpsertWithoutPassengersInput = {
    update: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPassengersInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type BookingUpdateWithoutPassengersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPassengersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DestinationCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    promotions?: PromotionCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutReviewsInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutReviewsInput, DestinationUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type DestinationUpsertWithoutReviewsInput = {
    update: XOR<DestinationUpdateWithoutReviewsInput, DestinationUncheckedUpdateWithoutReviewsInput>
    create: XOR<DestinationCreateWithoutReviewsInput, DestinationUncheckedCreateWithoutReviewsInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutReviewsInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutReviewsInput, DestinationUncheckedUpdateWithoutReviewsInput>
  }

  export type DestinationUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DestinationCreateWithoutPromotionsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingCreateNestedManyWithoutFromDestinationInput
    airport: AirportCreateNestedOneWithoutDestinationsInput
    city: CityCreateNestedOneWithoutDestinationsInput
    country: CountryCreateNestedOneWithoutDestinationsInput
    reviews?: ReviewCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingsTo?: BookingUncheckedCreateNestedManyWithoutDestinationInput
    bookingsFrom?: BookingUncheckedCreateNestedManyWithoutFromDestinationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutPromotionsInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutPromotionsInput, DestinationUncheckedCreateWithoutPromotionsInput>
  }

  export type DestinationUpsertWithoutPromotionsInput = {
    update: XOR<DestinationUpdateWithoutPromotionsInput, DestinationUncheckedUpdateWithoutPromotionsInput>
    create: XOR<DestinationCreateWithoutPromotionsInput, DestinationUncheckedCreateWithoutPromotionsInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutPromotionsInput, DestinationUncheckedUpdateWithoutPromotionsInput>
  }

  export type DestinationUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type BookingCreateWithoutNotificationsInput = {
    id?: string
    bookingReference: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: DestinationCreateNestedOneWithoutBookingsToInput
    flight?: FlightCreateNestedOneWithoutBookingsInput
    flightSchedule?: FlightScheduleCreateNestedOneWithoutBookingsInput
    fromDestination: DestinationCreateNestedOneWithoutBookingsFromInput
    user: UserCreateNestedOneWithoutBookingsInput
    passengers?: PassengerDetailCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutNotificationsInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passengers?: PassengerDetailUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutNotificationsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    passportNumber?: string | null
    role?: string
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type BookingUpsertWithoutNotificationsInput = {
    update: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type BookingUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AirlineCreateWithoutAdminFlightSchedulesInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftCreateNestedManyWithoutAirlineInput
    country: CountryCreateNestedOneWithoutAirlinesInput
    flights?: FlightCreateNestedManyWithoutAirlineInput
  }

  export type AirlineUncheckedCreateWithoutAdminFlightSchedulesInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    countryId: string
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aircraft?: AircraftUncheckedCreateNestedManyWithoutAirlineInput
    flights?: FlightUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type AirlineCreateOrConnectWithoutAdminFlightSchedulesInput = {
    where: AirlineWhereUniqueInput
    create: XOR<AirlineCreateWithoutAdminFlightSchedulesInput, AirlineUncheckedCreateWithoutAdminFlightSchedulesInput>
  }

  export type AirlineUpsertWithoutAdminFlightSchedulesInput = {
    update: XOR<AirlineUpdateWithoutAdminFlightSchedulesInput, AirlineUncheckedUpdateWithoutAdminFlightSchedulesInput>
    create: XOR<AirlineCreateWithoutAdminFlightSchedulesInput, AirlineUncheckedCreateWithoutAdminFlightSchedulesInput>
    where?: AirlineWhereInput
  }

  export type AirlineUpdateToOneWithWhereWithoutAdminFlightSchedulesInput = {
    where?: AirlineWhereInput
    data: XOR<AirlineUpdateWithoutAdminFlightSchedulesInput, AirlineUncheckedUpdateWithoutAdminFlightSchedulesInput>
  }

  export type AirlineUpdateWithoutAdminFlightSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUpdateManyWithoutAirlineNestedInput
    country?: CountryUpdateOneRequiredWithoutAirlinesNestedInput
    flights?: FlightUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateWithoutAdminFlightSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUncheckedUpdateManyWithoutAirlineNestedInput
    flights?: FlightUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type BookingCreateManyUserInput = {
    id?: string
    bookingReference: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    bookingId?: string | null
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    destinationId?: string | null
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirlineCreateManyCountryInput = {
    id?: string
    name: string
    code: string
    icaoCode?: string | null
    logo?: string | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirportCreateManyCountryInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    cityId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateManyCountryInput = {
    id?: string
    name: string
    state?: string | null
    population?: number | null
    timezone?: string | null
    lat?: number | null
    lon?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationCreateManyCountryInput = {
    id?: string
    name: string
    cityId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirlineUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUpdateManyWithoutAirlineNestedInput
    flights?: FlightUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraft?: AircraftUncheckedUpdateManyWithoutAirlineNestedInput
    flights?: FlightUncheckedUpdateManyWithoutAirlineNestedInput
    adminFlightSchedules?: AdminFlightScheduleUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type AirlineUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirportUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAirportsNestedInput
    destinations?: DestinationUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUpdateManyWithoutCityNestedInput
    destinations?: DestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airports?: AirportUncheckedUpdateManyWithoutCityNestedInput
    destinations?: DestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirportCreateManyCityInput = {
    id?: string
    name: string
    iataCode?: string | null
    icaoCode?: string | null
    countryId: string
    municipality?: string | null
    lat?: number | null
    lon?: number | null
    elevation?: number | null
    timezone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationCreateManyCityInput = {
    id?: string
    name: string
    countryId: string
    airportId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirportUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutAirportsNestedInput
    destinations?: DestinationUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinations?: DestinationUncheckedUpdateManyWithoutAirportNestedInput
    arrivalFlights?: FlightUncheckedUpdateManyWithoutArrivalAirportNestedInput
    departureFlights?: FlightUncheckedUpdateManyWithoutDepartureAirportNestedInput
  }

  export type AirportUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iataCode?: NullableStringFieldUpdateOperationsInput | string | null
    icaoCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    elevation?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    airport?: AirportUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    airportId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateManyAirportInput = {
    id?: string
    name: string
    cityId: string
    countryId: string
    description?: string | null
    imageUrl?: string | null
    category: string
    rating?: number | null
    isActive?: boolean
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightCreateManyArrivalAirportInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    departureAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightCreateManyDepartureAirportInput = {
    id?: string
    flightNumber: string
    airlineId: string
    aircraftId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DestinationUpdateWithoutAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUpdateManyWithoutFromDestinationNestedInput
    city?: CityUpdateOneRequiredWithoutDestinationsNestedInput
    country?: CountryUpdateOneRequiredWithoutDestinationsNestedInput
    promotions?: PromotionUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsTo?: BookingUncheckedUpdateManyWithoutDestinationNestedInput
    bookingsFrom?: BookingUncheckedUpdateManyWithoutFromDestinationNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutDestinationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateManyWithoutAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUpdateWithoutArrivalAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutArrivalAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightUncheckedUpdateManyWithoutArrivalAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUpdateWithoutDepartureAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutDepartureAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightUncheckedUpdateManyWithoutDepartureAirportInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftCreateManyAirlineInput = {
    id?: string
    registration: string
    aircraftTypeId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightCreateManyAirlineInput = {
    id?: string
    flightNumber: string
    aircraftId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminFlightScheduleCreateManyAirlineInput = {
    id?: string
    flightNo: string
    origin: string
    destination: string
    departure: Date | string
    arrival: Date | string
    basePrice: number
    seats: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aircraftType?: AircraftTypeUpdateOneRequiredWithoutAircraftNestedInput
    flights?: FlightUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    aircraftTypeId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flights?: FlightUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateManyWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    aircraftTypeId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    aircraft?: AircraftUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightUncheckedUpdateManyWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleUncheckedUpdateWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminFlightScheduleUncheckedUpdateManyWithoutAirlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNo?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departure?: DateTimeFieldUpdateOperationsInput | Date | string
    arrival?: DateTimeFieldUpdateOperationsInput | Date | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AircraftCreateManyAircraftTypeInput = {
    id?: string
    registration: string
    airlineId: string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AircraftUpdateWithoutAircraftTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    airline?: AirlineUpdateOneRequiredWithoutAircraftNestedInput
    flights?: FlightUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateWithoutAircraftTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flights?: FlightUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type AircraftUncheckedUpdateManyWithoutAircraftTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    registration?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightCreateManyAircraftInput = {
    id?: string
    flightNumber: string
    airlineId: string
    departureAirportId: string
    arrivalAirportId: string
    departureTime: Date | string
    arrivalTime: Date | string
    duration: number
    distance?: number | null
    status?: string
    gate?: string | null
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUpdateManyWithoutFlightNestedInput
    airline?: AirlineUpdateOneRequiredWithoutFlightsNestedInput
    arrivalAirport?: AirportUpdateOneRequiredWithoutArrivalFlightsNestedInput
    departureAirport?: AirportUpdateOneRequiredWithoutDepartureFlightsNestedInput
  }

  export type FlightUncheckedUpdateWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightNestedInput
    flightSchedules?: FlightScheduleUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type FlightUncheckedUpdateManyWithoutAircraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    airlineId?: StringFieldUpdateOperationsInput | string
    departureAirportId?: StringFieldUpdateOperationsInput | string
    arrivalAirportId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    gate?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyDestinationInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyFromDestinationInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    flightScheduleId?: string | null
    destinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateManyDestinationInput = {
    id?: string
    title: string
    description?: string | null
    code?: string | null
    discountType: string
    discountValue: number
    minPurchase?: number | null
    maxDiscount?: number | null
    startDate: Date | string
    endDate: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyDestinationInput = {
    id?: string
    userId: string
    bookingId?: string | null
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutFromDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutFromDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutFromDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    minPurchase?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyFlightInput = {
    id?: string
    bookingReference: string
    userId: string
    flightScheduleId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightScheduleCreateManyFlightInput = {
    id?: string
    classType: string
    availableSeats: number
    totalSeats: number
    basePrice: number
    currentPrice: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flightSchedule?: FlightScheduleUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightScheduleUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutFlightScheduleNestedInput
  }

  export type FlightScheduleUncheckedUpdateWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutFlightScheduleNestedInput
  }

  export type FlightScheduleUncheckedUpdateManyWithoutFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    classType?: StringFieldUpdateOperationsInput | string
    availableSeats?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyFlightScheduleInput = {
    id?: string
    bookingReference: string
    userId: string
    flightId?: string | null
    destinationId: string
    fromDestinationId: string
    departureDate: Date | string
    returnDate?: Date | string | null
    passengerCount: number
    bookingClass: string
    totalPrice: number
    taxes?: number
    fees?: number
    discountAmount?: number
    finalPrice: number
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutFlightScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: DestinationUpdateOneRequiredWithoutBookingsToNestedInput
    flight?: FlightUpdateOneWithoutBookingsNestedInput
    fromDestination?: DestinationUpdateOneRequiredWithoutBookingsFromNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutFlightScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerDetailUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutFlightScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingReference?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flightId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationId?: StringFieldUpdateOperationsInput | string
    fromDestinationId?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passengerCount?: IntFieldUpdateOperationsInput | number
    bookingClass?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    fees?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyBookingInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerDetailCreateManyBookingInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    seatNumber?: string | null
    mealPreference?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    paymentMethod: string
    paymentProvider?: string | null
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    failedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerDetailUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mealPreference?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}